{"mappings":"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","sources":["<anon>","node_modules/chart.js/dist/chart.umd.js","node_modules/chart.js/src/helpers/helpers.core.ts","node_modules/chart.js/src/helpers/helpers.math.ts","node_modules/chart.js/src/helpers/helpers.collection.ts","node_modules/chart.js/src/helpers/helpers.extras.ts","node_modules/chart.js/src/core/core.animator.js","node_modules/chart.js/node_modules/.pnpm/@kurkle+color@0.3.2/node_modules/@kurkle/color/dist/color.esm.js","node_modules/chart.js/src/helpers/helpers.color.ts","node_modules/chart.js/src/core/core.animations.defaults.js","node_modules/chart.js/src/helpers/helpers.intl.ts","node_modules/chart.js/src/core/core.ticks.js","node_modules/chart.js/src/core/core.defaults.js","node_modules/chart.js/src/core/core.layouts.defaults.js","node_modules/chart.js/src/core/core.scale.defaults.js","node_modules/chart.js/src/helpers/helpers.dom.ts","node_modules/chart.js/src/helpers/helpers.canvas.ts","node_modules/chart.js/src/helpers/helpers.config.ts","node_modules/chart.js/src/helpers/helpers.curve.ts","node_modules/chart.js/src/helpers/helpers.easing.ts","node_modules/chart.js/src/helpers/helpers.interpolation.ts","node_modules/chart.js/src/helpers/helpers.options.ts","node_modules/chart.js/src/helpers/helpers.rtl.ts","node_modules/chart.js/src/helpers/helpers.segment.js","node_modules/chart.js/src/core/core.interaction.js","node_modules/chart.js/src/core/core.layouts.js","node_modules/chart.js/src/platform/platform.base.js","node_modules/chart.js/src/platform/platform.basic.js","node_modules/chart.js/src/platform/platform.dom.js","node_modules/chart.js/src/platform/index.js","node_modules/chart.js/src/core/core.animation.js","node_modules/chart.js/src/core/core.animations.js","node_modules/chart.js/src/core/core.datasetController.js","node_modules/chart.js/src/core/core.element.ts","node_modules/chart.js/src/core/core.scale.autoskip.js","node_modules/chart.js/src/core/core.scale.js","node_modules/chart.js/src/core/core.typedRegistry.js","node_modules/chart.js/src/core/core.registry.js","node_modules/chart.js/src/core/core.plugins.js","node_modules/chart.js/src/core/core.config.js","node_modules/chart.js/src/core/core.controller.js","node_modules/chart.js/src/core/core.adapters.ts","node_modules/chart.js/src/controllers/controller.bar.js","node_modules/chart.js/src/controllers/controller.doughnut.js","node_modules/chart.js/src/controllers/controller.polarArea.js","node_modules/chart.js/src/controllers/controller.bubble.js","node_modules/chart.js/src/controllers/controller.line.js","node_modules/chart.js/src/controllers/controller.pie.js","node_modules/chart.js/src/controllers/controller.radar.js","node_modules/chart.js/src/controllers/controller.scatter.js","node_modules/chart.js/src/elements/element.arc.ts","node_modules/chart.js/src/elements/element.line.js","node_modules/chart.js/src/elements/element.point.ts","node_modules/chart.js/src/elements/element.bar.js","node_modules/chart.js/src/scales/scale.category.js","node_modules/chart.js/src/scales/scale.linearbase.js","node_modules/chart.js/src/scales/scale.linear.js","node_modules/chart.js/src/scales/scale.logarithmic.js","node_modules/chart.js/src/scales/scale.radialLinear.js","node_modules/chart.js/src/scales/scale.time.js","node_modules/chart.js/src/scales/scale.timeseries.js","node_modules/chart.js/src/plugins/plugin.colors.ts","node_modules/chart.js/src/plugins/plugin.decimation.js","node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","node_modules/chart.js/src/plugins/plugin.filler/index.js","node_modules/chart.js/src/plugins/plugin.legend.js","node_modules/chart.js/src/plugins/plugin.title.js","node_modules/chart.js/src/plugins/plugin.subtitle.js","node_modules/chart.js/src/plugins/plugin.tooltip.js","node_modules/chart.js/src/index.umd.ts"],"sourcesContent":["/*!\n * Chart.js v4.3.3\n * https://www.chartjs.org\n * (c) 2023 Chart.js Contributors\n * Released under the MIT License\n */ !function(t, e) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).Chart = e();\n}(this, function() {\n    \"use strict\";\n    var t = Object.freeze({\n        __proto__: null,\n        get Colors () {\n            return Ko;\n        },\n        get Decimation () {\n            return Jo;\n        },\n        get Filler () {\n            return pa;\n        },\n        get Legend () {\n            return _a;\n        },\n        get SubTitle () {\n            return wa;\n        },\n        get Title () {\n            return va;\n        },\n        get Tooltip () {\n            return Va;\n        }\n    });\n    function e() {}\n    const i = (()=>{\n        let t = 0;\n        return ()=>t++;\n    })();\n    function s(t) {\n        return null == t;\n    }\n    function n(t) {\n        if (Array.isArray && Array.isArray(t)) return !0;\n        const e = Object.prototype.toString.call(t);\n        return \"[object\" === e.slice(0, 7) && \"Array]\" === e.slice(-6);\n    }\n    function o(t) {\n        return null !== t && \"[object Object]\" === Object.prototype.toString.call(t);\n    }\n    function a(t) {\n        return (\"number\" == typeof t || t instanceof Number) && isFinite(+t);\n    }\n    function r(t, e) {\n        return a(t) ? t : e;\n    }\n    function l(t, e) {\n        return void 0 === t ? e : t;\n    }\n    const h = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 : +t / e, c = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 * e : +t;\n    function d(t, e, i) {\n        if (t && \"function\" == typeof t.call) return t.apply(i, e);\n    }\n    function u(t, e, i, s) {\n        let a, r, l;\n        if (n(t)) {\n            if (r = t.length, s) for(a = r - 1; a >= 0; a--)e.call(i, t[a], a);\n            else for(a = 0; a < r; a++)e.call(i, t[a], a);\n        } else if (o(t)) for(l = Object.keys(t), r = l.length, a = 0; a < r; a++)e.call(i, t[l[a]], l[a]);\n    }\n    function f(t, e) {\n        let i, s, n, o;\n        if (!t || !e || t.length !== e.length) return !1;\n        for(i = 0, s = t.length; i < s; ++i)if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n        return !0;\n    }\n    function g(t) {\n        if (n(t)) return t.map(g);\n        if (o(t)) {\n            const e = Object.create(null), i = Object.keys(t), s = i.length;\n            let n = 0;\n            for(; n < s; ++n)e[i[n]] = g(t[i[n]]);\n            return e;\n        }\n        return t;\n    }\n    function p(t) {\n        return -1 === [\n            \"__proto__\",\n            \"prototype\",\n            \"constructor\"\n        ].indexOf(t);\n    }\n    function m(t, e, i, s) {\n        if (!p(t)) return;\n        const n = e[t], a = i[t];\n        o(n) && o(a) ? b(n, a, s) : e[t] = g(a);\n    }\n    function b(t, e, i) {\n        const s = n(e) ? e : [\n            e\n        ], a = s.length;\n        if (!o(t)) return t;\n        const r = (i = i || {}).merger || m;\n        let l;\n        for(let e = 0; e < a; ++e){\n            if (l = s[e], !o(l)) continue;\n            const n = Object.keys(l);\n            for(let e = 0, s = n.length; e < s; ++e)r(n[e], t, l, i);\n        }\n        return t;\n    }\n    function x(t, e) {\n        return b(t, e, {\n            merger: _\n        });\n    }\n    function _(t, e, i) {\n        if (!p(t)) return;\n        const s = e[t], n = i[t];\n        o(s) && o(n) ? x(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n));\n    }\n    const y = {\n        \"\": (t)=>t,\n        x: (t)=>t.x,\n        y: (t)=>t.y\n    };\n    function v(t) {\n        const e = t.split(\".\"), i = [];\n        let s = \"\";\n        for (const t of e)s += t, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (i.push(s), s = \"\");\n        return i;\n    }\n    function M(t, e) {\n        const i = y[e] || (y[e] = function(t) {\n            const e = v(t);\n            return (t)=>{\n                for (const i of e){\n                    if (\"\" === i) break;\n                    t = t && t[i];\n                }\n                return t;\n            };\n        }(e));\n        return i(t);\n    }\n    function w(t) {\n        return t.charAt(0).toUpperCase() + t.slice(1);\n    }\n    const k = (t)=>void 0 !== t, S = (t)=>\"function\" == typeof t, P = (t, e)=>{\n        if (t.size !== e.size) return !1;\n        for (const i of t)if (!e.has(i)) return !1;\n        return !0;\n    };\n    function D(t) {\n        return \"mouseup\" === t.type || \"click\" === t.type || \"contextmenu\" === t.type;\n    }\n    const C = Math.PI, O = 2 * C, A = O + C, T = Number.POSITIVE_INFINITY, L = C / 180, E = C / 2, R = C / 4, I = 2 * C / 3, z = Math.log10, F = Math.sign;\n    function V(t, e, i) {\n        return Math.abs(t - e) < i;\n    }\n    function B(t) {\n        const e = Math.round(t);\n        t = V(t, e, t / 1e3) ? e : t;\n        const i = Math.pow(10, Math.floor(z(t))), s = t / i;\n        return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i;\n    }\n    function W(t) {\n        const e = [], i = Math.sqrt(t);\n        let s;\n        for(s = 1; s < i; s++)t % s == 0 && (e.push(s), e.push(t / s));\n        return i === (0 | i) && e.push(i), e.sort((t, e)=>t - e).pop(), e;\n    }\n    function N(t) {\n        return !isNaN(parseFloat(t)) && isFinite(t);\n    }\n    function H(t, e) {\n        const i = Math.round(t);\n        return i - e <= t && i + e >= t;\n    }\n    function j(t, e, i) {\n        let s, n, o;\n        for(s = 0, n = t.length; s < n; s++)o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));\n    }\n    function $(t) {\n        return t * (C / 180);\n    }\n    function Y(t) {\n        return t * (180 / C);\n    }\n    function U(t) {\n        if (!a(t)) return;\n        let e = 1, i = 0;\n        for(; Math.round(t * e) / e !== t;)e *= 10, i++;\n        return i;\n    }\n    function X(t, e) {\n        const i = e.x - t.x, s = e.y - t.y, n = Math.sqrt(i * i + s * s);\n        let o = Math.atan2(s, i);\n        return o < -0.5 * C && (o += O), {\n            angle: o,\n            distance: n\n        };\n    }\n    function q(t, e) {\n        return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }\n    function K(t, e) {\n        return (t - e + A) % O - C;\n    }\n    function G(t) {\n        return (t % O + O) % O;\n    }\n    function Z(t, e, i, s) {\n        const n = G(t), o = G(e), a = G(i), r = G(o - n), l = G(a - n), h = G(n - o), c = G(n - a);\n        return n === o || n === a || s && o === a || r > l && h < c;\n    }\n    function J(t, e, i) {\n        return Math.max(e, Math.min(i, t));\n    }\n    function Q(t) {\n        return J(t, -32768, 32767);\n    }\n    function tt(t, e, i, s = 1e-6) {\n        return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s;\n    }\n    function et(t, e, i) {\n        i = i || ((i)=>t[i] < e);\n        let s, n = t.length - 1, o = 0;\n        for(; n - o > 1;)s = o + n >> 1, i(s) ? o = s : n = s;\n        return {\n            lo: o,\n            hi: n\n        };\n    }\n    const it = (t, e, i, s)=>et(t, i, s ? (s)=>{\n            const n = t[s][e];\n            return n < i || n === i && t[s + 1][e] === i;\n        } : (s)=>t[s][e] < i), st = (t, e, i)=>et(t, i, (s)=>t[s][e] >= i);\n    function nt(t, e, i) {\n        let s = 0, n = t.length;\n        for(; s < n && t[s] < e;)s++;\n        for(; n > s && t[n - 1] > i;)n--;\n        return s > 0 || n < t.length ? t.slice(s, n) : t;\n    }\n    const ot = [\n        \"push\",\n        \"pop\",\n        \"shift\",\n        \"splice\",\n        \"unshift\"\n    ];\n    function at(t, e) {\n        t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, \"_chartjs\", {\n            configurable: !0,\n            enumerable: !1,\n            value: {\n                listeners: [\n                    e\n                ]\n            }\n        }), ot.forEach((e)=>{\n            const i = \"_onData\" + w(e), s = t[e];\n            Object.defineProperty(t, e, {\n                configurable: !0,\n                enumerable: !1,\n                value (...e) {\n                    const n = s.apply(this, e);\n                    return t._chartjs.listeners.forEach((t)=>{\n                        \"function\" == typeof t[i] && t[i](...e);\n                    }), n;\n                }\n            });\n        }));\n    }\n    function rt(t, e) {\n        const i = t._chartjs;\n        if (!i) return;\n        const s = i.listeners, n = s.indexOf(e);\n        -1 !== n && s.splice(n, 1), s.length > 0 || (ot.forEach((e)=>{\n            delete t[e];\n        }), delete t._chartjs);\n    }\n    function lt(t) {\n        const e = new Set(t);\n        return e.size === t.length ? t : Array.from(e);\n    }\n    const ht = \"undefined\" == typeof window ? function(t) {\n        return t();\n    } : window.requestAnimationFrame;\n    function ct(t, e) {\n        let i = [], s = !1;\n        return function(...n) {\n            i = n, s || (s = !0, ht.call(window, ()=>{\n                s = !1, t.apply(e, i);\n            }));\n        };\n    }\n    function dt(t, e) {\n        let i;\n        return function(...s) {\n            return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e;\n        };\n    }\n    const ut = (t)=>\"start\" === t ? \"left\" : \"end\" === t ? \"right\" : \"center\", ft = (t, e, i)=>\"start\" === t ? e : \"end\" === t ? i : (e + i) / 2, gt = (t, e, i, s)=>t === (s ? \"left\" : \"right\") ? i : \"center\" === t ? (e + i) / 2 : e;\n    function pt(t, e, i) {\n        const s = e.length;\n        let n = 0, o = s;\n        if (t._sorted) {\n            const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds();\n            d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n;\n        }\n        return {\n            start: n,\n            count: o\n        };\n    }\n    function mt(t) {\n        const { xScale: e, yScale: i, _scaleRanges: s } = t, n = {\n            xmin: e.min,\n            xmax: e.max,\n            ymin: i.min,\n            ymax: i.max\n        };\n        if (!s) return t._scaleRanges = n, !0;\n        const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;\n        return Object.assign(s, n), o;\n    }\n    class bt {\n        constructor(){\n            this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0;\n        }\n        _notify(t, e, i, s) {\n            const n = e.listeners[s], o = e.duration;\n            n.forEach((s)=>s({\n                    chart: t,\n                    initial: e.initial,\n                    numSteps: o,\n                    currentStep: Math.min(i - e.start, o)\n                }));\n        }\n        _refresh() {\n            this._request || (this._running = !0, this._request = ht.call(window, ()=>{\n                this._update(), this._request = null, this._running && this._refresh();\n            }));\n        }\n        _update(t = Date.now()) {\n            let e = 0;\n            this._charts.forEach((i, s)=>{\n                if (!i.running || !i.items.length) return;\n                const n = i.items;\n                let o, a = n.length - 1, r = !1;\n                for(; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());\n                r && (s.draw(), this._notify(s, i, t, \"progress\")), n.length || (i.running = !1, this._notify(s, i, t, \"complete\"), i.initial = !1), e += n.length;\n            }), this._lastDate = t, 0 === e && (this._running = !1);\n        }\n        _getAnims(t) {\n            const e = this._charts;\n            let i = e.get(t);\n            return i || (i = {\n                running: !1,\n                initial: !0,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            }, e.set(t, i)), i;\n        }\n        listen(t, e, i) {\n            this._getAnims(t).listeners[e].push(i);\n        }\n        add(t, e) {\n            e && e.length && this._getAnims(t).items.push(...e);\n        }\n        has(t) {\n            return this._getAnims(t).items.length > 0;\n        }\n        start(t) {\n            const e = this._charts.get(t);\n            e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e)=>Math.max(t, e._duration), 0), this._refresh());\n        }\n        running(t) {\n            if (!this._running) return !1;\n            const e = this._charts.get(t);\n            return !!(e && e.running && e.items.length);\n        }\n        stop(t) {\n            const e = this._charts.get(t);\n            if (!e || !e.items.length) return;\n            const i = e.items;\n            let s = i.length - 1;\n            for(; s >= 0; --s)i[s].cancel();\n            e.items = [], this._notify(t, e, Date.now(), \"complete\");\n        }\n        remove(t) {\n            return this._charts.delete(t);\n        }\n    }\n    var xt = new bt;\n    /*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */ function _t(t) {\n        return t + .5 | 0;\n    }\n    const yt = (t, e, i)=>Math.max(Math.min(t, i), e);\n    function vt(t) {\n        return yt(_t(2.55 * t), 0, 255);\n    }\n    function Mt(t) {\n        return yt(_t(255 * t), 0, 255);\n    }\n    function wt(t) {\n        return yt(_t(t / 2.55) / 100, 0, 1);\n    }\n    function kt(t) {\n        return yt(_t(100 * t), 0, 100);\n    }\n    const St = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        A: 10,\n        B: 11,\n        C: 12,\n        D: 13,\n        E: 14,\n        F: 15,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }, Pt = [\n        ...\"0123456789ABCDEF\"\n    ], Dt = (t)=>Pt[15 & t], Ct = (t)=>Pt[(240 & t) >> 4] + Pt[15 & t], Ot = (t)=>(240 & t) >> 4 == (15 & t);\n    function At(t) {\n        var e = ((t)=>Ot(t.r) && Ot(t.g) && Ot(t.b) && Ot(t.a))(t) ? Dt : Ct;\n        return t ? \"#\" + e(t.r) + e(t.g) + e(t.b) + ((t, e)=>t < 255 ? e(t) : \"\")(t.a, e) : void 0;\n    }\n    const Tt = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    function Lt(t, e, i) {\n        const s = e * Math.min(i, 1 - i), n = (e, n = (e + t / 30) % 12)=>i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);\n        return [\n            n(0),\n            n(8),\n            n(4)\n        ];\n    }\n    function Et(t, e, i) {\n        const s = (s, n = (s + t / 60) % 6)=>i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);\n        return [\n            s(5),\n            s(3),\n            s(1)\n        ];\n    }\n    function Rt(t, e, i) {\n        const s = Lt(t, 1, .5);\n        let n;\n        for(e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++)s[n] *= 1 - e - i, s[n] += e;\n        return s;\n    }\n    function It(t) {\n        const e = t.r / 255, i = t.g / 255, s = t.b / 255, n = Math.max(e, i, s), o = Math.min(e, i, s), a = (n + o) / 2;\n        let r, l, h;\n        return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function(t, e, i, s, n) {\n            return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4;\n        }(e, i, s, h, n), r = 60 * r + .5), [\n            0 | r,\n            l || 0,\n            a\n        ];\n    }\n    function zt(t, e, i, s) {\n        return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt);\n    }\n    function Ft(t, e, i) {\n        return zt(Lt, t, e, i);\n    }\n    function Vt(t) {\n        return (t % 360 + 360) % 360;\n    }\n    function Bt(t) {\n        const e = Tt.exec(t);\n        let i, s = 255;\n        if (!e) return;\n        e[5] !== i && (s = e[6] ? vt(+e[5]) : Mt(+e[5]));\n        const n = Vt(+e[2]), o = +e[3] / 100, a = +e[4] / 100;\n        return i = \"hwb\" === e[1] ? function(t, e, i) {\n            return zt(Rt, t, e, i);\n        }(n, o, a) : \"hsv\" === e[1] ? function(t, e, i) {\n            return zt(Et, t, e, i);\n        }(n, o, a) : Ft(n, o, a), {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: s\n        };\n    }\n    const Wt = {\n        x: \"dark\",\n        Z: \"light\",\n        Y: \"re\",\n        X: \"blu\",\n        W: \"gr\",\n        V: \"medium\",\n        U: \"slate\",\n        A: \"ee\",\n        T: \"ol\",\n        S: \"or\",\n        B: \"ra\",\n        C: \"lateg\",\n        D: \"ights\",\n        R: \"in\",\n        Q: \"turquois\",\n        E: \"hi\",\n        P: \"ro\",\n        O: \"al\",\n        N: \"le\",\n        M: \"de\",\n        L: \"yello\",\n        F: \"en\",\n        K: \"ch\",\n        G: \"arks\",\n        H: \"ea\",\n        I: \"ightg\",\n        J: \"wh\"\n    }, Nt = {\n        OiceXe: \"f0f8ff\",\n        antiquewEte: \"faebd7\",\n        aqua: \"ffff\",\n        aquamarRe: \"7fffd4\",\n        azuY: \"f0ffff\",\n        beige: \"f5f5dc\",\n        bisque: \"ffe4c4\",\n        black: \"0\",\n        blanKedOmond: \"ffebcd\",\n        Xe: \"ff\",\n        XeviTet: \"8a2be2\",\n        bPwn: \"a52a2a\",\n        burlywood: \"deb887\",\n        caMtXe: \"5f9ea0\",\n        KartYuse: \"7fff00\",\n        KocTate: \"d2691e\",\n        cSO: \"ff7f50\",\n        cSnflowerXe: \"6495ed\",\n        cSnsilk: \"fff8dc\",\n        crimson: \"dc143c\",\n        cyan: \"ffff\",\n        xXe: \"8b\",\n        xcyan: \"8b8b\",\n        xgTMnPd: \"b8860b\",\n        xWay: \"a9a9a9\",\n        xgYF: \"6400\",\n        xgYy: \"a9a9a9\",\n        xkhaki: \"bdb76b\",\n        xmagFta: \"8b008b\",\n        xTivegYF: \"556b2f\",\n        xSange: \"ff8c00\",\n        xScEd: \"9932cc\",\n        xYd: \"8b0000\",\n        xsOmon: \"e9967a\",\n        xsHgYF: \"8fbc8f\",\n        xUXe: \"483d8b\",\n        xUWay: \"2f4f4f\",\n        xUgYy: \"2f4f4f\",\n        xQe: \"ced1\",\n        xviTet: \"9400d3\",\n        dAppRk: \"ff1493\",\n        dApskyXe: \"bfff\",\n        dimWay: \"696969\",\n        dimgYy: \"696969\",\n        dodgerXe: \"1e90ff\",\n        fiYbrick: \"b22222\",\n        flSOwEte: \"fffaf0\",\n        foYstWAn: \"228b22\",\n        fuKsia: \"ff00ff\",\n        gaRsbSo: \"dcdcdc\",\n        ghostwEte: \"f8f8ff\",\n        gTd: \"ffd700\",\n        gTMnPd: \"daa520\",\n        Way: \"808080\",\n        gYF: \"8000\",\n        gYFLw: \"adff2f\",\n        gYy: \"808080\",\n        honeyMw: \"f0fff0\",\n        hotpRk: \"ff69b4\",\n        RdianYd: \"cd5c5c\",\n        Rdigo: \"4b0082\",\n        ivSy: \"fffff0\",\n        khaki: \"f0e68c\",\n        lavFMr: \"e6e6fa\",\n        lavFMrXsh: \"fff0f5\",\n        lawngYF: \"7cfc00\",\n        NmoncEffon: \"fffacd\",\n        ZXe: \"add8e6\",\n        ZcSO: \"f08080\",\n        Zcyan: \"e0ffff\",\n        ZgTMnPdLw: \"fafad2\",\n        ZWay: \"d3d3d3\",\n        ZgYF: \"90ee90\",\n        ZgYy: \"d3d3d3\",\n        ZpRk: \"ffb6c1\",\n        ZsOmon: \"ffa07a\",\n        ZsHgYF: \"20b2aa\",\n        ZskyXe: \"87cefa\",\n        ZUWay: \"778899\",\n        ZUgYy: \"778899\",\n        ZstAlXe: \"b0c4de\",\n        ZLw: \"ffffe0\",\n        lime: \"ff00\",\n        limegYF: \"32cd32\",\n        lRF: \"faf0e6\",\n        magFta: \"ff00ff\",\n        maPon: \"800000\",\n        VaquamarRe: \"66cdaa\",\n        VXe: \"cd\",\n        VScEd: \"ba55d3\",\n        VpurpN: \"9370db\",\n        VsHgYF: \"3cb371\",\n        VUXe: \"7b68ee\",\n        VsprRggYF: \"fa9a\",\n        VQe: \"48d1cc\",\n        VviTetYd: \"c71585\",\n        midnightXe: \"191970\",\n        mRtcYam: \"f5fffa\",\n        mistyPse: \"ffe4e1\",\n        moccasR: \"ffe4b5\",\n        navajowEte: \"ffdead\",\n        navy: \"80\",\n        Tdlace: \"fdf5e6\",\n        Tive: \"808000\",\n        TivedBb: \"6b8e23\",\n        Sange: \"ffa500\",\n        SangeYd: \"ff4500\",\n        ScEd: \"da70d6\",\n        pOegTMnPd: \"eee8aa\",\n        pOegYF: \"98fb98\",\n        pOeQe: \"afeeee\",\n        pOeviTetYd: \"db7093\",\n        papayawEp: \"ffefd5\",\n        pHKpuff: \"ffdab9\",\n        peru: \"cd853f\",\n        pRk: \"ffc0cb\",\n        plum: \"dda0dd\",\n        powMrXe: \"b0e0e6\",\n        purpN: \"800080\",\n        YbeccapurpN: \"663399\",\n        Yd: \"ff0000\",\n        Psybrown: \"bc8f8f\",\n        PyOXe: \"4169e1\",\n        saddNbPwn: \"8b4513\",\n        sOmon: \"fa8072\",\n        sandybPwn: \"f4a460\",\n        sHgYF: \"2e8b57\",\n        sHshell: \"fff5ee\",\n        siFna: \"a0522d\",\n        silver: \"c0c0c0\",\n        skyXe: \"87ceeb\",\n        UXe: \"6a5acd\",\n        UWay: \"708090\",\n        UgYy: \"708090\",\n        snow: \"fffafa\",\n        sprRggYF: \"ff7f\",\n        stAlXe: \"4682b4\",\n        tan: \"d2b48c\",\n        teO: \"8080\",\n        tEstN: \"d8bfd8\",\n        tomato: \"ff6347\",\n        Qe: \"40e0d0\",\n        viTet: \"ee82ee\",\n        JHt: \"f5deb3\",\n        wEte: \"ffffff\",\n        wEtesmoke: \"f5f5f5\",\n        Lw: \"ffff00\",\n        LwgYF: \"9acd32\"\n    };\n    let Ht;\n    function jt(t) {\n        Ht || (Ht = function() {\n            const t = {}, e = Object.keys(Nt), i = Object.keys(Wt);\n            let s, n, o, a, r;\n            for(s = 0; s < e.length; s++){\n                for(a = r = e[s], n = 0; n < i.length; n++)o = i[n], r = r.replace(o, Wt[o]);\n                o = parseInt(Nt[a], 16), t[r] = [\n                    o >> 16 & 255,\n                    o >> 8 & 255,\n                    255 & o\n                ];\n            }\n            return t;\n        }(), Ht.transparent = [\n            0,\n            0,\n            0,\n            0\n        ]);\n        const e = Ht[t.toLowerCase()];\n        return e && {\n            r: e[0],\n            g: e[1],\n            b: e[2],\n            a: 4 === e.length ? e[3] : 255\n        };\n    }\n    const $t = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    const Yt = (t)=>t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, Ut = (t)=>t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    function Xt(t, e, i) {\n        if (t) {\n            let s = It(t);\n            s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = Ft(s), t.r = s[0], t.g = s[1], t.b = s[2];\n        }\n    }\n    function qt(t, e) {\n        return t ? Object.assign(e || {}, t) : t;\n    }\n    function Kt(t) {\n        var e = {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 255\n        };\n        return Array.isArray(t) ? t.length >= 3 && (e = {\n            r: t[0],\n            g: t[1],\n            b: t[2],\n            a: 255\n        }, t.length > 3 && (e.a = Mt(t[3]))) : (e = qt(t, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        })).a = Mt(e.a), e;\n    }\n    function Gt(t) {\n        return \"r\" === t.charAt(0) ? function(t) {\n            const e = $t.exec(t);\n            let i, s, n, o = 255;\n            if (e) {\n                if (e[7] !== i) {\n                    const t = +e[7];\n                    o = e[8] ? vt(t) : yt(255 * t, 0, 255);\n                }\n                return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? vt(i) : yt(i, 0, 255)), s = 255 & (e[4] ? vt(s) : yt(s, 0, 255)), n = 255 & (e[6] ? vt(n) : yt(n, 0, 255)), {\n                    r: i,\n                    g: s,\n                    b: n,\n                    a: o\n                };\n            }\n        }(t) : Bt(t);\n    }\n    class Zt {\n        constructor(t){\n            if (t instanceof Zt) return t;\n            const e = typeof t;\n            let i;\n            var s, n, o;\n            \"object\" === e ? i = Kt(t) : \"string\" === e && (o = (s = t).length, \"#\" === s[0] && (4 === o || 5 === o ? n = {\n                r: 255 & 17 * St[s[1]],\n                g: 255 & 17 * St[s[2]],\n                b: 255 & 17 * St[s[3]],\n                a: 5 === o ? 17 * St[s[4]] : 255\n            } : 7 !== o && 9 !== o || (n = {\n                r: St[s[1]] << 4 | St[s[2]],\n                g: St[s[3]] << 4 | St[s[4]],\n                b: St[s[5]] << 4 | St[s[6]],\n                a: 9 === o ? St[s[7]] << 4 | St[s[8]] : 255\n            })), i = n || jt(t) || Gt(t)), this._rgb = i, this._valid = !!i;\n        }\n        get valid() {\n            return this._valid;\n        }\n        get rgb() {\n            var t = qt(this._rgb);\n            return t && (t.a = wt(t.a)), t;\n        }\n        set rgb(t) {\n            this._rgb = Kt(t);\n        }\n        rgbString() {\n            var t;\n            return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;\n        }\n        hexString() {\n            return this._valid ? At(this._rgb) : void 0;\n        }\n        hslString() {\n            return this._valid ? function(t) {\n                if (!t) return;\n                const e = It(t), i = e[0], s = kt(e[1]), n = kt(e[2]);\n                return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`;\n            }(this._rgb) : void 0;\n        }\n        mix(t, e) {\n            if (t) {\n                const i = this.rgb, s = t.rgb;\n                let n;\n                const o = e === n ? .5 : e, a = 2 * o - 1, r = i.a - s.a, l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;\n                n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;\n            }\n            return this;\n        }\n        interpolate(t, e) {\n            return t && (this._rgb = function(t, e, i) {\n                const s = Ut(wt(t.r)), n = Ut(wt(t.g)), o = Ut(wt(t.b));\n                return {\n                    r: Mt(Yt(s + i * (Ut(wt(e.r)) - s))),\n                    g: Mt(Yt(n + i * (Ut(wt(e.g)) - n))),\n                    b: Mt(Yt(o + i * (Ut(wt(e.b)) - o))),\n                    a: t.a + i * (e.a - t.a)\n                };\n            }(this._rgb, t._rgb, e)), this;\n        }\n        clone() {\n            return new Zt(this.rgb);\n        }\n        alpha(t) {\n            return this._rgb.a = Mt(t), this;\n        }\n        clearer(t) {\n            return this._rgb.a *= 1 - t, this;\n        }\n        greyscale() {\n            const t = this._rgb, e = _t(.3 * t.r + .59 * t.g + .11 * t.b);\n            return t.r = t.g = t.b = e, this;\n        }\n        opaquer(t) {\n            return this._rgb.a *= 1 + t, this;\n        }\n        negate() {\n            const t = this._rgb;\n            return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n        }\n        lighten(t) {\n            return Xt(this._rgb, 2, t), this;\n        }\n        darken(t) {\n            return Xt(this._rgb, 2, -t), this;\n        }\n        saturate(t) {\n            return Xt(this._rgb, 1, t), this;\n        }\n        desaturate(t) {\n            return Xt(this._rgb, 1, -t), this;\n        }\n        rotate(t) {\n            return function(t, e) {\n                var i = It(t);\n                i[0] = Vt(i[0] + e), i = Ft(i), t.r = i[0], t.g = i[1], t.b = i[2];\n            }(this._rgb, t), this;\n        }\n    }\n    function Jt(t) {\n        if (t && \"object\" == typeof t) {\n            const e = t.toString();\n            return \"[object CanvasPattern]\" === e || \"[object CanvasGradient]\" === e;\n        }\n        return !1;\n    }\n    function Qt(t) {\n        return Jt(t) ? t : new Zt(t);\n    }\n    function te(t) {\n        return Jt(t) ? t : new Zt(t).saturate(.5).darken(.1).hexString();\n    }\n    const ee = [\n        \"x\",\n        \"y\",\n        \"borderWidth\",\n        \"radius\",\n        \"tension\"\n    ], ie = [\n        \"color\",\n        \"borderColor\",\n        \"backgroundColor\"\n    ];\n    const se = new Map;\n    function ne(t, e, i) {\n        return (function(t, e) {\n            e = e || {};\n            const i = t + JSON.stringify(e);\n            let s = se.get(i);\n            return s || (s = new Intl.NumberFormat(t, e), se.set(i, s)), s;\n        })(e, i).format(t);\n    }\n    const oe = {\n        values: (t)=>n(t) ? t : \"\" + t,\n        numeric (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = this.chart.options.locale;\n            let n, o = t;\n            if (i.length > 1) {\n                const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));\n                (e < 1e-4 || e > 1e15) && (n = \"scientific\"), o = function(t, e) {\n                    let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;\n                    Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));\n                    return i;\n                }(t, i);\n            }\n            const a = z(Math.abs(o)), r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {\n                notation: n,\n                minimumFractionDigits: r,\n                maximumFractionDigits: r\n            };\n            return Object.assign(l, this.options.ticks.format), ne(t, s, l);\n        },\n        logarithmic (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = i[e].significand || t / Math.pow(10, Math.floor(z(t)));\n            return [\n                1,\n                2,\n                3,\n                5,\n                10,\n                15\n            ].includes(s) || e > .8 * i.length ? oe.numeric.call(this, t, e, i) : \"\";\n        }\n    };\n    var ae = {\n        formatters: oe\n    };\n    const re = Object.create(null), le = Object.create(null);\n    function he(t, e) {\n        if (!e) return t;\n        const i = e.split(\".\");\n        for(let e = 0, s = i.length; e < s; ++e){\n            const s = i[e];\n            t = t[s] || (t[s] = Object.create(null));\n        }\n        return t;\n    }\n    function ce(t, e, i) {\n        return \"string\" == typeof e ? b(he(t, e), i) : b(he(t, \"\"), e);\n    }\n    class de {\n        constructor(t, e){\n            this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = (t)=>t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\n                \"mousemove\",\n                \"mouseout\",\n                \"click\",\n                \"touchstart\",\n                \"touchmove\"\n            ], this.font = {\n                family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n                size: 12,\n                style: \"normal\",\n                lineHeight: 1.2,\n                weight: null\n            }, this.hover = {}, this.hoverBackgroundColor = (t, e)=>te(e.backgroundColor), this.hoverBorderColor = (t, e)=>te(e.borderColor), this.hoverColor = (t, e)=>te(e.color), this.indexAxis = \"x\", this.interaction = {\n                mode: \"nearest\",\n                intersect: !0,\n                includeInvisible: !1\n            }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e);\n        }\n        set(t, e) {\n            return ce(this, t, e);\n        }\n        get(t) {\n            return he(this, t);\n        }\n        describe(t, e) {\n            return ce(le, t, e);\n        }\n        override(t, e) {\n            return ce(re, t, e);\n        }\n        route(t, e, i, s) {\n            const n = he(this, t), a = he(this, i), r = \"_\" + e;\n            Object.defineProperties(n, {\n                [r]: {\n                    value: n[e],\n                    writable: !0\n                },\n                [e]: {\n                    enumerable: !0,\n                    get () {\n                        const t = this[r], e = a[s];\n                        return o(t) ? Object.assign({}, e, t) : l(t, e);\n                    },\n                    set (t) {\n                        this[r] = t;\n                    }\n                }\n            });\n        }\n        apply(t) {\n            t.forEach((t)=>t(this));\n        }\n    }\n    var ue = new de({\n        _scriptable: (t)=>!t.startsWith(\"on\"),\n        _indexable: (t)=>\"events\" !== t,\n        hover: {\n            _fallback: \"interaction\"\n        },\n        interaction: {\n            _scriptable: !1,\n            _indexable: !1\n        }\n    }, [\n        function(t) {\n            t.set(\"animation\", {\n                delay: void 0,\n                duration: 1e3,\n                easing: \"easeOutQuart\",\n                fn: void 0,\n                from: void 0,\n                loop: void 0,\n                to: void 0,\n                type: void 0\n            }), t.describe(\"animation\", {\n                _fallback: !1,\n                _indexable: !1,\n                _scriptable: (t)=>\"onProgress\" !== t && \"onComplete\" !== t && \"fn\" !== t\n            }), t.set(\"animations\", {\n                colors: {\n                    type: \"color\",\n                    properties: ie\n                },\n                numbers: {\n                    type: \"number\",\n                    properties: ee\n                }\n            }), t.describe(\"animations\", {\n                _fallback: \"animation\"\n            }), t.set(\"transitions\", {\n                active: {\n                    animation: {\n                        duration: 400\n                    }\n                },\n                resize: {\n                    animation: {\n                        duration: 0\n                    }\n                },\n                show: {\n                    animations: {\n                        colors: {\n                            from: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            duration: 0\n                        }\n                    }\n                },\n                hide: {\n                    animations: {\n                        colors: {\n                            to: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            easing: \"linear\",\n                            fn: (t)=>0 | t\n                        }\n                    }\n                }\n            });\n        },\n        function(t) {\n            t.set(\"layout\", {\n                autoPadding: !0,\n                padding: {\n                    top: 0,\n                    right: 0,\n                    bottom: 0,\n                    left: 0\n                }\n            });\n        },\n        function(t) {\n            t.set(\"scale\", {\n                display: !0,\n                offset: !1,\n                reverse: !1,\n                beginAtZero: !1,\n                bounds: \"ticks\",\n                grace: 0,\n                grid: {\n                    display: !0,\n                    lineWidth: 1,\n                    drawOnChartArea: !0,\n                    drawTicks: !0,\n                    tickLength: 8,\n                    tickWidth: (t, e)=>e.lineWidth,\n                    tickColor: (t, e)=>e.color,\n                    offset: !1\n                },\n                border: {\n                    display: !0,\n                    dash: [],\n                    dashOffset: 0,\n                    width: 1\n                },\n                title: {\n                    display: !1,\n                    text: \"\",\n                    padding: {\n                        top: 4,\n                        bottom: 4\n                    }\n                },\n                ticks: {\n                    minRotation: 0,\n                    maxRotation: 50,\n                    mirror: !1,\n                    textStrokeWidth: 0,\n                    textStrokeColor: \"\",\n                    padding: 3,\n                    display: !0,\n                    autoSkip: !0,\n                    autoSkipPadding: 3,\n                    labelOffset: 0,\n                    callback: ae.formatters.values,\n                    minor: {},\n                    major: {},\n                    align: \"center\",\n                    crossAlign: \"near\",\n                    showLabelBackdrop: !1,\n                    backdropColor: \"rgba(255, 255, 255, 0.75)\",\n                    backdropPadding: 2\n                }\n            }), t.route(\"scale.ticks\", \"color\", \"\", \"color\"), t.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), t.route(\"scale.border\", \"color\", \"\", \"borderColor\"), t.route(\"scale.title\", \"color\", \"\", \"color\"), t.describe(\"scale\", {\n                _fallback: !1,\n                _scriptable: (t)=>!t.startsWith(\"before\") && !t.startsWith(\"after\") && \"callback\" !== t && \"parser\" !== t,\n                _indexable: (t)=>\"borderDash\" !== t && \"tickBorderDash\" !== t && \"dash\" !== t\n            }), t.describe(\"scales\", {\n                _fallback: \"scale\"\n            }), t.describe(\"scale.ticks\", {\n                _scriptable: (t)=>\"backdropPadding\" !== t && \"callback\" !== t,\n                _indexable: (t)=>\"backdropPadding\" !== t\n            });\n        }\n    ]);\n    function fe() {\n        return \"undefined\" != typeof window && \"undefined\" != typeof document;\n    }\n    function ge(t) {\n        let e = t.parentNode;\n        return e && \"[object ShadowRoot]\" === e.toString() && (e = e.host), e;\n    }\n    function pe(t, e, i) {\n        let s;\n        return \"string\" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf(\"%\") && (s = s / 100 * e.parentNode[i])) : s = t, s;\n    }\n    const me = (t)=>t.ownerDocument.defaultView.getComputedStyle(t, null);\n    function be(t, e) {\n        return me(t).getPropertyValue(e);\n    }\n    const xe = [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ];\n    function _e(t, e, i) {\n        const s = {};\n        i = i ? \"-\" + i : \"\";\n        for(let n = 0; n < 4; n++){\n            const o = xe[n];\n            s[o] = parseFloat(t[e + \"-\" + o + i]) || 0;\n        }\n        return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n    }\n    const ye = (t, e, i)=>(t > 0 || e > 0) && (!i || !i.shadowRoot);\n    function ve(t, e) {\n        if (\"native\" in t) return t;\n        const { canvas: i, currentDevicePixelRatio: s } = e, n = me(i), o = \"border-box\" === n.boxSizing, a = _e(n, \"padding\"), r = _e(n, \"border\", \"width\"), { x: l, y: h, box: c } = function(t, e) {\n            const i = t.touches, s = i && i.length ? i[0] : t, { offsetX: n, offsetY: o } = s;\n            let a, r, l = !1;\n            if (ye(n, o, t.target)) a = n, r = o;\n            else {\n                const t = e.getBoundingClientRect();\n                a = s.clientX - t.left, r = s.clientY - t.top, l = !0;\n            }\n            return {\n                x: a,\n                y: r,\n                box: l\n            };\n        }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);\n        let { width: f, height: g } = e;\n        return o && (f -= a.width + r.width, g -= a.height + r.height), {\n            x: Math.round((l - d) / f * i.width / s),\n            y: Math.round((h - u) / g * i.height / s)\n        };\n    }\n    const Me = (t)=>Math.round(10 * t) / 10;\n    function we(t, e, i, s) {\n        const n = me(t), o = _e(n, \"margin\"), a = pe(n.maxWidth, t, \"clientWidth\") || T, r = pe(n.maxHeight, t, \"clientHeight\") || T, l = function(t, e, i) {\n            let s, n;\n            if (void 0 === e || void 0 === i) {\n                const o = ge(t);\n                if (o) {\n                    const t = o.getBoundingClientRect(), a = me(o), r = _e(a, \"border\", \"width\"), l = _e(a, \"padding\");\n                    e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = pe(a.maxWidth, o, \"clientWidth\"), n = pe(a.maxHeight, o, \"clientHeight\");\n                } else e = t.clientWidth, i = t.clientHeight;\n            }\n            return {\n                width: e,\n                height: i,\n                maxWidth: s || T,\n                maxHeight: n || T\n            };\n        }(t, e, i);\n        let { width: h, height: c } = l;\n        if (\"content-box\" === n.boxSizing) {\n            const t = _e(n, \"border\", \"width\"), e = _e(n, \"padding\");\n            h -= e.width + t.width, c -= e.height + t.height;\n        }\n        h = Math.max(0, h - o.width), c = Math.max(0, s ? h / s : c - o.height), h = Me(Math.min(h, a, l.maxWidth)), c = Me(Math.min(c, r, l.maxHeight)), h && !c && (c = Me(h / 2));\n        return (void 0 !== e || void 0 !== i) && s && l.height && c > l.height && (c = l.height, h = Me(Math.floor(c * s))), {\n            width: h,\n            height: c\n        };\n    }\n    function ke(t, e, i) {\n        const s = e || 1, n = Math.floor(t.height * s), o = Math.floor(t.width * s);\n        t.height = Math.floor(t.height), t.width = Math.floor(t.width);\n        const a = t.canvas;\n        return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0);\n    }\n    const Se = function() {\n        let t = !1;\n        try {\n            const e = {\n                get passive () {\n                    return t = !0, !1;\n                }\n            };\n            window.addEventListener(\"test\", null, e), window.removeEventListener(\"test\", null, e);\n        } catch (t) {}\n        return t;\n    }();\n    function Pe(t, e) {\n        const i = be(t, e), s = i && i.match(/^(\\d+)(\\.\\d+)?px$/);\n        return s ? +s[1] : void 0;\n    }\n    function De(t) {\n        return !t || s(t.size) || s(t.family) ? null : (t.style ? t.style + \" \" : \"\") + (t.weight ? t.weight + \" \" : \"\") + t.size + \"px \" + t.family;\n    }\n    function Ce(t, e, i, s, n) {\n        let o = e[n];\n        return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s;\n    }\n    function Oe(t, e, i, s) {\n        let o = (s = s || {}).data = s.data || {}, a = s.garbageCollect = s.garbageCollect || [];\n        s.font !== e && (o = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;\n        let r = 0;\n        const l = i.length;\n        let h, c, d, u, f;\n        for(h = 0; h < l; h++)if (u = i[h], null == u || n(u)) {\n            if (n(u)) for(c = 0, d = u.length; c < d; c++)f = u[c], null == f || n(f) || (r = Ce(t, o, a, r, f));\n        } else r = Ce(t, o, a, r, u);\n        t.restore();\n        const g = a.length / 2;\n        if (g > i.length) {\n            for(h = 0; h < g; h++)delete o[a[h]];\n            a.splice(0, g);\n        }\n        return r;\n    }\n    function Ae(t, e, i) {\n        const s = t.currentDevicePixelRatio, n = 0 !== i ? Math.max(i / 2, .5) : 0;\n        return Math.round((e - n) * s) / s + n;\n    }\n    function Te(t, e) {\n        (e = e || t.getContext(\"2d\")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore();\n    }\n    function Le(t, e, i, s) {\n        Ee(t, e, i, s, null);\n    }\n    function Ee(t, e, i, s, n) {\n        let o, a, r, l, h, c, d, u;\n        const f = e.pointStyle, g = e.rotation, p = e.radius;\n        let m = (g || 0) * L;\n        if (f && \"object\" == typeof f && (o = f.toString(), \"[object HTMLImageElement]\" === o || \"[object HTMLCanvasElement]\" === o)) return t.save(), t.translate(i, s), t.rotate(m), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void t.restore();\n        if (!(isNaN(p) || p <= 0)) {\n            switch(t.beginPath(), f){\n                default:\n                    n ? t.ellipse(i, s, n / 2, p, 0, 0, O) : t.arc(i, s, p, 0, O), t.closePath();\n                    break;\n                case \"triangle\":\n                    c = n ? n / 2 : p, t.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), t.closePath();\n                    break;\n                case \"rectRounded\":\n                    h = .516 * p, l = p - h, a = Math.cos(m + R) * l, d = Math.cos(m + R) * (n ? n / 2 - h : l), r = Math.sin(m + R) * l, u = Math.sin(m + R) * (n ? n / 2 - h : l), t.arc(i - d, s - r, h, m - C, m - E), t.arc(i + u, s - a, h, m - E, m), t.arc(i + d, s + r, h, m, m + E), t.arc(i - u, s + a, h, m + E, m + C), t.closePath();\n                    break;\n                case \"rect\":\n                    if (!g) {\n                        l = Math.SQRT1_2 * p, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);\n                        break;\n                    }\n                    m += R;\n                case \"rectRot\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + u, s - a), t.lineTo(i + d, s + r), t.lineTo(i - u, s + a), t.closePath();\n                    break;\n                case \"crossRot\":\n                    m += R;\n                case \"cross\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"star\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a), m += R, d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"line\":\n                    a = n ? n / 2 : Math.cos(m) * p, r = Math.sin(m) * p, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);\n                    break;\n                case \"dash\":\n                    t.moveTo(i, s), t.lineTo(i + Math.cos(m) * (n ? n / 2 : p), s + Math.sin(m) * p);\n                    break;\n                case !1:\n                    t.closePath();\n            }\n            t.fill(), e.borderWidth > 0 && t.stroke();\n        }\n    }\n    function Re(t, e, i) {\n        return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;\n    }\n    function Ie(t, e) {\n        t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();\n    }\n    function ze(t) {\n        t.restore();\n    }\n    function Fe(t, e, i, s, n) {\n        if (!e) return t.lineTo(i.x, i.y);\n        if (\"middle\" === n) {\n            const s = (e.x + i.x) / 2;\n            t.lineTo(s, e.y), t.lineTo(s, i.y);\n        } else \"after\" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);\n        t.lineTo(i.x, i.y);\n    }\n    function Ve(t, e, i, s) {\n        if (!e) return t.lineTo(i.x, i.y);\n        t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y);\n    }\n    function Be(t, e, i, s, n) {\n        if (n.strikethrough || n.underline) {\n            const o = t.measureText(s), a = e - o.actualBoundingBoxLeft, r = e + o.actualBoundingBoxRight, l = i - o.actualBoundingBoxAscent, h = i + o.actualBoundingBoxDescent, c = n.strikethrough ? (l + h) / 2 : h;\n            t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke();\n        }\n    }\n    function We(t, e) {\n        const i = t.fillStyle;\n        t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i;\n    }\n    function Ne(t, e, i, o, a, r = {}) {\n        const l = n(e) ? e : [\n            e\n        ], h = r.strokeWidth > 0 && \"\" !== r.strokeColor;\n        let c, d;\n        for(t.save(), t.font = a.string, function(t, e) {\n            e.translation && t.translate(e.translation[0], e.translation[1]), s(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);\n        }(t, r), c = 0; c < l.length; ++c)d = l[c], r.backdrop && We(t, r.backdrop), h && (r.strokeColor && (t.strokeStyle = r.strokeColor), s(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, i, o, r.maxWidth)), t.fillText(d, i, o, r.maxWidth), Be(t, i, o, d, r), o += Number(a.lineHeight);\n        t.restore();\n    }\n    function He(t, e) {\n        const { x: i, y: s, w: n, h: o, radius: a } = e;\n        t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, -E, C, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, C, E, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, E, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -E, !0), t.lineTo(i + a.topLeft, s);\n    }\n    function je(t, e = [\n        \"\"\n    ], i, s, n = ()=>t[0]) {\n        const o = i || t;\n        void 0 === s && (s = ti(\"_fallback\", t));\n        const a = {\n            [Symbol.toStringTag]: \"Object\",\n            _cacheable: !0,\n            _scopes: t,\n            _rootScopes: o,\n            _fallback: s,\n            _getTarget: n,\n            override: (i)=>je([\n                    i,\n                    ...t\n                ], e, o, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete e._keys, delete t[0][i], !0),\n            get: (i, s)=>qe(i, s, ()=>(function(t, e, i, s) {\n                        let n;\n                        for (const o of e)if (n = ti(Ue(o, t), i), void 0 !== n) return Xe(t, n) ? Je(i, s, t, n) : n;\n                    })(s, e, t, i)),\n            getOwnPropertyDescriptor: (t, e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0], e),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t[0]),\n            has: (t, e)=>ei(t).includes(e),\n            ownKeys: (t)=>ei(t),\n            set (t, e, i) {\n                const s = t._storage || (t._storage = n());\n                return t[e] = s[e] = i, delete t._keys, !0;\n            }\n        });\n    }\n    function $e(t, e, i, s) {\n        const a = {\n            _cacheable: !1,\n            _proxy: t,\n            _context: e,\n            _subProxy: i,\n            _stack: new Set,\n            _descriptors: Ye(t, s),\n            setContext: (e)=>$e(t, e, i, s),\n            override: (n)=>$e(t.override(n), e, i, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete t[i], !0),\n            get: (t, e, i)=>qe(t, e, ()=>(function(t, e, i) {\n                        const { _proxy: s, _context: a, _subProxy: r, _descriptors: l } = t;\n                        let h = s[e];\n                        S(h) && l.isScriptable(e) && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: o, _subProxy: a, _stack: r } = i;\n                            if (r.has(t)) throw new Error(\"Recursion detected: \" + Array.from(r).join(\"->\") + \"->\" + t);\n                            r.add(t);\n                            let l = e(o, a || s);\n                            r.delete(t), Xe(t, l) && (l = Je(n._scopes, n, t, l));\n                            return l;\n                        }(e, h, t, i));\n                        n(h) && h.length && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: a, _subProxy: r, _descriptors: l } = i;\n                            if (void 0 !== a.index && s(t)) return e[a.index % e.length];\n                            if (o(e[0])) {\n                                const i = e, s = n._scopes.filter((t)=>t !== i);\n                                e = [];\n                                for (const o of i){\n                                    const i = Je(s, n, t, o);\n                                    e.push($e(i, a, r && r[t], l));\n                                }\n                            }\n                            return e;\n                        }(e, h, t, l.isIndexable));\n                        Xe(e, h) && (h = $e(h, a, r && r[e], l));\n                        return h;\n                    })(t, e, i)),\n            getOwnPropertyDescriptor: (e, i)=>e._descriptors.allKeys ? Reflect.has(t, i) ? {\n                    enumerable: !0,\n                    configurable: !0\n                } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t),\n            has: (e, i)=>Reflect.has(t, i),\n            ownKeys: ()=>Reflect.ownKeys(t),\n            set: (e, i, s)=>(t[i] = s, delete e[i], !0)\n        });\n    }\n    function Ye(t, e = {\n        scriptable: !0,\n        indexable: !0\n    }) {\n        const { _scriptable: i = e.scriptable, _indexable: s = e.indexable, _allKeys: n = e.allKeys } = t;\n        return {\n            allKeys: n,\n            scriptable: i,\n            indexable: s,\n            isScriptable: S(i) ? i : ()=>i,\n            isIndexable: S(s) ? s : ()=>s\n        };\n    }\n    const Ue = (t, e)=>t ? t + w(e) : e, Xe = (t, e)=>o(e) && \"adapters\" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);\n    function qe(t, e, i) {\n        if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];\n        const s = i();\n        return t[e] = s, s;\n    }\n    function Ke(t, e, i) {\n        return S(t) ? t(e, i) : t;\n    }\n    const Ge = (t, e)=>!0 === t ? e : \"string\" == typeof t ? M(e, t) : void 0;\n    function Ze(t, e, i, s, n) {\n        for (const o of e){\n            const e = Ge(i, o);\n            if (e) {\n                t.add(e);\n                const o = Ke(e._fallback, i, n);\n                if (void 0 !== o && o !== i && o !== s) return o;\n            } else if (!1 === e && void 0 !== s && i !== s) return null;\n        }\n        return !1;\n    }\n    function Je(t, e, i, s) {\n        const a = e._rootScopes, r = Ke(e._fallback, i, s), l = [\n            ...t,\n            ...a\n        ], h = new Set;\n        h.add(s);\n        let c = Qe(h, l, i, r || i, s);\n        return null !== c && (void 0 === r || r === i || (c = Qe(h, l, r, c, s), null !== c)) && je(Array.from(h), [\n            \"\"\n        ], a, r, ()=>(function(t, e, i) {\n                const s = t._getTarget();\n                e in s || (s[e] = {});\n                const a = s[e];\n                if (n(a) && o(i)) return i;\n                return a || {};\n            })(e, i, s));\n    }\n    function Qe(t, e, i, s, n) {\n        for(; i;)i = Ze(t, e, i, s, n);\n        return i;\n    }\n    function ti(t, e) {\n        for (const i of e){\n            if (!i) continue;\n            const e = i[t];\n            if (void 0 !== e) return e;\n        }\n    }\n    function ei(t) {\n        let e = t._keys;\n        return e || (e = t._keys = function(t) {\n            const e = new Set;\n            for (const i of t)for (const t of Object.keys(i).filter((t)=>!t.startsWith(\"_\")))e.add(t);\n            return Array.from(e);\n        }(t._scopes)), e;\n    }\n    function ii(t, e, i, s) {\n        const { iScale: n } = t, { key: o = \"r\" } = this._parsing, a = new Array(s);\n        let r, l, h, c;\n        for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n            r: n.parse(M(c, o), h)\n        };\n        return a;\n    }\n    const si = Number.EPSILON || 1e-14, ni = (t, e)=>e < t.length && !t[e].skip && t[e], oi = (t)=>\"x\" === t ? \"y\" : \"x\";\n    function ai(t, e, i, s) {\n        const n = t.skip ? e : t, o = e, a = i.skip ? e : i, r = q(o, n), l = q(a, o);\n        let h = r / (r + l), c = l / (r + l);\n        h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;\n        const d = s * h, u = s * c;\n        return {\n            previous: {\n                x: o.x - d * (a.x - n.x),\n                y: o.y - d * (a.y - n.y)\n            },\n            next: {\n                x: o.x + u * (a.x - n.x),\n                y: o.y + u * (a.y - n.y)\n            }\n        };\n    }\n    function ri(t, e = \"x\") {\n        const i = oi(e), s = t.length, n = Array(s).fill(0), o = Array(s);\n        let a, r, l, h = ni(t, 0);\n        for(a = 0; a < s; ++a)if (r = l, l = h, h = ni(t, a + 1), l) {\n            if (h) {\n                const t = h[e] - l[e];\n                n[a] = 0 !== t ? (h[i] - l[i]) / t : 0;\n            }\n            o[a] = r ? h ? F(n[a - 1]) !== F(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a];\n        }\n        !function(t, e, i) {\n            const s = t.length;\n            let n, o, a, r, l, h = ni(t, 0);\n            for(let c = 0; c < s - 1; ++c)l = h, h = ni(t, c + 1), l && h && (V(e[c], 0, si) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])));\n        }(t, n, o), function(t, e, i = \"x\") {\n            const s = oi(i), n = t.length;\n            let o, a, r, l = ni(t, 0);\n            for(let h = 0; h < n; ++h){\n                if (a = r, r = l, l = ni(t, h + 1), !r) continue;\n                const n = r[i], c = r[s];\n                a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h]);\n            }\n        }(t, o, e);\n    }\n    function li(t, e, i) {\n        return Math.max(Math.min(t, i), e);\n    }\n    function hi(t, e, i, s, n) {\n        let o, a, r, l;\n        if (e.spanGaps && (t = t.filter((t)=>!t.skip)), \"monotone\" === e.cubicInterpolationMode) ri(t, n);\n        else {\n            let i = s ? t[t.length - 1] : t[0];\n            for(o = 0, a = t.length; o < a; ++o)r = t[o], l = ai(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r;\n        }\n        e.capBezierPoints && function(t, e) {\n            let i, s, n, o, a, r = Re(t[0], e);\n            for(i = 0, s = t.length; i < s; ++i)a = o, o = r, r = i < s - 1 && Re(t[i + 1], e), o && (n = t[i], a && (n.cp1x = li(n.cp1x, e.left, e.right), n.cp1y = li(n.cp1y, e.top, e.bottom)), r && (n.cp2x = li(n.cp2x, e.left, e.right), n.cp2y = li(n.cp2y, e.top, e.bottom)));\n        }(t, i);\n    }\n    const ci = (t)=>0 === t || 1 === t, di = (t, e, i)=>-Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i), ui = (t, e, i)=>Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1, fi = {\n        linear: (t)=>t,\n        easeInQuad: (t)=>t * t,\n        easeOutQuad: (t)=>-t * (t - 2),\n        easeInOutQuad: (t)=>(t /= .5) < 1 ? .5 * t * t : -0.5 * (--t * (t - 2) - 1),\n        easeInCubic: (t)=>t * t * t,\n        easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n        easeInOutCubic: (t)=>(t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),\n        easeInQuart: (t)=>t * t * t * t,\n        easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n        easeInOutQuart: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n        easeInQuint: (t)=>t * t * t * t * t,\n        easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n        easeInOutQuint: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),\n        easeInSine: (t)=>1 - Math.cos(t * E),\n        easeOutSine: (t)=>Math.sin(t * E),\n        easeInOutSine: (t)=>-0.5 * (Math.cos(C * t) - 1),\n        easeInExpo: (t)=>0 === t ? 0 : Math.pow(2, 10 * (t - 1)),\n        easeOutExpo: (t)=>1 === t ? 1 : 1 - Math.pow(2, -10 * t),\n        easeInOutExpo: (t)=>ci(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),\n        easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n        easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n        easeInOutCirc: (t)=>(t /= .5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n        easeInElastic: (t)=>ci(t) ? t : di(t, .075, .3),\n        easeOutElastic: (t)=>ci(t) ? t : ui(t, .075, .3),\n        easeInOutElastic (t) {\n            const e = .1125;\n            return ci(t) ? t : t < .5 ? .5 * di(2 * t, e, .45) : .5 + .5 * ui(2 * t - 1, e, .45);\n        },\n        easeInBack (t) {\n            const e = 1.70158;\n            return t * t * ((e + 1) * t - e);\n        },\n        easeOutBack (t) {\n            const e = 1.70158;\n            return (t -= 1) * t * ((e + 1) * t + e) + 1;\n        },\n        easeInOutBack (t) {\n            let e = 1.70158;\n            return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);\n        },\n        easeInBounce: (t)=>1 - fi.easeOutBounce(1 - t),\n        easeOutBounce (t) {\n            const e = 7.5625, i = 2.75;\n            return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375;\n        },\n        easeInOutBounce: (t)=>t < .5 ? .5 * fi.easeInBounce(2 * t) : .5 * fi.easeOutBounce(2 * t - 1) + .5\n    };\n    function gi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: t.y + i * (e.y - t.y)\n        };\n    }\n    function pi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: \"middle\" === s ? i < .5 ? t.y : e.y : \"after\" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y\n        };\n    }\n    function mi(t, e, i, s) {\n        const n = {\n            x: t.cp2x,\n            y: t.cp2y\n        }, o = {\n            x: e.cp1x,\n            y: e.cp1y\n        }, a = gi(t, n, i), r = gi(n, o, i), l = gi(o, e, i), h = gi(a, r, i), c = gi(r, l, i);\n        return gi(h, c, i);\n    }\n    const bi = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/, xi = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n    function _i(t, e) {\n        const i = (\"\" + t).match(bi);\n        if (!i || \"normal\" === i[1]) return 1.2 * e;\n        switch(t = +i[2], i[3]){\n            case \"px\":\n                return t;\n            case \"%\":\n                t /= 100;\n        }\n        return e * t;\n    }\n    const yi = (t)=>+t || 0;\n    function vi(t, e) {\n        const i = {}, s = o(e), n = s ? Object.keys(e) : e, a = o(t) ? s ? (i)=>l(t[i], t[e[i]]) : (e)=>t[e] : ()=>t;\n        for (const t of n)i[t] = yi(a(t));\n        return i;\n    }\n    function Mi(t) {\n        return vi(t, {\n            top: \"y\",\n            right: \"x\",\n            bottom: \"y\",\n            left: \"x\"\n        });\n    }\n    function wi(t) {\n        return vi(t, [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]);\n    }\n    function ki(t) {\n        const e = Mi(t);\n        return e.width = e.left + e.right, e.height = e.top + e.bottom, e;\n    }\n    function Si(t, e) {\n        t = t || {}, e = e || ue.font;\n        let i = l(t.size, e.size);\n        \"string\" == typeof i && (i = parseInt(i, 10));\n        let s = l(t.style, e.style);\n        s && !(\"\" + s).match(xi) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = void 0);\n        const n = {\n            family: l(t.family, e.family),\n            lineHeight: _i(l(t.lineHeight, e.lineHeight), i),\n            size: i,\n            style: s,\n            weight: l(t.weight, e.weight),\n            string: \"\"\n        };\n        return n.string = De(n), n;\n    }\n    function Pi(t, e, i, s) {\n        let o, a, r, l = !0;\n        for(o = 0, a = t.length; o < a; ++o)if (r = t[o], void 0 !== r && (void 0 !== e && \"function\" == typeof r && (r = r(e), l = !1), void 0 !== i && n(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return s && !l && (s.cacheable = !1), r;\n    }\n    function Di(t, e, i) {\n        const { min: s, max: n } = t, o = c(e, (n - s) / 2), a = (t, e)=>i && 0 === t ? 0 : t + e;\n        return {\n            min: a(s, -Math.abs(o)),\n            max: a(n, o)\n        };\n    }\n    function Ci(t, e) {\n        return Object.assign(Object.create(t), e);\n    }\n    function Oi(t, e, i) {\n        return t ? function(t, e) {\n            return {\n                x: (i)=>t + t + e - i,\n                setWidth (t) {\n                    e = t;\n                },\n                textAlign: (t)=>\"center\" === t ? t : \"right\" === t ? \"left\" : \"right\",\n                xPlus: (t, e)=>t - e,\n                leftForLtr: (t, e)=>t - e\n            };\n        }(e, i) : {\n            x: (t)=>t,\n            setWidth (t) {},\n            textAlign: (t)=>t,\n            xPlus: (t, e)=>t + e,\n            leftForLtr: (t, e)=>t\n        };\n    }\n    function Ai(t, e) {\n        let i, s;\n        \"ltr\" !== e && \"rtl\" !== e || (i = t.canvas.style, s = [\n            i.getPropertyValue(\"direction\"),\n            i.getPropertyPriority(\"direction\")\n        ], i.setProperty(\"direction\", e, \"important\"), t.prevTextDirection = s);\n    }\n    function Ti(t, e) {\n        void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty(\"direction\", e[0], e[1]));\n    }\n    function Li(t) {\n        return \"angle\" === t ? {\n            between: Z,\n            compare: K,\n            normalize: G\n        } : {\n            between: tt,\n            compare: (t, e)=>t - e,\n            normalize: (t)=>t\n        };\n    }\n    function Ei({ start: t, end: e, count: i, loop: s, style: n }) {\n        return {\n            start: t % i,\n            end: e % i,\n            loop: s && (e - t + 1) % i == 0,\n            style: n\n        };\n    }\n    function Ri(t, e, i) {\n        if (!i) return [\n            t\n        ];\n        const { property: s, start: n, end: o } = i, a = e.length, { compare: r, between: l, normalize: h } = Li(s), { start: c, end: d, loop: u, style: f } = function(t, e, i) {\n            const { property: s, start: n, end: o } = i, { between: a, normalize: r } = Li(s), l = e.length;\n            let h, c, { start: d, end: u, loop: f } = t;\n            if (f) {\n                for(d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h)d--, u--;\n                d %= l, u %= l;\n            }\n            return u < d && (u += l), {\n                start: d,\n                end: u,\n                loop: f,\n                style: t.style\n            };\n        }(t, e, i), g = [];\n        let p, m, b, x = !1, _ = null;\n        const y = ()=>x || l(n, b, p) && 0 !== r(n, b), v = ()=>!x || 0 === r(o, p) || l(o, b, p);\n        for(let t = c, i = c; t <= d; ++t)m = e[t % a], m.skip || (p = h(m[s]), p !== b && (x = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(Ei({\n            start: _,\n            end: t,\n            loop: u,\n            count: a,\n            style: f\n        })), _ = null), i = t, b = p));\n        return null !== _ && g.push(Ei({\n            start: _,\n            end: d,\n            loop: u,\n            count: a,\n            style: f\n        })), g;\n    }\n    function Ii(t, e) {\n        const i = [], s = t.segments;\n        for(let n = 0; n < s.length; n++){\n            const o = Ri(s[n], t.points, e);\n            o.length && i.push(...o);\n        }\n        return i;\n    }\n    function zi(t, e) {\n        const i = t.points, s = t.options.spanGaps, n = i.length;\n        if (!n) return [];\n        const o = !!t._loop, { start: a, end: r } = function(t, e, i, s) {\n            let n = 0, o = e - 1;\n            if (i && !s) for(; n < e && !t[n].skip;)n++;\n            for(; n < e && t[n].skip;)n++;\n            for(n %= e, i && (o += n); o > n && t[o % e].skip;)o--;\n            return o %= e, {\n                start: n,\n                end: o\n            };\n        }(i, n, o, s);\n        if (!0 === s) return Fi(t, [\n            {\n                start: a,\n                end: r,\n                loop: o\n            }\n        ], i, e);\n        return Fi(t, function(t, e, i, s) {\n            const n = t.length, o = [];\n            let a, r = e, l = t[e];\n            for(a = e + 1; a <= i; ++a){\n                const i = t[a % n];\n                i.skip || i.stop ? l.skip || (s = !1, o.push({\n                    start: e % n,\n                    end: (a - 1) % n,\n                    loop: s\n                }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i;\n            }\n            return null !== r && o.push({\n                start: e % n,\n                end: r % n,\n                loop: s\n            }), o;\n        }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e);\n    }\n    function Fi(t, e, i, s) {\n        return s && s.setContext && i ? function(t, e, i, s) {\n            const n = t._chart.getContext(), o = Vi(t.options), { _datasetIndex: a, options: { spanGaps: r } } = t, l = i.length, h = [];\n            let c = o, d = e[0].start, u = d;\n            function f(t, e, s, n) {\n                const o = r ? -1 : 1;\n                if (t !== e) {\n                    for(t += l; i[t % l].skip;)t -= o;\n                    for(; i[e % l].skip;)e += o;\n                    t % l != e % l && (h.push({\n                        start: t % l,\n                        end: e % l,\n                        loop: s,\n                        style: n\n                    }), c = n, d = e % l);\n                }\n            }\n            for (const t of e){\n                d = r ? d : t.start;\n                let e, o = i[d % l];\n                for(u = d + 1; u <= t.end; u++){\n                    const r = i[u % l];\n                    e = Vi(s.setContext(Ci(n, {\n                        type: \"segment\",\n                        p0: o,\n                        p1: r,\n                        p0DataIndex: (u - 1) % l,\n                        p1DataIndex: u % l,\n                        datasetIndex: a\n                    }))), Bi(e, c) && f(d, u - 1, t.loop, c), o = r, c = e;\n                }\n                d < u - 1 && f(d, u - 1, t.loop, c);\n            }\n            return h;\n        }(t, e, i, s) : e;\n    }\n    function Vi(t) {\n        return {\n            backgroundColor: t.backgroundColor,\n            borderCapStyle: t.borderCapStyle,\n            borderDash: t.borderDash,\n            borderDashOffset: t.borderDashOffset,\n            borderJoinStyle: t.borderJoinStyle,\n            borderWidth: t.borderWidth,\n            borderColor: t.borderColor\n        };\n    }\n    function Bi(t, e) {\n        if (!e) return !1;\n        const i = [], s = function(t, e) {\n            return Jt(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e;\n        };\n        return JSON.stringify(t, s) !== JSON.stringify(e, s);\n    }\n    var Wi = Object.freeze({\n        __proto__: null,\n        HALF_PI: E,\n        INFINITY: T,\n        PI: C,\n        PITAU: A,\n        QUARTER_PI: R,\n        RAD_PER_DEG: L,\n        TAU: O,\n        TWO_THIRDS_PI: I,\n        _addGrace: Di,\n        _alignPixel: Ae,\n        _alignStartEnd: ft,\n        _angleBetween: Z,\n        _angleDiff: K,\n        _arrayUnique: lt,\n        _attachContext: $e,\n        _bezierCurveTo: Ve,\n        _bezierInterpolation: mi,\n        _boundSegment: Ri,\n        _boundSegments: Ii,\n        _capitalize: w,\n        _computeSegments: zi,\n        _createResolver: je,\n        _decimalPlaces: U,\n        _deprecated: function(t, e, i, s) {\n            void 0 !== e && console.warn(t + ': \"' + i + '\" is deprecated. Please use \"' + s + '\" instead');\n        },\n        _descriptors: Ye,\n        _elementsEqual: f,\n        _factorize: W,\n        _filterBetween: nt,\n        _getParentNode: ge,\n        _getStartAndCountOfVisiblePoints: pt,\n        _int16Range: Q,\n        _isBetween: tt,\n        _isClickEvent: D,\n        _isDomSupported: fe,\n        _isPointInArea: Re,\n        _limitValue: J,\n        _longestText: Oe,\n        _lookup: et,\n        _lookupByKey: it,\n        _measureText: Ce,\n        _merger: m,\n        _mergerIf: _,\n        _normalizeAngle: G,\n        _parseObjectDataRadialScale: ii,\n        _pointInLine: gi,\n        _readValueToProps: vi,\n        _rlookupByKey: st,\n        _scaleRangesChanged: mt,\n        _setMinAndMaxByKey: j,\n        _splitKey: v,\n        _steppedInterpolation: pi,\n        _steppedLineTo: Fe,\n        _textX: gt,\n        _toLeftRightCenter: ut,\n        _updateBezierControlPoints: hi,\n        addRoundedRectPath: He,\n        almostEquals: V,\n        almostWhole: H,\n        callback: d,\n        clearCanvas: Te,\n        clipArea: Ie,\n        clone: g,\n        color: Qt,\n        createContext: Ci,\n        debounce: dt,\n        defined: k,\n        distanceBetweenPoints: q,\n        drawPoint: Le,\n        drawPointLegend: Ee,\n        each: u,\n        easingEffects: fi,\n        finiteOrDefault: r,\n        fontString: function(t, e, i) {\n            return e + \" \" + t + \"px \" + i;\n        },\n        formatNumber: ne,\n        getAngleFromPoint: X,\n        getHoverColor: te,\n        getMaximumSize: we,\n        getRelativePosition: ve,\n        getRtlAdapter: Oi,\n        getStyle: be,\n        isArray: n,\n        isFinite: a,\n        isFunction: S,\n        isNullOrUndef: s,\n        isNumber: N,\n        isObject: o,\n        isPatternOrGradient: Jt,\n        listenArrayEvents: at,\n        log10: z,\n        merge: b,\n        mergeIf: x,\n        niceNum: B,\n        noop: e,\n        overrideTextDirection: Ai,\n        readUsedSize: Pe,\n        renderText: Ne,\n        requestAnimFrame: ht,\n        resolve: Pi,\n        resolveObjectKey: M,\n        restoreTextDirection: Ti,\n        retinaScale: ke,\n        setsEqual: P,\n        sign: F,\n        splineCurve: ai,\n        splineCurveMonotone: ri,\n        supportsEventListenerOptions: Se,\n        throttled: ct,\n        toDegrees: Y,\n        toDimension: c,\n        toFont: Si,\n        toFontString: De,\n        toLineHeight: _i,\n        toPadding: ki,\n        toPercentage: h,\n        toRadians: $,\n        toTRBL: Mi,\n        toTRBLCorners: wi,\n        uid: i,\n        unclipArea: ze,\n        unlistenArrayEvents: rt,\n        valueOrDefault: l\n    });\n    function Ni(t, e, i, s) {\n        const { controller: n, data: o, _sorted: a } = t, r = n._cachedMeta.iScale;\n        if (r && e === r.axis && \"r\" !== e && a && o.length) {\n            const t = r._reversePixels ? st : it;\n            if (!s) return t(o, e, i);\n            if (n._sharedOptions) {\n                const s = o[0], n = \"function\" == typeof s.getRange && s.getRange(e);\n                if (n) {\n                    const s = t(o, e, i - n), a = t(o, e, i + n);\n                    return {\n                        lo: s.lo,\n                        hi: a.hi\n                    };\n                }\n            }\n        }\n        return {\n            lo: 0,\n            hi: o.length - 1\n        };\n    }\n    function Hi(t, e, i, s, n) {\n        const o = t.getSortedVisibleDatasetMetas(), a = i[e];\n        for(let t = 0, i = o.length; t < i; ++t){\n            const { index: i, data: r } = o[t], { lo: l, hi: h } = Ni(o[t], e, a, n);\n            for(let t = l; t <= h; ++t){\n                const e = r[t];\n                e.skip || s(e, i, t);\n            }\n        }\n    }\n    function ji(t, e, i, s, n) {\n        const o = [];\n        if (!n && !t.isPointInArea(e)) return o;\n        return Hi(t, i, e, function(i, a, r) {\n            (n || Re(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({\n                element: i,\n                datasetIndex: a,\n                index: r\n            });\n        }, !0), o;\n    }\n    function $i(t, e, i, s, n, o) {\n        let a = [];\n        const r = function(t) {\n            const e = -1 !== t.indexOf(\"x\"), i = -1 !== t.indexOf(\"y\");\n            return function(t, s) {\n                const n = e ? Math.abs(t.x - s.x) : 0, o = i ? Math.abs(t.y - s.y) : 0;\n                return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n            };\n        }(i);\n        let l = Number.POSITIVE_INFINITY;\n        return Hi(t, i, e, function(i, h, c) {\n            const d = i.inRange(e.x, e.y, n);\n            if (s && !d) return;\n            const u = i.getCenterPoint(n);\n            if (!(!!o || t.isPointInArea(u)) && !d) return;\n            const f = r(e, u);\n            f < l ? (a = [\n                {\n                    element: i,\n                    datasetIndex: h,\n                    index: c\n                }\n            ], l = f) : f === l && a.push({\n                element: i,\n                datasetIndex: h,\n                index: c\n            });\n        }), a;\n    }\n    function Yi(t, e, i, s, n, o) {\n        return o || t.isPointInArea(e) ? \"r\" !== i || s ? $i(t, e, i, s, n, o) : function(t, e, i, s) {\n            let n = [];\n            return Hi(t, i, e, function(t, i, o) {\n                const { startAngle: a, endAngle: r } = t.getProps([\n                    \"startAngle\",\n                    \"endAngle\"\n                ], s), { angle: l } = X(t, {\n                    x: e.x,\n                    y: e.y\n                });\n                Z(l, a, r) && n.push({\n                    element: t,\n                    datasetIndex: i,\n                    index: o\n                });\n            }), n;\n        }(t, e, i, n) : [];\n    }\n    function Ui(t, e, i, s, n) {\n        const o = [], a = \"x\" === i ? \"inXRange\" : \"inYRange\";\n        let r = !1;\n        return Hi(t, i, e, (t, s, l)=>{\n            t[a](e[i], n) && (o.push({\n                element: t,\n                datasetIndex: s,\n                index: l\n            }), r = r || t.inRange(e.x, e.y, n));\n        }), s && !r ? [] : o;\n    }\n    var Xi = {\n        evaluateInteractionItems: Hi,\n        modes: {\n            index (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"x\", a = i.includeInvisible || !1, r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a), l = [];\n                return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t)=>{\n                    const e = r[0].index, i = t.data[e];\n                    i && !i.skip && l.push({\n                        element: i,\n                        datasetIndex: t.index,\n                        index: e\n                    });\n                }), l) : [];\n            },\n            dataset (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                let r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a);\n                if (r.length > 0) {\n                    const e = r[0].datasetIndex, i = t.getDatasetMeta(e).data;\n                    r = [];\n                    for(let t = 0; t < i.length; ++t)r.push({\n                        element: i[t],\n                        datasetIndex: e,\n                        index: t\n                    });\n                }\n                return r;\n            },\n            point: (t, e, i, s)=>ji(t, ve(e, t), i.axis || \"xy\", s, i.includeInvisible || !1),\n            nearest (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                return Yi(t, n, o, i.intersect, s, a);\n            },\n            x: (t, e, i, s)=>Ui(t, ve(e, t), \"x\", i.intersect, s),\n            y: (t, e, i, s)=>Ui(t, ve(e, t), \"y\", i.intersect, s)\n        }\n    };\n    const qi = [\n        \"left\",\n        \"top\",\n        \"right\",\n        \"bottom\"\n    ];\n    function Ki(t, e) {\n        return t.filter((t)=>t.pos === e);\n    }\n    function Gi(t, e) {\n        return t.filter((t)=>-1 === qi.indexOf(t.pos) && t.box.axis === e);\n    }\n    function Zi(t, e) {\n        return t.sort((t, i)=>{\n            const s = e ? i : t, n = e ? t : i;\n            return s.weight === n.weight ? s.index - n.index : s.weight - n.weight;\n        });\n    }\n    function Ji(t, e) {\n        const i = function(t) {\n            const e = {};\n            for (const i of t){\n                const { stack: t, pos: s, stackWeight: n } = i;\n                if (!t || !qi.includes(s)) continue;\n                const o = e[t] || (e[t] = {\n                    count: 0,\n                    placed: 0,\n                    weight: 0,\n                    size: 0\n                });\n                o.count++, o.weight += n;\n            }\n            return e;\n        }(t), { vBoxMaxWidth: s, hBoxMaxHeight: n } = e;\n        let o, a, r;\n        for(o = 0, a = t.length; o < a; ++o){\n            r = t[o];\n            const { fullSize: a } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;\n            r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight);\n        }\n        return i;\n    }\n    function Qi(t, e, i, s) {\n        return Math.max(t[i], e[i]) + Math.max(t[s], e[s]);\n    }\n    function ts(t, e) {\n        t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);\n    }\n    function es(t, e, i, s) {\n        const { pos: n, box: a } = i, r = t.maxPadding;\n        if (!o(n)) {\n            i.size && (t[n] -= i.size);\n            const e = s[i.stack] || {\n                size: 0,\n                count: 1\n            };\n            e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[n] += i.size;\n        }\n        a.getPadding && ts(r, a.getPadding());\n        const l = Math.max(0, e.outerWidth - Qi(r, t, \"left\", \"right\")), h = Math.max(0, e.outerHeight - Qi(r, t, \"top\", \"bottom\")), c = l !== t.w, d = h !== t.h;\n        return t.w = l, t.h = h, i.horizontal ? {\n            same: c,\n            other: d\n        } : {\n            same: d,\n            other: c\n        };\n    }\n    function is(t, e) {\n        const i = e.maxPadding;\n        function s(t) {\n            const s = {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            };\n            return t.forEach((t)=>{\n                s[t] = Math.max(e[t], i[t]);\n            }), s;\n        }\n        return s(t ? [\n            \"left\",\n            \"right\"\n        ] : [\n            \"top\",\n            \"bottom\"\n        ]);\n    }\n    function ss(t, e, i, s) {\n        const n = [];\n        let o, a, r, l, h, c;\n        for(o = 0, a = t.length, h = 0; o < a; ++o){\n            r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, is(r.horizontal, e));\n            const { same: a, other: d } = es(e, i, r, s);\n            h |= a && n.length, c = c || d, l.fullSize || n.push(r);\n        }\n        return h && ss(n, e, i, s) || c;\n    }\n    function ns(t, e, i, s, n) {\n        t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n;\n    }\n    function os(t, e, i, s) {\n        const n = i.padding;\n        let { x: o, y: a } = e;\n        for (const r of t){\n            const t = r.box, l = s[r.stack] || {\n                count: 1,\n                placed: 0,\n                weight: 1\n            }, h = r.stackWeight / l.weight || 1;\n            if (r.horizontal) {\n                const s = e.w * h, o = l.size || t.height;\n                k(l.start) && (a = l.start), t.fullSize ? ns(t, n.left, a, i.outerWidth - n.right - n.left, o) : ns(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom;\n            } else {\n                const s = e.h * h, a = l.size || t.width;\n                k(l.start) && (o = l.start), t.fullSize ? ns(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : ns(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right;\n            }\n        }\n        e.x = o, e.y = a;\n    }\n    var as = {\n        addBox (t, e) {\n            t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || \"top\", e.weight = e.weight || 0, e._layers = e._layers || function() {\n                return [\n                    {\n                        z: 0,\n                        draw (t) {\n                            e.draw(t);\n                        }\n                    }\n                ];\n            }, t.boxes.push(e);\n        },\n        removeBox (t, e) {\n            const i = t.boxes ? t.boxes.indexOf(e) : -1;\n            -1 !== i && t.boxes.splice(i, 1);\n        },\n        configure (t, e, i) {\n            e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;\n        },\n        update (t, e, i, s) {\n            if (!t) return;\n            const n = ki(t.options.layout.padding), o = Math.max(e - n.width, 0), a = Math.max(i - n.height, 0), r = function(t) {\n                const e = function(t) {\n                    const e = [];\n                    let i, s, n, o, a, r;\n                    for(i = 0, s = (t || []).length; i < s; ++i)n = t[i], ({ position: o, options: { stack: a, stackWeight: r = 1 } } = n), e.push({\n                        index: i,\n                        box: n,\n                        pos: o,\n                        horizontal: n.isHorizontal(),\n                        weight: n.weight,\n                        stack: a && o + a,\n                        stackWeight: r\n                    });\n                    return e;\n                }(t), i = Zi(e.filter((t)=>t.box.fullSize), !0), s = Zi(Ki(e, \"left\"), !0), n = Zi(Ki(e, \"right\")), o = Zi(Ki(e, \"top\"), !0), a = Zi(Ki(e, \"bottom\")), r = Gi(e, \"x\"), l = Gi(e, \"y\");\n                return {\n                    fullSize: i,\n                    leftAndTop: s.concat(o),\n                    rightAndBottom: n.concat(l).concat(a).concat(r),\n                    chartArea: Ki(e, \"chartArea\"),\n                    vertical: s.concat(n).concat(l),\n                    horizontal: o.concat(a).concat(r)\n                };\n            }(t.boxes), l = r.vertical, h = r.horizontal;\n            u(t.boxes, (t)=>{\n                \"function\" == typeof t.beforeLayout && t.beforeLayout();\n            });\n            const c = l.reduce((t, e)=>e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1, d = Object.freeze({\n                outerWidth: e,\n                outerHeight: i,\n                padding: n,\n                availableWidth: o,\n                availableHeight: a,\n                vBoxMaxWidth: o / 2 / c,\n                hBoxMaxHeight: a / 2\n            }), f = Object.assign({}, n);\n            ts(f, ki(s));\n            const g = Object.assign({\n                maxPadding: f,\n                w: o,\n                h: a,\n                x: n.left,\n                y: n.top\n            }, n), p = Ji(l.concat(h), d);\n            ss(r.fullSize, g, d, p), ss(l, g, d, p), ss(h, g, d, p) && ss(l, g, d, p), function(t) {\n                const e = t.maxPadding;\n                function i(i) {\n                    const s = Math.max(e[i] - t[i], 0);\n                    return t[i] += s, s;\n                }\n                t.y += i(\"top\"), t.x += i(\"left\"), i(\"right\"), i(\"bottom\");\n            }(g), os(r.leftAndTop, g, d, p), g.x += g.w, g.y += g.h, os(r.rightAndBottom, g, d, p), t.chartArea = {\n                left: g.left,\n                top: g.top,\n                right: g.left + g.w,\n                bottom: g.top + g.h,\n                height: g.h,\n                width: g.w\n            }, u(r.chartArea, (e)=>{\n                const i = e.box;\n                Object.assign(i, t.chartArea), i.update(g.w, g.h, {\n                    left: 0,\n                    top: 0,\n                    right: 0,\n                    bottom: 0\n                });\n            });\n        }\n    };\n    class rs {\n        acquireContext(t, e) {}\n        releaseContext(t) {\n            return !1;\n        }\n        addEventListener(t, e, i) {}\n        removeEventListener(t, e, i) {}\n        getDevicePixelRatio() {\n            return 1;\n        }\n        getMaximumSize(t, e, i, s) {\n            return e = Math.max(0, e || t.width), i = i || t.height, {\n                width: e,\n                height: Math.max(0, s ? Math.floor(e / s) : i)\n            };\n        }\n        isAttached(t) {\n            return !0;\n        }\n        updateConfig(t) {}\n    }\n    class ls extends rs {\n        acquireContext(t) {\n            return t && t.getContext && t.getContext(\"2d\") || null;\n        }\n        updateConfig(t) {\n            t.options.animation = !1;\n        }\n    }\n    const hs = \"$chartjs\", cs = {\n        touchstart: \"mousedown\",\n        touchmove: \"mousemove\",\n        touchend: \"mouseup\",\n        pointerenter: \"mouseenter\",\n        pointerdown: \"mousedown\",\n        pointermove: \"mousemove\",\n        pointerup: \"mouseup\",\n        pointerleave: \"mouseout\",\n        pointerout: \"mouseout\"\n    }, ds = (t)=>null === t || \"\" === t;\n    const us = !!Se && {\n        passive: !0\n    };\n    function fs(t, e, i) {\n        t.canvas.removeEventListener(e, i, us);\n    }\n    function gs(t, e) {\n        for (const i of t)if (i === e || i.contains(e)) return !0;\n    }\n    function ps(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.addedNodes, s), e = e && !gs(i.removedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    function ms(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.removedNodes, s), e = e && !gs(i.addedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    const bs = new Map;\n    let xs = 0;\n    function _s() {\n        const t = window.devicePixelRatio;\n        t !== xs && (xs = t, bs.forEach((e, i)=>{\n            i.currentDevicePixelRatio !== t && e();\n        }));\n    }\n    function ys(t, e, i) {\n        const s = t.canvas, n = s && ge(s);\n        if (!n) return;\n        const o = ct((t, e)=>{\n            const s = n.clientWidth;\n            i(t, e), s < n.clientWidth && i();\n        }, window), a = new ResizeObserver((t)=>{\n            const e = t[0], i = e.contentRect.width, s = e.contentRect.height;\n            0 === i && 0 === s || o(i, s);\n        });\n        return a.observe(n), function(t, e) {\n            bs.size || window.addEventListener(\"resize\", _s), bs.set(t, e);\n        }(t, o), a;\n    }\n    function vs(t, e, i) {\n        i && i.disconnect(), \"resize\" === e && function(t) {\n            bs.delete(t), bs.size || window.removeEventListener(\"resize\", _s);\n        }(t);\n    }\n    function Ms(t, e, i) {\n        const s = t.canvas, n = ct((e)=>{\n            null !== t.ctx && i(function(t, e) {\n                const i = cs[t.type] || t.type, { x: s, y: n } = ve(t, e);\n                return {\n                    type: i,\n                    chart: e,\n                    native: t,\n                    x: void 0 !== s ? s : null,\n                    y: void 0 !== n ? n : null\n                };\n            }(e, t));\n        }, t);\n        return function(t, e, i) {\n            t.addEventListener(e, i, us);\n        }(s, e, n), n;\n    }\n    class ws extends rs {\n        acquireContext(t, e) {\n            const i = t && t.getContext && t.getContext(\"2d\");\n            return i && i.canvas === t ? (function(t, e) {\n                const i = t.style, s = t.getAttribute(\"height\"), n = t.getAttribute(\"width\");\n                if (t[hs] = {\n                    initial: {\n                        height: s,\n                        width: n,\n                        style: {\n                            display: i.display,\n                            height: i.height,\n                            width: i.width\n                        }\n                    }\n                }, i.display = i.display || \"block\", i.boxSizing = i.boxSizing || \"border-box\", ds(n)) {\n                    const e = Pe(t, \"width\");\n                    void 0 !== e && (t.width = e);\n                }\n                if (ds(s)) {\n                    if (\"\" === t.style.height) t.height = t.width / (e || 2);\n                    else {\n                        const e = Pe(t, \"height\");\n                        void 0 !== e && (t.height = e);\n                    }\n                }\n            }(t, e), i) : null;\n        }\n        releaseContext(t) {\n            const e = t.canvas;\n            if (!e[hs]) return !1;\n            const i = e[hs].initial;\n            [\n                \"height\",\n                \"width\"\n            ].forEach((t)=>{\n                const n = i[t];\n                s(n) ? e.removeAttribute(t) : e.setAttribute(t, n);\n            });\n            const n = i.style || {};\n            return Object.keys(n).forEach((t)=>{\n                e.style[t] = n[t];\n            }), e.width = e.width, delete e[hs], !0;\n        }\n        addEventListener(t, e, i) {\n            this.removeEventListener(t, e);\n            const s = t.$proxies || (t.$proxies = {}), n = {\n                attach: ps,\n                detach: ms,\n                resize: ys\n            }[e] || Ms;\n            s[e] = n(t, e, i);\n        }\n        removeEventListener(t, e) {\n            const i = t.$proxies || (t.$proxies = {}), s = i[e];\n            if (!s) return;\n            (({\n                attach: vs,\n                detach: vs,\n                resize: vs\n            })[e] || fs)(t, e, s), i[e] = void 0;\n        }\n        getDevicePixelRatio() {\n            return window.devicePixelRatio;\n        }\n        getMaximumSize(t, e, i, s) {\n            return we(t, e, i, s);\n        }\n        isAttached(t) {\n            const e = ge(t);\n            return !(!e || !e.isConnected);\n        }\n    }\n    function ks(t) {\n        return !fe() || \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? ls : ws;\n    }\n    var Ss = Object.freeze({\n        __proto__: null,\n        BasePlatform: rs,\n        BasicPlatform: ls,\n        DomPlatform: ws,\n        _detectPlatform: ks\n    });\n    const Ps = \"transparent\", Ds = {\n        boolean: (t, e, i)=>i > .5 ? e : t,\n        color (t, e, i) {\n            const s = Qt(t || Ps), n = s.valid && Qt(e || Ps);\n            return n && n.valid ? n.mix(s, i).hexString() : e;\n        },\n        number: (t, e, i)=>t + (e - t) * i\n    };\n    class Cs {\n        constructor(t, e, i, s){\n            const n = e[i];\n            s = Pi([\n                t.to,\n                s,\n                n,\n                t.from\n            ]);\n            const o = Pi([\n                t.from,\n                n,\n                s\n            ]);\n            this._active = !0, this._fn = t.fn || Ds[t.type || typeof o], this._easing = fi[t.easing] || fi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0;\n        }\n        active() {\n            return this._active;\n        }\n        update(t, e, i) {\n            if (this._active) {\n                this._notify(!1);\n                const s = this._target[this._prop], n = i - this._start, o = this._duration - n;\n                this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Pi([\n                    t.to,\n                    e,\n                    s,\n                    t.from\n                ]), this._from = Pi([\n                    t.from,\n                    s,\n                    e\n                ]);\n            }\n        }\n        cancel() {\n            this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n        }\n        tick(t) {\n            const e = t - this._start, i = this._duration, s = this._prop, n = this._from, o = this._loop, a = this._to;\n            let r;\n            if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);\n            e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r));\n        }\n        wait() {\n            const t = this._promises || (this._promises = []);\n            return new Promise((e, i)=>{\n                t.push({\n                    res: e,\n                    rej: i\n                });\n            });\n        }\n        _notify(t) {\n            const e = t ? \"res\" : \"rej\", i = this._promises || [];\n            for(let t = 0; t < i.length; t++)i[t][e]();\n        }\n    }\n    class Os {\n        constructor(t, e){\n            this._chart = t, this._properties = new Map, this.configure(e);\n        }\n        configure(t) {\n            if (!o(t)) return;\n            const e = Object.keys(ue.animation), i = this._properties;\n            Object.getOwnPropertyNames(t).forEach((s)=>{\n                const a = t[s];\n                if (!o(a)) return;\n                const r = {};\n                for (const t of e)r[t] = a[t];\n                (n(a.properties) && a.properties || [\n                    s\n                ]).forEach((t)=>{\n                    t !== s && i.has(t) || i.set(t, r);\n                });\n            });\n        }\n        _animateOptions(t, e) {\n            const i = e.options, s = function(t, e) {\n                if (!e) return;\n                let i = t.options;\n                if (!i) return void (t.options = e);\n                i.$shared && (t.options = i = Object.assign({}, i, {\n                    $shared: !1,\n                    $animations: {}\n                }));\n                return i;\n            }(t, i);\n            if (!s) return [];\n            const n = this._createAnimations(s, i);\n            return i.$shared && (function(t, e) {\n                const i = [], s = Object.keys(e);\n                for(let e = 0; e < s.length; e++){\n                    const n = t[s[e]];\n                    n && n.active() && i.push(n.wait());\n                }\n                return Promise.all(i);\n            })(t.options.$animations, i).then(()=>{\n                t.options = i;\n            }, ()=>{}), n;\n        }\n        _createAnimations(t, e) {\n            const i = this._properties, s = [], n = t.$animations || (t.$animations = {}), o = Object.keys(e), a = Date.now();\n            let r;\n            for(r = o.length - 1; r >= 0; --r){\n                const l = o[r];\n                if (\"$\" === l.charAt(0)) continue;\n                if (\"options\" === l) {\n                    s.push(...this._animateOptions(t, e));\n                    continue;\n                }\n                const h = e[l];\n                let c = n[l];\n                const d = i.get(l);\n                if (c) {\n                    if (d && c.active()) {\n                        c.update(d, h, a);\n                        continue;\n                    }\n                    c.cancel();\n                }\n                d && d.duration ? (n[l] = c = new Cs(d, t, l, h), s.push(c)) : t[l] = h;\n            }\n            return s;\n        }\n        update(t, e) {\n            if (0 === this._properties.size) return void Object.assign(t, e);\n            const i = this._createAnimations(t, e);\n            return i.length ? (xt.add(this._chart, i), !0) : void 0;\n        }\n    }\n    function As(t, e) {\n        const i = t && t.options || {}, s = i.reverse, n = void 0 === i.min ? e : 0, o = void 0 === i.max ? e : 0;\n        return {\n            start: s ? o : n,\n            end: s ? n : o\n        };\n    }\n    function Ts(t, e) {\n        const i = [], s = t._getSortedDatasetMetas(e);\n        let n, o;\n        for(n = 0, o = s.length; n < o; ++n)i.push(s[n].index);\n        return i;\n    }\n    function Ls(t, e, i, s = {}) {\n        const n = t.keys, o = \"single\" === s.mode;\n        let r, l, h, c;\n        if (null !== e) {\n            for(r = 0, l = n.length; r < l; ++r){\n                if (h = +n[r], h === i) {\n                    if (s.all) continue;\n                    break;\n                }\n                c = t.values[h], a(c) && (o || 0 === e || F(e) === F(c)) && (e += c);\n            }\n            return e;\n        }\n    }\n    function Es(t, e) {\n        const i = t && t.options.stacked;\n        return i || void 0 === i && void 0 !== e.stack;\n    }\n    function Rs(t, e, i) {\n        const s = t[e] || (t[e] = {});\n        return s[i] || (s[i] = {});\n    }\n    function Is(t, e, i, s) {\n        for (const n of e.getMatchingVisibleMetas(s).reverse()){\n            const e = t[n.index];\n            if (i && e > 0 || !i && e < 0) return n.index;\n        }\n        return null;\n    }\n    function zs(t, e) {\n        const { chart: i, _cachedMeta: s } = t, n = i._stacks || (i._stacks = {}), { iScale: o, vScale: a, index: r } = s, l = o.axis, h = a.axis, c = function(t, e, i) {\n            return `${t.id}.${e.id}.${i.stack || i.type}`;\n        }(o, a, s), d = e.length;\n        let u;\n        for(let t = 0; t < d; ++t){\n            const i = e[t], { [l]: o, [h]: d } = i;\n            u = (i._stacks || (i._stacks = {}))[h] = Rs(n, c, o), u[r] = d, u._top = Is(u, a, !0, s.type), u._bottom = Is(u, a, !1, s.type);\n            (u._visualValues || (u._visualValues = {}))[r] = d;\n        }\n    }\n    function Fs(t, e) {\n        const i = t.scales;\n        return Object.keys(i).filter((t)=>i[t].axis === e).shift();\n    }\n    function Vs(t, e) {\n        const i = t.controller.index, s = t.vScale && t.vScale.axis;\n        if (s) {\n            e = e || t._parsed;\n            for (const t of e){\n                const e = t._stacks;\n                if (!e || void 0 === e[s] || void 0 === e[s][i]) return;\n                delete e[s][i], void 0 !== e[s]._visualValues && void 0 !== e[s]._visualValues[i] && delete e[s]._visualValues[i];\n            }\n        }\n    }\n    const Bs = (t)=>\"reset\" === t || \"none\" === t, Ws = (t, e)=>e ? t : Object.assign({}, t);\n    class Ns {\n        static defaults = {};\n        static datasetElementType = null;\n        static dataElementType = null;\n        constructor(t, e){\n            this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();\n        }\n        initialize() {\n            const t = this._cachedMeta;\n            this.configure(), this.linkScales(), t._stacked = Es(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled(\"filler\") && console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n        updateIndex(t) {\n            this.index !== t && Vs(this._cachedMeta), this.index = t;\n        }\n        linkScales() {\n            const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (t, e, i, s)=>\"x\" === t ? e : \"r\" === t ? s : i, n = e.xAxisID = l(i.xAxisID, Fs(t, \"x\")), o = e.yAxisID = l(i.yAxisID, Fs(t, \"y\")), a = e.rAxisID = l(i.rAxisID, Fs(t, \"r\")), r = e.indexAxis, h = e.iAxisID = s(r, n, o, a), c = e.vAxisID = s(r, o, n, a);\n            e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c);\n        }\n        getDataset() {\n            return this.chart.data.datasets[this.index];\n        }\n        getMeta() {\n            return this.chart.getDatasetMeta(this.index);\n        }\n        getScaleForId(t) {\n            return this.chart.scales[t];\n        }\n        _getOtherScale(t) {\n            const e = this._cachedMeta;\n            return t === e.iScale ? e.vScale : e.iScale;\n        }\n        reset() {\n            this._update(\"reset\");\n        }\n        _destroy() {\n            const t = this._cachedMeta;\n            this._data && rt(this._data, this), t._stacked && Vs(t);\n        }\n        _dataCheck() {\n            const t = this.getDataset(), e = t.data || (t.data = []), i = this._data;\n            if (o(e)) this._data = function(t) {\n                const e = Object.keys(t), i = new Array(e.length);\n                let s, n, o;\n                for(s = 0, n = e.length; s < n; ++s)o = e[s], i[s] = {\n                    x: o,\n                    y: t[o]\n                };\n                return i;\n            }(e);\n            else if (i !== e) {\n                if (i) {\n                    rt(i, this);\n                    const t = this._cachedMeta;\n                    Vs(t), t._parsed = [];\n                }\n                e && Object.isExtensible(e) && at(e, this), this._syncList = [], this._data = e;\n            }\n        }\n        addElements() {\n            const t = this._cachedMeta;\n            this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType);\n        }\n        buildOrUpdateElements(t) {\n            const e = this._cachedMeta, i = this.getDataset();\n            let s = !1;\n            this._dataCheck();\n            const n = e._stacked;\n            e._stacked = Es(e.vScale, e), e.stack !== i.stack && (s = !0, Vs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && zs(this, e._parsed);\n        }\n        configure() {\n            const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0);\n            this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n        }\n        parse(t, e) {\n            const { _cachedMeta: i, _data: s } = this, { iScale: a, _stacked: r } = i, l = a.axis;\n            let h, c, d, u = 0 === t && e === s.length || i._sorted, f = t > 0 && i._parsed[t - 1];\n            if (!1 === this._parsing) i._parsed = s, i._sorted = !0, d = s;\n            else {\n                d = n(s[t]) ? this.parseArrayData(i, s, t, e) : o(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);\n                const a = ()=>null === c[l] || f && c[l] < f[l];\n                for(h = 0; h < e; ++h)i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);\n                i._sorted = u;\n            }\n            r && zs(this, d);\n        }\n        parsePrimitiveData(t, e, i, s) {\n            const { iScale: n, vScale: o } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);\n            let d, u, f;\n            for(d = 0, u = s; d < u; ++d)f = d + i, c[d] = {\n                [a]: h || n.parse(l[f], f),\n                [r]: o.parse(e[f], f)\n            };\n            return c;\n        }\n        parseArrayData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, a = new Array(s);\n            let r, l, h, c;\n            for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n                x: n.parse(c[0], h),\n                y: o.parse(c[1], h)\n            };\n            return a;\n        }\n        parseObjectData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = new Array(s);\n            let h, c, d, u;\n            for(h = 0, c = s; h < c; ++h)d = h + i, u = e[d], l[h] = {\n                x: n.parse(M(u, a), d),\n                y: o.parse(M(u, r), d)\n            };\n            return l;\n        }\n        getParsed(t) {\n            return this._cachedMeta._parsed[t];\n        }\n        getDataElement(t) {\n            return this._cachedMeta.data[t];\n        }\n        applyStack(t, e, i) {\n            const s = this.chart, n = this._cachedMeta, o = e[t.axis];\n            return Ls({\n                keys: Ts(s, !0),\n                values: e._stacks[t.axis]._visualValues\n            }, o, n.index, {\n                mode: i\n            });\n        }\n        updateRangeFromParsed(t, e, i, s) {\n            const n = i[e.axis];\n            let o = null === n ? NaN : n;\n            const a = s && i._stacks[e.axis];\n            s && a && (s.values = a, o = Ls(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);\n        }\n        getMinMax(t, e) {\n            const i = this._cachedMeta, s = i._parsed, n = i._sorted && t === i.iScale, o = s.length, r = this._getOtherScale(t), l = ((t, e, i)=>t && !e.hidden && e._stacked && {\n                    keys: Ts(i, !0),\n                    values: null\n                })(e, i, this.chart), h = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            }, { min: c, max: d } = function(t) {\n                const { min: e, max: i, minDefined: s, maxDefined: n } = t.getUserBounds();\n                return {\n                    min: s ? e : Number.NEGATIVE_INFINITY,\n                    max: n ? i : Number.POSITIVE_INFINITY\n                };\n            }(r);\n            let u, f;\n            function g() {\n                f = s[u];\n                const e = f[r.axis];\n                return !a(f[t.axis]) || c > e || d < e;\n            }\n            for(u = 0; u < o && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);\n            if (n) {\n                for(u = o - 1; u >= 0; --u)if (!g()) {\n                    this.updateRangeFromParsed(h, t, f, l);\n                    break;\n                }\n            }\n            return h;\n        }\n        getAllParsedValues(t) {\n            const e = this._cachedMeta._parsed, i = [];\n            let s, n, o;\n            for(s = 0, n = e.length; s < n; ++s)o = e[s][t.axis], a(o) && i.push(o);\n            return i;\n        }\n        getMaxOverflow() {\n            return !1;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = e.iScale, s = e.vScale, n = this.getParsed(t);\n            return {\n                label: i ? \"\" + i.getLabelForValue(n[i.axis]) : \"\",\n                value: s ? \"\" + s.getLabelForValue(n[s.axis]) : \"\"\n            };\n        }\n        _update(t) {\n            const e = this._cachedMeta;\n            this.update(t || \"default\"), e._clip = function(t) {\n                let e, i, s, n;\n                return o(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {\n                    top: e,\n                    right: i,\n                    bottom: s,\n                    left: n,\n                    disabled: !1 === t\n                };\n            }(l(this.options.clip, function(t, e, i) {\n                if (!1 === i) return !1;\n                const s = As(t, i), n = As(e, i);\n                return {\n                    top: n.end,\n                    right: s.end,\n                    bottom: n.start,\n                    left: s.start\n                };\n            }(e.xScale, e.yScale, this.getMaxOverflow())));\n        }\n        update(t) {}\n        draw() {\n            const t = this._ctx, e = this.chart, i = this._cachedMeta, s = i.data || [], n = e.chartArea, o = [], a = this._drawStart || 0, r = this._drawCount || s.length - a, l = this.options.drawActiveElementsOnTop;\n            let h;\n            for(i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h){\n                const e = s[h];\n                e.hidden || (e.active && l ? o.push(e) : e.draw(t, n));\n            }\n            for(h = 0; h < o.length; ++h)o[h].draw(t, n);\n        }\n        getStyle(t, e) {\n            const i = e ? \"active\" : \"default\";\n            return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);\n        }\n        getContext(t, e, i) {\n            const s = this.getDataset();\n            let n;\n            if (t >= 0 && t < this._cachedMeta.data.length) {\n                const e = this._cachedMeta.data[t];\n                n = e.$context || (e.$context = function(t, e, i) {\n                    return Ci(t, {\n                        active: !1,\n                        dataIndex: e,\n                        parsed: void 0,\n                        raw: void 0,\n                        element: i,\n                        index: e,\n                        mode: \"default\",\n                        type: \"data\"\n                    });\n                }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t;\n            } else n = this.$context || (this.$context = function(t, e) {\n                return Ci(t, {\n                    active: !1,\n                    dataset: void 0,\n                    datasetIndex: e,\n                    index: e,\n                    mode: \"default\",\n                    type: \"dataset\"\n                });\n            }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;\n            return n.active = !!e, n.mode = i, n;\n        }\n        resolveDatasetElementOptions(t) {\n            return this._resolveElementOptions(this.datasetElementType.id, t);\n        }\n        resolveDataElementOptions(t, e) {\n            return this._resolveElementOptions(this.dataElementType.id, e, t);\n        }\n        _resolveElementOptions(t, e = \"default\", i) {\n            const s = \"active\" === e, n = this._cachedDataOpts, o = t + \"-\" + e, a = n[o], r = this.enableOptionSharing && k(i);\n            if (a) return Ws(a, r);\n            const l = this.chart.config, h = l.datasetElementScopeKeys(this._type, t), c = s ? [\n                `${t}Hover`,\n                \"hover\",\n                t,\n                \"\"\n            ] : [\n                t,\n                \"\"\n            ], d = l.getOptionScopes(this.getDataset(), h), u = Object.keys(ue.elements[t]), f = l.resolveNamedOptions(d, u, ()=>this.getContext(i, s, e), c);\n            return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ws(f, r))), f;\n        }\n        _resolveAnimations(t, e, i) {\n            const s = this.chart, n = this._cachedDataOpts, o = `animation-${e}`, a = n[o];\n            if (a) return a;\n            let r;\n            if (!1 !== s.options.animation) {\n                const s = this.chart.config, n = s.datasetAnimationScopeKeys(this._type, e), o = s.getOptionScopes(this.getDataset(), n);\n                r = s.createResolver(o, this.getContext(t, i, e));\n            }\n            const l = new Os(s, r && r.animations);\n            return r && r._cacheable && (n[o] = Object.freeze(l)), l;\n        }\n        getSharedOptions(t) {\n            if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n        }\n        includeOptions(t, e) {\n            return !e || Bs(t) || this.chart._animationsDisabled;\n        }\n        _getSharedOptions(t, e) {\n            const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, n = this.getSharedOptions(i), o = this.includeOptions(e, n) || n !== s;\n            return this.updateSharedOptions(n, e, i), {\n                sharedOptions: n,\n                includeOptions: o\n            };\n        }\n        updateElement(t, e, i, s) {\n            Bs(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);\n        }\n        updateSharedOptions(t, e, i) {\n            t && !Bs(e) && this._resolveAnimations(void 0, e).update(t, i);\n        }\n        _setStyle(t, e, i, s) {\n            t.active = s;\n            const n = this.getStyle(e, s);\n            this._resolveAnimations(e, i, s).update(t, {\n                options: !s && this.getSharedOptions(n) || n\n            });\n        }\n        removeHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !1);\n        }\n        setHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !0);\n        }\n        _removeDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !1);\n        }\n        _setDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !0);\n        }\n        _resyncElements(t) {\n            const e = this._data, i = this._cachedMeta.data;\n            for (const [t, e, i] of this._syncList)this[t](e, i);\n            this._syncList = [];\n            const s = i.length, n = e.length, o = Math.min(n, s);\n            o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n);\n        }\n        _insertElements(t, e, i = !0) {\n            const s = this._cachedMeta, n = s.data, o = t + e;\n            let a;\n            const r = (t)=>{\n                for(t.length += e, a = t.length - 1; a >= o; a--)t[a] = t[a - e];\n            };\n            for(r(n), a = t; a < o; ++a)n[a] = new this.dataElementType;\n            this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, \"reset\");\n        }\n        updateElements(t, e, i, s) {}\n        _removeElements(t, e) {\n            const i = this._cachedMeta;\n            if (this._parsing) {\n                const s = i._parsed.splice(t, e);\n                i._stacked && Vs(i, s);\n            }\n            i.data.splice(t, e);\n        }\n        _sync(t) {\n            if (this._parsing) this._syncList.push(t);\n            else {\n                const [e, i, s] = t;\n                this[e](i, s);\n            }\n            this.chart._dataChanges.push([\n                this.index,\n                ...t\n            ]);\n        }\n        _onDataPush() {\n            const t = arguments.length;\n            this._sync([\n                \"_insertElements\",\n                this.getDataset().data.length - t,\n                t\n            ]);\n        }\n        _onDataPop() {\n            this._sync([\n                \"_removeElements\",\n                this._cachedMeta.data.length - 1,\n                1\n            ]);\n        }\n        _onDataShift() {\n            this._sync([\n                \"_removeElements\",\n                0,\n                1\n            ]);\n        }\n        _onDataSplice(t, e) {\n            e && this._sync([\n                \"_removeElements\",\n                t,\n                e\n            ]);\n            const i = arguments.length - 2;\n            i && this._sync([\n                \"_insertElements\",\n                t,\n                i\n            ]);\n        }\n        _onDataUnshift() {\n            this._sync([\n                \"_insertElements\",\n                0,\n                arguments.length\n            ]);\n        }\n    }\n    class Hs {\n        static defaults = {};\n        static defaultRoutes = void 0;\n        x;\n        y;\n        active = !1;\n        options;\n        $animations;\n        tooltipPosition(t) {\n            const { x: e, y: i } = this.getProps([\n                \"x\",\n                \"y\"\n            ], t);\n            return {\n                x: e,\n                y: i\n            };\n        }\n        hasValue() {\n            return N(this.x) && N(this.y);\n        }\n        getProps(t, e) {\n            const i = this.$animations;\n            if (!e || !i) return this;\n            const s = {};\n            return t.forEach((t)=>{\n                s[t] = i[t] && i[t].active() ? i[t]._to : this[t];\n            }), s;\n        }\n    }\n    function js(t, e) {\n        const i = t.options.ticks, n = function(t) {\n            const e = t.options.offset, i = t._tickSize(), s = t._length / i + (e ? 0 : 1), n = t._maxLength / i;\n            return Math.floor(Math.min(s, n));\n        }(t), o = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? function(t) {\n            const e = [];\n            let i, s;\n            for(i = 0, s = t.length; i < s; i++)t[i].major && e.push(i);\n            return e;\n        }(e) : [], r = a.length, l = a[0], h = a[r - 1], c = [];\n        if (r > o) return function(t, e, i, s) {\n            let n, o = 0, a = i[0];\n            for(s = Math.ceil(s), n = 0; n < t.length; n++)n === a && (e.push(t[n]), o++, a = i[o * s]);\n        }(e, c, a, r / o), c;\n        const d = function(t, e, i) {\n            const s = function(t) {\n                const e = t.length;\n                let i, s;\n                if (e < 2) return !1;\n                for(s = t[0], i = 1; i < e; ++i)if (t[i] - t[i - 1] !== s) return !1;\n                return s;\n            }(t), n = e.length / i;\n            if (!s) return Math.max(n, 1);\n            const o = W(s);\n            for(let t = 0, e = o.length - 1; t < e; t++){\n                const e = o[t];\n                if (e > n) return e;\n            }\n            return Math.max(n, 1);\n        }(a, e, o);\n        if (r > 0) {\n            let t, i;\n            const n = r > 1 ? Math.round((h - l) / (r - 1)) : null;\n            for($s(e, c, d, s(n) ? 0 : l - n, l), t = 0, i = r - 1; t < i; t++)$s(e, c, d, a[t], a[t + 1]);\n            return $s(e, c, d, h, s(n) ? e.length : h + n), c;\n        }\n        return $s(e, c, d), c;\n    }\n    function $s(t, e, i, s, n) {\n        const o = l(s, 0), a = Math.min(l(n, t.length), t.length);\n        let r, h, c, d = 0;\n        for(i = Math.ceil(i), n && (r = n - s, i = r / Math.floor(r / i)), c = o; c < 0;)d++, c = Math.round(o + d * i);\n        for(h = Math.max(o, 0); h < a; h++)h === c && (e.push(t[h]), d++, c = Math.round(o + d * i));\n    }\n    const Ys = (t, e, i)=>\"top\" === e || \"left\" === e ? t[e] + i : t[e] - i, Us = (t, e)=>Math.min(e || t, t);\n    function Xs(t, e) {\n        const i = [], s = t.length / e, n = t.length;\n        let o = 0;\n        for(; o < n; o += s)i.push(t[Math.floor(o)]);\n        return i;\n    }\n    function qs(t, e, i) {\n        const s = t.ticks.length, n = Math.min(e, s - 1), o = t._startPixel, a = t._endPixel, r = 1e-6;\n        let l, h = t.getPixelForTick(n);\n        if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h;\n    }\n    function Ks(t) {\n        return t.drawTicks ? t.tickLength : 0;\n    }\n    function Gs(t, e) {\n        if (!t.display) return 0;\n        const i = Si(t.font, e), s = ki(t.padding);\n        return (n(t.text) ? t.text.length : 1) * i.lineHeight + s.height;\n    }\n    function Zs(t, e, i) {\n        let s = ut(t);\n        return (i && \"right\" !== e || !i && \"right\" === e) && (s = ((t)=>\"left\" === t ? \"right\" : \"right\" === t ? \"left\" : t)(s)), s;\n    }\n    class Js extends Hs {\n        constructor(t){\n            super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n        }\n        init(t) {\n            this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n        }\n        parse(t, e) {\n            return t;\n        }\n        getUserBounds() {\n            let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this;\n            return t = r(t, Number.POSITIVE_INFINITY), e = r(e, Number.NEGATIVE_INFINITY), i = r(i, Number.POSITIVE_INFINITY), s = r(s, Number.NEGATIVE_INFINITY), {\n                min: r(t, i),\n                max: r(e, s),\n                minDefined: a(t),\n                maxDefined: a(e)\n            };\n        }\n        getMinMax(t) {\n            let e, { min: i, max: s, minDefined: n, maxDefined: o } = this.getUserBounds();\n            if (n && o) return {\n                min: i,\n                max: s\n            };\n            const a = this.getMatchingVisibleMetas();\n            for(let r = 0, l = a.length; r < l; ++r)e = a[r].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));\n            return i = o && i > s ? s : i, s = n && i > s ? i : s, {\n                min: r(i, r(s, i)),\n                max: r(s, r(i, s))\n            };\n        }\n        getPadding() {\n            return {\n                left: this.paddingLeft || 0,\n                top: this.paddingTop || 0,\n                right: this.paddingRight || 0,\n                bottom: this.paddingBottom || 0\n            };\n        }\n        getTicks() {\n            return this.ticks;\n        }\n        getLabels() {\n            const t = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n        }\n        getLabelItems(t = this.chart.chartArea) {\n            return this._labelItems || (this._labelItems = this._computeLabelItems(t));\n        }\n        beforeLayout() {\n            this._cache = {}, this._dataLimitsCached = !1;\n        }\n        beforeUpdate() {\n            d(this.options.beforeUpdate, [\n                this\n            ]);\n        }\n        update(t, e, i) {\n            const { beginAtZero: s, grace: n, ticks: o } = this.options, a = o.sampleSize;\n            this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Di(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n            const r = a < this.ticks.length;\n            this._convertTicksToLabels(r ? Xs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || \"auto\" === o.source) && (this.ticks = js(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n        }\n        configure() {\n            let t, e, i = this.options.reverse;\n            this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels;\n        }\n        afterUpdate() {\n            d(this.options.afterUpdate, [\n                this\n            ]);\n        }\n        beforeSetDimensions() {\n            d(this.options.beforeSetDimensions, [\n                this\n            ]);\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n        }\n        afterSetDimensions() {\n            d(this.options.afterSetDimensions, [\n                this\n            ]);\n        }\n        _callHooks(t) {\n            this.chart.notifyPlugins(t, this.getContext()), d(this.options[t], [\n                this\n            ]);\n        }\n        beforeDataLimits() {\n            this._callHooks(\"beforeDataLimits\");\n        }\n        determineDataLimits() {}\n        afterDataLimits() {\n            this._callHooks(\"afterDataLimits\");\n        }\n        beforeBuildTicks() {\n            this._callHooks(\"beforeBuildTicks\");\n        }\n        buildTicks() {\n            return [];\n        }\n        afterBuildTicks() {\n            this._callHooks(\"afterBuildTicks\");\n        }\n        beforeTickToLabelConversion() {\n            d(this.options.beforeTickToLabelConversion, [\n                this\n            ]);\n        }\n        generateTickLabels(t) {\n            const e = this.options.ticks;\n            let i, s, n;\n            for(i = 0, s = t.length; i < s; i++)n = t[i], n.label = d(e.callback, [\n                n.value,\n                i,\n                t\n            ], this);\n        }\n        afterTickToLabelConversion() {\n            d(this.options.afterTickToLabelConversion, [\n                this\n            ]);\n        }\n        beforeCalculateLabelRotation() {\n            d(this.options.beforeCalculateLabelRotation, [\n                this\n            ]);\n        }\n        calculateLabelRotation() {\n            const t = this.options, e = t.ticks, i = Us(this.ticks.length, t.ticks.maxTicksLimit), s = e.minRotation || 0, n = e.maxRotation;\n            let o, a, r, l = s;\n            if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s);\n            const h = this._getLabelSizes(), c = h.widest.width, d = h.highest.height, u = J(this.chart.width - c, 0, this.maxWidth);\n            o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ks(t.grid) - e.padding - Gs(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = Y(Math.min(Math.asin(J((h.highest.height + 6) / o, -1, 1)), Math.asin(J(a / r, -1, 1)) - Math.asin(J(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l;\n        }\n        afterCalculateLabelRotation() {\n            d(this.options.afterCalculateLabelRotation, [\n                this\n            ]);\n        }\n        afterAutoSkip() {}\n        beforeFit() {\n            d(this.options.beforeFit, [\n                this\n            ]);\n        }\n        fit() {\n            const t = {\n                width: 0,\n                height: 0\n            }, { chart: e, options: { ticks: i, title: s, grid: n } } = this, o = this._isVisible(), a = this.isHorizontal();\n            if (o) {\n                const o = Gs(s, e.options.font);\n                if (a ? (t.width = this.maxWidth, t.height = Ks(n) + o) : (t.height = this.maxHeight, t.width = Ks(n) + o), i.display && this.ticks.length) {\n                    const { first: e, last: s, widest: n, highest: o } = this._getLabelSizes(), r = 2 * i.padding, l = $(this.labelRotation), h = Math.cos(l), c = Math.sin(l);\n                    if (a) {\n                        const e = i.mirror ? 0 : c * n.width + h * o.height;\n                        t.height = Math.min(this.maxHeight, t.height + e + r);\n                    } else {\n                        const e = i.mirror ? 0 : h * n.width + c * o.height;\n                        t.width = Math.min(this.maxWidth, t.width + e + r);\n                    }\n                    this._calculatePadding(e, s, c, h);\n                }\n            }\n            this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n        }\n        _calculatePadding(t, e, i, s) {\n            const { ticks: { align: n, padding: o }, position: a } = this.options, r = 0 !== this.labelRotation, l = \"top\" !== a && \"x\" === this.axis;\n            if (this.isHorizontal()) {\n                const a = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);\n                let c = 0, d = 0;\n                r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : \"start\" === n ? d = e.width : \"end\" === n ? c = t.width : \"inner\" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0);\n            } else {\n                let i = e.height / 2, s = t.height / 2;\n                \"start\" === n ? (i = 0, s = t.height) : \"end\" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o;\n            }\n        }\n        _handleMargins() {\n            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n        }\n        afterFit() {\n            d(this.options.afterFit, [\n                this\n            ]);\n        }\n        isHorizontal() {\n            const { axis: t, position: e } = this.options;\n            return \"top\" === e || \"bottom\" === e || \"x\" === t;\n        }\n        isFullSize() {\n            return this.options.fullSize;\n        }\n        _convertTicksToLabels(t) {\n            let e, i;\n            for(this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)s(t[e].label) && (t.splice(e, 1), i--, e--);\n            this.afterTickToLabelConversion();\n        }\n        _getLabelSizes() {\n            let t = this._labelSizes;\n            if (!t) {\n                const e = this.options.ticks.sampleSize;\n                let i = this.ticks;\n                e < i.length && (i = Xs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);\n            }\n            return t;\n        }\n        _computeLabelSizes(t, e, i) {\n            const { ctx: o, _longestTextCache: a } = this, r = [], l = [], h = Math.floor(e / Us(e, i));\n            let c, d, f, g, p, m, b, x, _, y, v, M = 0, w = 0;\n            for(c = 0; c < e; c += h){\n                if (g = t[c].label, p = this._resolveTickFontOptions(c), o.font = m = p.string, b = a[m] = a[m] || {\n                    data: {},\n                    gc: []\n                }, x = p.lineHeight, _ = y = 0, s(g) || n(g)) {\n                    if (n(g)) for(d = 0, f = g.length; d < f; ++d)v = g[d], s(v) || n(v) || (_ = Ce(o, b.data, b.gc, _, v), y += x);\n                } else _ = Ce(o, b.data, b.gc, _, g), y = x;\n                r.push(_), l.push(y), M = Math.max(_, M), w = Math.max(y, w);\n            }\n            !function(t, e) {\n                u(t, (t)=>{\n                    const i = t.gc, s = i.length / 2;\n                    let n;\n                    if (s > e) {\n                        for(n = 0; n < s; ++n)delete t.data[i[n]];\n                        i.splice(0, s);\n                    }\n                });\n            }(a, e);\n            const k = r.indexOf(M), S = l.indexOf(w), P = (t)=>({\n                    width: r[t] || 0,\n                    height: l[t] || 0\n                });\n            return {\n                first: P(0),\n                last: P(e - 1),\n                widest: P(k),\n                highest: P(S),\n                widths: r,\n                heights: l\n            };\n        }\n        getLabelForValue(t) {\n            return t;\n        }\n        getPixelForValue(t, e) {\n            return NaN;\n        }\n        getValueForPixel(t) {}\n        getPixelForTick(t) {\n            const e = this.ticks;\n            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n        }\n        getPixelForDecimal(t) {\n            this._reversePixels && (t = 1 - t);\n            const e = this._startPixel + t * this._length;\n            return Q(this._alignToPixels ? Ae(this.chart, e, 0) : e);\n        }\n        getDecimalForPixel(t) {\n            const e = (t - this._startPixel) / this._length;\n            return this._reversePixels ? 1 - e : e;\n        }\n        getBasePixel() {\n            return this.getPixelForValue(this.getBaseValue());\n        }\n        getBaseValue() {\n            const { min: t, max: e } = this;\n            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n        }\n        getContext(t) {\n            const e = this.ticks || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return i.$context || (i.$context = function(t, e, i) {\n                    return Ci(t, {\n                        tick: i,\n                        index: e,\n                        type: \"tick\"\n                    });\n                }(this.getContext(), t, i));\n            }\n            return this.$context || (this.$context = Ci(this.chart.getContext(), {\n                scale: this,\n                type: \"scale\"\n            }));\n        }\n        _tickSize() {\n            const t = this.options.ticks, e = $(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), n = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = n ? n.widest.width + o : 0, r = n ? n.highest.height + o : 0;\n            return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s;\n        }\n        _isVisible() {\n            const t = this.options.display;\n            return \"auto\" !== t ? !!t : this.getMatchingVisibleMetas().length > 0;\n        }\n        _computeGridLineItems(t) {\n            const e = this.axis, i = this.chart, s = this.options, { grid: n, position: a, border: r } = s, h = n.offset, c = this.isHorizontal(), d = this.ticks.length + (h ? 1 : 0), u = Ks(n), f = [], g = r.setContext(this.getContext()), p = g.display ? g.width : 0, m = p / 2, b = function(t) {\n                return Ae(i, t, p);\n            };\n            let x, _, y, v, M, w, k, S, P, D, C, O;\n            if (\"top\" === a) x = b(this.bottom), w = this.bottom - u, S = x - m, D = b(t.top) + m, O = t.bottom;\n            else if (\"bottom\" === a) x = b(this.top), D = t.top, O = b(t.bottom) - m, w = x + m, S = this.top + u;\n            else if (\"left\" === a) x = b(this.right), M = this.right - u, k = x - m, P = b(t.left) + m, C = t.right;\n            else if (\"right\" === a) x = b(this.left), P = t.left, C = b(t.right) - m, M = x + m, k = this.left + u;\n            else if (\"x\" === e) {\n                if (\"center\" === a) x = b((t.top + t.bottom) / 2 + .5);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    x = b(this.chart.scales[t].getPixelForValue(e));\n                }\n                D = t.top, O = t.bottom, w = x + m, S = w + u;\n            } else if (\"y\" === e) {\n                if (\"center\" === a) x = b((t.left + t.right) / 2);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    x = b(this.chart.scales[t].getPixelForValue(e));\n                }\n                M = x - m, k = M - u, P = t.left, C = t.right;\n            }\n            const A = l(s.ticks.maxTicksLimit, d), T = Math.max(1, Math.ceil(d / A));\n            for(_ = 0; _ < d; _ += T){\n                const t = this.getContext(_), e = n.setContext(t), s = r.setContext(t), o = e.lineWidth, a = e.color, l = s.dash || [], d = s.dashOffset, u = e.tickWidth, g = e.tickColor, p = e.tickBorderDash || [], m = e.tickBorderDashOffset;\n                y = qs(this, _, h), void 0 !== y && (v = Ae(i, y, o), c ? M = k = P = C = v : w = S = D = O = v, f.push({\n                    tx1: M,\n                    ty1: w,\n                    tx2: k,\n                    ty2: S,\n                    x1: P,\n                    y1: D,\n                    x2: C,\n                    y2: O,\n                    width: o,\n                    color: a,\n                    borderDash: l,\n                    borderDashOffset: d,\n                    tickWidth: u,\n                    tickColor: g,\n                    tickBorderDash: p,\n                    tickBorderDashOffset: m\n                }));\n            }\n            return this._ticksLength = d, this._borderValue = x, f;\n        }\n        _computeLabelItems(t) {\n            const e = this.axis, i = this.options, { position: s, ticks: a } = i, r = this.isHorizontal(), l = this.ticks, { align: h, crossAlign: c, padding: d, mirror: u } = a, f = Ks(i.grid), g = f + d, p = u ? -d : g, m = -$(this.labelRotation), b = [];\n            let x, _, y, v, M, w, k, S, P, D, C, O, A = \"middle\";\n            if (\"top\" === s) w = this.bottom - p, k = this._getXAxisLabelAlignment();\n            else if (\"bottom\" === s) w = this.top + p, k = this._getXAxisLabelAlignment();\n            else if (\"left\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"right\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"x\" === e) {\n                if (\"center\" === s) w = (t.top + t.bottom) / 2 + g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    w = this.chart.scales[t].getPixelForValue(e) + g;\n                }\n                k = this._getXAxisLabelAlignment();\n            } else if (\"y\" === e) {\n                if (\"center\" === s) M = (t.left + t.right) / 2 - g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    M = this.chart.scales[t].getPixelForValue(e);\n                }\n                k = this._getYAxisLabelAlignment(f).textAlign;\n            }\n            \"y\" === e && (\"start\" === h ? A = \"top\" : \"end\" === h && (A = \"bottom\"));\n            const T = this._getLabelSizes();\n            for(x = 0, _ = l.length; x < _; ++x){\n                y = l[x], v = y.label;\n                const t = a.setContext(this.getContext(x));\n                S = this.getPixelForTick(x) + a.labelOffset, P = this._resolveTickFontOptions(x), D = P.lineHeight, C = n(v) ? v.length : 1;\n                const e = C / 2, i = t.color, o = t.textStrokeColor, h = t.textStrokeWidth;\n                let d, f = k;\n                if (r ? (M = S, \"inner\" === k && (f = x === _ - 1 ? this.options.reverse ? \"left\" : \"right\" : 0 === x ? this.options.reverse ? \"right\" : \"left\" : \"center\"), O = \"top\" === s ? \"near\" === c || 0 !== m ? -C * D + D / 2 : \"center\" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : \"near\" === c || 0 !== m ? D / 2 : \"center\" === c ? T.highest.height / 2 - e * D : T.highest.height - C * D, u && (O *= -1), 0 === m || t.showLabelBackdrop || (M += D / 2 * Math.sin(m))) : (w = S, O = (1 - C) * D / 2), t.showLabelBackdrop) {\n                    const e = ki(t.backdropPadding), i = T.heights[x], s = T.widths[x];\n                    let n = O - e.top, o = 0 - e.left;\n                    switch(A){\n                        case \"middle\":\n                            n -= i / 2;\n                            break;\n                        case \"bottom\":\n                            n -= i;\n                    }\n                    switch(k){\n                        case \"center\":\n                            o -= s / 2;\n                            break;\n                        case \"right\":\n                            o -= s;\n                    }\n                    d = {\n                        left: o,\n                        top: n,\n                        width: s + e.width,\n                        height: i + e.height,\n                        color: t.backdropColor\n                    };\n                }\n                b.push({\n                    label: v,\n                    font: P,\n                    textOffset: O,\n                    options: {\n                        rotation: m,\n                        color: i,\n                        strokeColor: o,\n                        strokeWidth: h,\n                        textAlign: f,\n                        textBaseline: A,\n                        translation: [\n                            M,\n                            w\n                        ],\n                        backdrop: d\n                    }\n                });\n            }\n            return b;\n        }\n        _getXAxisLabelAlignment() {\n            const { position: t, ticks: e } = this.options;\n            if (-$(this.labelRotation)) return \"top\" === t ? \"left\" : \"right\";\n            let i = \"center\";\n            return \"start\" === e.align ? i = \"left\" : \"end\" === e.align ? i = \"right\" : \"inner\" === e.align && (i = \"inner\"), i;\n        }\n        _getYAxisLabelAlignment(t) {\n            const { position: e, ticks: { crossAlign: i, mirror: s, padding: n } } = this.options, o = t + n, a = this._getLabelSizes().widest.width;\n            let r, l;\n            return \"left\" === e ? s ? (l = this.right + n, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l += a)) : (l = this.right - o, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l = this.left)) : \"right\" === e ? s ? (l = this.left + n, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l -= a)) : (l = this.left + o, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l = this.right)) : r = \"right\", {\n                textAlign: r,\n                x: l\n            };\n        }\n        _computeLabelArea() {\n            if (this.options.ticks.mirror) return;\n            const t = this.chart, e = this.options.position;\n            return \"left\" === e || \"right\" === e ? {\n                top: 0,\n                left: this.left,\n                bottom: t.height,\n                right: this.right\n            } : \"top\" === e || \"bottom\" === e ? {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: t.width\n            } : void 0;\n        }\n        drawBackground() {\n            const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: n, height: o } = this;\n            e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore());\n        }\n        getLineWidthForValue(t) {\n            const e = this.options.grid;\n            if (!this._isVisible() || !e.display) return 0;\n            const i = this.ticks.findIndex((e)=>e.value === t);\n            if (i >= 0) return e.setContext(this.getContext(i)).lineWidth;\n            return 0;\n        }\n        drawGrid(t) {\n            const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n            let n, o;\n            const a = (t, e, s)=>{\n                s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore());\n            };\n            if (e.display) for(n = 0, o = s.length; n < o; ++n){\n                const t = s[n];\n                e.drawOnChartArea && a({\n                    x: t.x1,\n                    y: t.y1\n                }, {\n                    x: t.x2,\n                    y: t.y2\n                }, t), e.drawTicks && a({\n                    x: t.tx1,\n                    y: t.ty1\n                }, {\n                    x: t.tx2,\n                    y: t.ty2\n                }, {\n                    color: t.tickColor,\n                    width: t.tickWidth,\n                    borderDash: t.tickBorderDash,\n                    borderDashOffset: t.tickBorderDashOffset\n                });\n            }\n        }\n        drawBorder() {\n            const { chart: t, ctx: e, options: { border: i, grid: s } } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;\n            if (!o) return;\n            const a = s.setContext(this.getContext(0)).lineWidth, r = this._borderValue;\n            let l, h, c, d;\n            this.isHorizontal() ? (l = Ae(t, this.left, o) - o / 2, h = Ae(t, this.right, a) + a / 2, c = d = r) : (c = Ae(t, this.top, o) - o / 2, d = Ae(t, this.bottom, a) + a / 2, l = h = r), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, d), e.stroke(), e.restore();\n        }\n        drawLabels(t) {\n            if (!this.options.ticks.display) return;\n            const e = this.ctx, i = this._computeLabelArea();\n            i && Ie(e, i);\n            const s = this.getLabelItems(t);\n            for (const t of s){\n                const i = t.options, s = t.font;\n                Ne(e, t.label, 0, t.textOffset, s, i);\n            }\n            i && ze(e);\n        }\n        drawTitle() {\n            const { ctx: t, options: { position: e, title: i, reverse: s } } = this;\n            if (!i.display) return;\n            const a = Si(i.font), r = ki(i.padding), l = i.align;\n            let h = a.lineHeight / 2;\n            \"bottom\" === e || \"center\" === e || o(e) ? (h += r.bottom, n(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;\n            const { titleX: c, titleY: d, maxWidth: u, rotation: f } = function(t, e, i, s) {\n                const { top: n, left: a, bottom: r, right: l, chart: h } = t, { chartArea: c, scales: d } = h;\n                let u, f, g, p = 0;\n                const m = r - n, b = l - a;\n                if (t.isHorizontal()) {\n                    if (f = ft(s, a, l), o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        g = d[t].getPixelForValue(s) + m - e;\n                    } else g = \"center\" === i ? (c.bottom + c.top) / 2 + m - e : Ys(t, i, e);\n                    u = l - a;\n                } else {\n                    if (o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        f = d[t].getPixelForValue(s) - b + e;\n                    } else f = \"center\" === i ? (c.left + c.right) / 2 - b + e : Ys(t, i, e);\n                    g = ft(s, r, n), p = \"left\" === i ? -E : E;\n                }\n                return {\n                    titleX: f,\n                    titleY: g,\n                    maxWidth: u,\n                    rotation: p\n                };\n            }(this, h, e, l);\n            Ne(t, i.text, 0, 0, a, {\n                color: i.color,\n                maxWidth: u,\n                rotation: f,\n                textAlign: Zs(l, e, s),\n                textBaseline: \"middle\",\n                translation: [\n                    c,\n                    d\n                ]\n            });\n        }\n        draw(t) {\n            this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n        }\n        _layers() {\n            const t = this.options, e = t.ticks && t.ticks.z || 0, i = l(t.grid && t.grid.z, -1), s = l(t.border && t.border.z, 0);\n            return this._isVisible() && this.draw === Js.prototype.draw ? [\n                {\n                    z: i,\n                    draw: (t)=>{\n                        this.drawBackground(), this.drawGrid(t), this.drawTitle();\n                    }\n                },\n                {\n                    z: s,\n                    draw: ()=>{\n                        this.drawBorder();\n                    }\n                },\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.drawLabels(t);\n                    }\n                }\n            ] : [\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.draw(t);\n                    }\n                }\n            ];\n        }\n        getMatchingVisibleMetas(t) {\n            const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + \"AxisID\", s = [];\n            let n, o;\n            for(n = 0, o = e.length; n < o; ++n){\n                const o = e[n];\n                o[i] !== this.id || t && o.type !== t || s.push(o);\n            }\n            return s;\n        }\n        _resolveTickFontOptions(t) {\n            return Si(this.options.ticks.setContext(this.getContext(t)).font);\n        }\n        _maxDigits() {\n            const t = this._resolveTickFontOptions(0).lineHeight;\n            return (this.isHorizontal() ? this.width : this.height) / t;\n        }\n    }\n    class Qs {\n        constructor(t, e, i){\n            this.type = t, this.scope = e, this.override = i, this.items = Object.create(null);\n        }\n        isForType(t) {\n            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n        }\n        register(t) {\n            const e = Object.getPrototypeOf(t);\n            let i;\n            (function(t) {\n                return \"id\" in t && \"defaults\" in t;\n            })(e) && (i = this.register(e));\n            const s = this.items, n = t.id, o = this.scope + \".\" + n;\n            if (!n) throw new Error(\"class does not have id: \" + t);\n            return n in s || (s[n] = t, function(t, e, i) {\n                const s = b(Object.create(null), [\n                    i ? ue.get(i) : {},\n                    ue.get(e),\n                    t.defaults\n                ]);\n                ue.set(e, s), t.defaultRoutes && function(t, e) {\n                    Object.keys(e).forEach((i)=>{\n                        const s = i.split(\".\"), n = s.pop(), o = [\n                            t\n                        ].concat(s).join(\".\"), a = e[i].split(\".\"), r = a.pop(), l = a.join(\".\");\n                        ue.route(o, n, l, r);\n                    });\n                }(e, t.defaultRoutes);\n                t.descriptors && ue.describe(e, t.descriptors);\n            }(t, o, i), this.override && ue.override(t.id, t.overrides)), o;\n        }\n        get(t) {\n            return this.items[t];\n        }\n        unregister(t) {\n            const e = this.items, i = t.id, s = this.scope;\n            i in e && delete e[i], s && i in ue[s] && (delete ue[s][i], this.override && delete re[i]);\n        }\n    }\n    class tn {\n        constructor(){\n            this.controllers = new Qs(Ns, \"datasets\", !0), this.elements = new Qs(Hs, \"elements\"), this.plugins = new Qs(Object, \"plugins\"), this.scales = new Qs(Js, \"scales\"), this._typedRegistries = [\n                this.controllers,\n                this.scales,\n                this.elements\n            ];\n        }\n        add(...t) {\n            this._each(\"register\", t);\n        }\n        remove(...t) {\n            this._each(\"unregister\", t);\n        }\n        addControllers(...t) {\n            this._each(\"register\", t, this.controllers);\n        }\n        addElements(...t) {\n            this._each(\"register\", t, this.elements);\n        }\n        addPlugins(...t) {\n            this._each(\"register\", t, this.plugins);\n        }\n        addScales(...t) {\n            this._each(\"register\", t, this.scales);\n        }\n        getController(t) {\n            return this._get(t, this.controllers, \"controller\");\n        }\n        getElement(t) {\n            return this._get(t, this.elements, \"element\");\n        }\n        getPlugin(t) {\n            return this._get(t, this.plugins, \"plugin\");\n        }\n        getScale(t) {\n            return this._get(t, this.scales, \"scale\");\n        }\n        removeControllers(...t) {\n            this._each(\"unregister\", t, this.controllers);\n        }\n        removeElements(...t) {\n            this._each(\"unregister\", t, this.elements);\n        }\n        removePlugins(...t) {\n            this._each(\"unregister\", t, this.plugins);\n        }\n        removeScales(...t) {\n            this._each(\"unregister\", t, this.scales);\n        }\n        _each(t, e, i) {\n            [\n                ...e\n            ].forEach((e)=>{\n                const s = i || this._getRegistryForType(e);\n                i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : u(e, (e)=>{\n                    const s = i || this._getRegistryForType(e);\n                    this._exec(t, s, e);\n                });\n            });\n        }\n        _exec(t, e, i) {\n            const s = w(t);\n            d(i[\"before\" + s], [], i), e[t](i), d(i[\"after\" + s], [], i);\n        }\n        _getRegistryForType(t) {\n            for(let e = 0; e < this._typedRegistries.length; e++){\n                const i = this._typedRegistries[e];\n                if (i.isForType(t)) return i;\n            }\n            return this.plugins;\n        }\n        _get(t, e, i) {\n            const s = e.get(t);\n            if (void 0 === s) throw new Error('\"' + t + '\" is not a registered ' + i + \".\");\n            return s;\n        }\n    }\n    var en = new tn;\n    class sn {\n        constructor(){\n            this._init = [];\n        }\n        notify(t, e, i, s) {\n            \"beforeInit\" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n            const n = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(n, t, e, i);\n            return \"afterDestroy\" === e && (this._notify(n, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), o;\n        }\n        _notify(t, e, i, s) {\n            s = s || {};\n            for (const n of t){\n                const t = n.plugin;\n                if (!1 === d(t[i], [\n                    e,\n                    s,\n                    n.options\n                ], t) && s.cancelable) return !1;\n            }\n            return !0;\n        }\n        invalidate() {\n            s(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n        }\n        _descriptors(t) {\n            if (this._cache) return this._cache;\n            const e = this._cache = this._createDescriptors(t);\n            return this._notifyStateChanges(t), e;\n        }\n        _createDescriptors(t, e) {\n            const i = t && t.config, s = l(i.options && i.options.plugins, {}), n = function(t) {\n                const e = {}, i = [], s = Object.keys(en.plugins.items);\n                for(let t = 0; t < s.length; t++)i.push(en.getPlugin(s[t]));\n                const n = t.plugins || [];\n                for(let t = 0; t < n.length; t++){\n                    const s = n[t];\n                    -1 === i.indexOf(s) && (i.push(s), e[s.id] = !0);\n                }\n                return {\n                    plugins: i,\n                    localIds: e\n                };\n            }(i);\n            return !1 !== s || e ? function(t, { plugins: e, localIds: i }, s, n) {\n                const o = [], a = t.getContext();\n                for (const r of e){\n                    const e = r.id, l = nn(s[e], n);\n                    null !== l && o.push({\n                        plugin: r,\n                        options: on(t.config, {\n                            plugin: r,\n                            local: i[e]\n                        }, l, a)\n                    });\n                }\n                return o;\n            }(t, n, s, e) : [];\n        }\n        _notifyStateChanges(t) {\n            const e = this._oldCache || [], i = this._cache, s = (t, e)=>t.filter((t)=>!e.some((e)=>t.plugin.id === e.plugin.id));\n            this._notify(s(e, i), t, \"stop\"), this._notify(s(i, e), t, \"start\");\n        }\n    }\n    function nn(t, e) {\n        return e || !1 !== t ? !0 === t ? {} : t : null;\n    }\n    function on(t, { plugin: e, local: i }, s, n) {\n        const o = t.pluginScopeKeys(e), a = t.getOptionScopes(s, o);\n        return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [\n            \"\"\n        ], {\n            scriptable: !1,\n            indexable: !1,\n            allKeys: !0\n        });\n    }\n    function an(t, e) {\n        const i = ue.datasets[t] || {};\n        return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || \"x\";\n    }\n    function rn(t) {\n        if (\"x\" === t || \"y\" === t || \"r\" === t) return t;\n    }\n    function ln(t, ...e) {\n        if (rn(t)) return t;\n        for (const s of e){\n            const e = s.axis || (\"top\" === (i = s.position) || \"bottom\" === i ? \"x\" : \"left\" === i || \"right\" === i ? \"y\" : void 0) || t.length > 1 && rn(t[0].toLowerCase());\n            if (e) return e;\n        }\n        var i;\n        throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);\n    }\n    function hn(t, e, i) {\n        if (i[e + \"AxisID\"] === t) return {\n            axis: e\n        };\n    }\n    function cn(t, e) {\n        const i = re[t.type] || {\n            scales: {}\n        }, s = e.scales || {}, n = an(t.type, e), a = Object.create(null);\n        return Object.keys(s).forEach((e)=>{\n            const r = s[e];\n            if (!o(r)) return console.error(`Invalid scale configuration for scale: ${e}`);\n            if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`);\n            const l = ln(e, r, function(t, e) {\n                if (e.data && e.data.datasets) {\n                    const i = e.data.datasets.filter((e)=>e.xAxisID === t || e.yAxisID === t);\n                    if (i.length) return hn(t, \"x\", i[0]) || hn(t, \"y\", i[0]);\n                }\n                return {};\n            }(e, t), ue.scales[r.type]), h = function(t, e) {\n                return t === e ? \"_index_\" : \"_value_\";\n            }(l, n), c = i.scales || {};\n            a[e] = x(Object.create(null), [\n                {\n                    axis: l\n                },\n                r,\n                c[l],\n                c[h]\n            ]);\n        }), t.data.datasets.forEach((i)=>{\n            const n = i.type || t.type, o = i.indexAxis || an(n, e), r = (re[n] || {}).scales || {};\n            Object.keys(r).forEach((t)=>{\n                const e = function(t, e) {\n                    let i = t;\n                    return \"_index_\" === t ? i = e : \"_value_\" === t && (i = \"x\" === e ? \"y\" : \"x\"), i;\n                }(t, o), n = i[e + \"AxisID\"] || e;\n                a[n] = a[n] || Object.create(null), x(a[n], [\n                    {\n                        axis: e\n                    },\n                    s[n],\n                    r[t]\n                ]);\n            });\n        }), Object.keys(a).forEach((t)=>{\n            const e = a[t];\n            x(e, [\n                ue.scales[e.type],\n                ue.scale\n            ]);\n        }), a;\n    }\n    function dn(t) {\n        const e = t.options || (t.options = {});\n        e.plugins = l(e.plugins, {}), e.scales = cn(t, e);\n    }\n    function un(t) {\n        return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t;\n    }\n    const fn = new Map, gn = new Set;\n    function pn(t, e) {\n        let i = fn.get(t);\n        return i || (i = e(), fn.set(t, i), gn.add(i)), i;\n    }\n    const mn = (t, e, i)=>{\n        const s = M(e, i);\n        void 0 !== s && t.add(s);\n    };\n    class bn {\n        constructor(t){\n            this._config = function(t) {\n                return (t = t || {}).data = un(t.data), dn(t), t;\n            }(t), this._scopeCache = new Map, this._resolverCache = new Map;\n        }\n        get platform() {\n            return this._config.platform;\n        }\n        get type() {\n            return this._config.type;\n        }\n        set type(t) {\n            this._config.type = t;\n        }\n        get data() {\n            return this._config.data;\n        }\n        set data(t) {\n            this._config.data = un(t);\n        }\n        get options() {\n            return this._config.options;\n        }\n        set options(t) {\n            this._config.options = t;\n        }\n        get plugins() {\n            return this._config.plugins;\n        }\n        update() {\n            const t = this._config;\n            this.clearCache(), dn(t);\n        }\n        clearCache() {\n            this._scopeCache.clear(), this._resolverCache.clear();\n        }\n        datasetScopeKeys(t) {\n            return pn(t, ()=>[\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetAnimationScopeKeys(t, e) {\n            return pn(`${t}.transition.${e}`, ()=>[\n                    [\n                        `datasets.${t}.transitions.${e}`,\n                        `transitions.${e}`\n                    ],\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetElementScopeKeys(t, e) {\n            return pn(`${t}-${e}`, ()=>[\n                    [\n                        `datasets.${t}.elements.${e}`,\n                        `datasets.${t}`,\n                        `elements.${e}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        pluginScopeKeys(t) {\n            const e = t.id;\n            return pn(`${this.type}-plugin-${e}`, ()=>[\n                    [\n                        `plugins.${e}`,\n                        ...t.additionalOptionScopes || []\n                    ]\n                ]);\n        }\n        _cachedScopes(t, e) {\n            const i = this._scopeCache;\n            let s = i.get(t);\n            return s && !e || (s = new Map, i.set(t, s)), s;\n        }\n        getOptionScopes(t, e, i) {\n            const { options: s, type: n } = this, o = this._cachedScopes(t, i), a = o.get(e);\n            if (a) return a;\n            const r = new Set;\n            e.forEach((e)=>{\n                t && (r.add(t), e.forEach((e)=>mn(r, t, e))), e.forEach((t)=>mn(r, s, t)), e.forEach((t)=>mn(r, re[n] || {}, t)), e.forEach((t)=>mn(r, ue, t)), e.forEach((t)=>mn(r, le, t));\n            });\n            const l = Array.from(r);\n            return 0 === l.length && l.push(Object.create(null)), gn.has(e) && o.set(e, l), l;\n        }\n        chartOptionScopes() {\n            const { options: t, type: e } = this;\n            return [\n                t,\n                re[e] || {},\n                ue.datasets[e] || {},\n                {\n                    type: e\n                },\n                ue,\n                le\n            ];\n        }\n        resolveNamedOptions(t, e, i, s = [\n            \"\"\n        ]) {\n            const o = {\n                $shared: !0\n            }, { resolver: a, subPrefixes: r } = xn(this._resolverCache, t, s);\n            let l = a;\n            if (function(t, e) {\n                const { isScriptable: i, isIndexable: s } = Ye(t);\n                for (const o of e){\n                    const e = i(o), a = s(o), r = (a || e) && t[o];\n                    if (e && (S(r) || _n(r)) || a && n(r)) return !0;\n                }\n                return !1;\n            }(a, e)) {\n                o.$shared = !1;\n                l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r));\n            }\n            for (const t of e)o[t] = l[t];\n            return o;\n        }\n        createResolver(t, e, i = [\n            \"\"\n        ], s) {\n            const { resolver: n } = xn(this._resolverCache, t, i);\n            return o(e) ? $e(n, e, void 0, s) : n;\n        }\n    }\n    function xn(t, e, i) {\n        let s = t.get(e);\n        s || (s = new Map, t.set(e, s));\n        const n = i.join();\n        let o = s.get(n);\n        if (!o) o = {\n            resolver: je(e, i),\n            subPrefixes: i.filter((t)=>!t.toLowerCase().includes(\"hover\"))\n        }, s.set(n, o);\n        return o;\n    }\n    const _n = (t)=>o(t) && Object.getOwnPropertyNames(t).reduce((e, i)=>e || S(t[i]), !1);\n    const yn = [\n        \"top\",\n        \"bottom\",\n        \"left\",\n        \"right\",\n        \"chartArea\"\n    ];\n    function vn(t, e) {\n        return \"top\" === t || \"bottom\" === t || -1 === yn.indexOf(t) && \"x\" === e;\n    }\n    function Mn(t, e) {\n        return function(i, s) {\n            return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t];\n        };\n    }\n    function wn(t) {\n        const e = t.chart, i = e.options.animation;\n        e.notifyPlugins(\"afterRender\"), d(i && i.onComplete, [\n            t\n        ], e);\n    }\n    function kn(t) {\n        const e = t.chart, i = e.options.animation;\n        d(i && i.onProgress, [\n            t\n        ], e);\n    }\n    function Sn(t) {\n        return fe() && \"string\" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;\n    }\n    const Pn = {}, Dn = (t)=>{\n        const e = Sn(t);\n        return Object.values(Pn).filter((t)=>t.canvas === e).pop();\n    };\n    function Cn(t, e, i) {\n        const s = Object.keys(t);\n        for (const n of s){\n            const s = +n;\n            if (s >= e) {\n                const o = t[n];\n                delete t[n], (i > 0 || s > e) && (t[s + i] = o);\n            }\n        }\n    }\n    class On {\n        static defaults = ue;\n        static instances = Pn;\n        static overrides = re;\n        static registry = en;\n        static version = \"4.3.3\";\n        static getChart = Dn;\n        static register(...t) {\n            en.add(...t), An();\n        }\n        static unregister(...t) {\n            en.remove(...t), An();\n        }\n        constructor(t, e){\n            const s = this.config = new bn(e), n = Sn(t), o = Dn(n);\n            if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n            const a = s.createResolver(s.chartOptionScopes(), this.getContext());\n            this.platform = new (s.platform || ks(n)), this.platform.updateConfig(s);\n            const r = this.platform.acquireContext(n, a.aspectRatio), l = r && r.canvas, h = l && l.height, c = l && l.width;\n            this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t)=>this.update(t), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r && l ? (xt.listen(this, \"complete\", wn), xt.listen(this, \"progress\", kn), this._initialize(), this.attached && this.update()) : console.error(\"Failed to create chart: can't acquire context from the given item\");\n        }\n        get aspectRatio() {\n            const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: o } = this;\n            return s(t) ? e && o ? o : n ? i / n : null : t;\n        }\n        get data() {\n            return this.config.data;\n        }\n        set data(t) {\n            this.config.data = t;\n        }\n        get options() {\n            return this._options;\n        }\n        set options(t) {\n            this.config.options = t;\n        }\n        get registry() {\n            return en;\n        }\n        _initialize() {\n            return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n        }\n        clear() {\n            return Te(this.canvas, this.ctx), this;\n        }\n        stop() {\n            return xt.stop(this), this;\n        }\n        resize(t, e) {\n            xt.running(this) ? this._resizeBeforeDraw = {\n                width: t,\n                height: e\n            } : this._resize(t, e);\n        }\n        _resize(t, e) {\n            const i = this.options, s = this.canvas, n = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, t, e, n), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), r = this.width ? \"resize\" : \"attach\";\n            this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ke(this, a, !0) && (this.notifyPlugins(\"resize\", {\n                size: o\n            }), d(i.onResize, [\n                this,\n                o\n            ], this), this.attached && this._doResize(r) && this.render());\n        }\n        ensureScalesHaveIDs() {\n            u(this.options.scales || {}, (t, e)=>{\n                t.id = e;\n            });\n        }\n        buildOrUpdateScales() {\n            const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((t, e)=>(t[e] = !1, t), {});\n            let n = [];\n            e && (n = n.concat(Object.keys(e).map((t)=>{\n                const i = e[t], s = ln(t, i), n = \"r\" === s, o = \"x\" === s;\n                return {\n                    options: i,\n                    dposition: n ? \"chartArea\" : o ? \"bottom\" : \"left\",\n                    dtype: n ? \"radialLinear\" : o ? \"category\" : \"linear\"\n                };\n            }))), u(n, (e)=>{\n                const n = e.options, o = n.id, a = ln(o, n), r = l(n.type, e.dtype);\n                void 0 !== n.position && vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0;\n                let h = null;\n                if (o in i && i[o].type === r) h = i[o];\n                else h = new (en.getScale(r))({\n                    id: o,\n                    type: r,\n                    ctx: this.ctx,\n                    chart: this\n                }), i[h.id] = h;\n                h.init(n, t);\n            }), u(s, (t, e)=>{\n                t || delete i[e];\n            }), u(i, (t)=>{\n                as.configure(this, t, t.options), as.addBox(this, t);\n            });\n        }\n        _updateMetasets() {\n            const t = this._metasets, e = this.data.datasets.length, i = t.length;\n            if (t.sort((t, e)=>t.index - e.index), i > e) {\n                for(let t = e; t < i; ++t)this._destroyDatasetMeta(t);\n                t.splice(e, i - e);\n            }\n            this._sortedMetasets = t.slice(0).sort(Mn(\"order\", \"index\"));\n        }\n        _removeUnreferencedMetasets() {\n            const { _metasets: t, data: { datasets: e } } = this;\n            t.length > e.length && delete this._stacks, t.forEach((t, i)=>{\n                0 === e.filter((e)=>e === t._dataset).length && this._destroyDatasetMeta(i);\n            });\n        }\n        buildOrUpdateControllers() {\n            const t = [], e = this.data.datasets;\n            let i, s;\n            for(this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++){\n                const s = e[i];\n                let n = this.getDatasetMeta(i);\n                const o = s.type || this.config.type;\n                if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = \"\" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();\n                else {\n                    const e = en.getController(o), { datasetElementType: s, dataElementType: a } = ue.datasets[o];\n                    Object.assign(e, {\n                        dataElementType: en.getElement(a),\n                        datasetElementType: s && en.getElement(s)\n                    }), n.controller = new e(this, i), t.push(n.controller);\n                }\n            }\n            return this._updateMetasets(), t;\n        }\n        _resetElements() {\n            u(this.data.datasets, (t, e)=>{\n                this.getDatasetMeta(e).controller.reset();\n            }, this);\n        }\n        reset() {\n            this._resetElements(), this.notifyPlugins(\"reset\");\n        }\n        update(t) {\n            const e = this.config;\n            e.update();\n            const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;\n            if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins(\"beforeUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) return;\n            const n = this.buildOrUpdateControllers();\n            this.notifyPlugins(\"beforeElementsUpdate\");\n            let o = 0;\n            for(let t = 0, e = this.data.datasets.length; t < e; t++){\n                const { controller: e } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);\n                e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o);\n            }\n            o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t)=>{\n                t.reset();\n            }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n                mode: t\n            }), this._layers.sort(Mn(\"z\", \"_idx\"));\n            const { _active: a, _lastEvent: r } = this;\n            r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n        }\n        _updateScales() {\n            u(this.scales, (t)=>{\n                as.removeBox(this, t);\n            }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n        }\n        _checkEventBindings() {\n            const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events);\n            P(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents());\n        }\n        _updateHiddenIndices() {\n            const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];\n            for (const { method: i, start: s, count: n } of e)Cn(t, s, \"_removeElements\" === i ? -n : n);\n        }\n        _getUniformDataChanges() {\n            const t = this._dataChanges;\n            if (!t || !t.length) return;\n            this._dataChanges = [];\n            const e = this.data.datasets.length, i = (e)=>new Set(t.filter((t)=>t[0] === e).map((t, e)=>e + \",\" + t.splice(1).join(\",\"))), s = i(0);\n            for(let t = 1; t < e; t++)if (!P(s, i(t))) return;\n            return Array.from(s).map((t)=>t.split(\",\")).map((t)=>({\n                    method: t[1],\n                    start: +t[2],\n                    count: +t[3]\n                }));\n        }\n        _updateLayout(t) {\n            if (!1 === this.notifyPlugins(\"beforeLayout\", {\n                cancelable: !0\n            })) return;\n            as.update(this, this.width, this.height, t);\n            const e = this.chartArea, i = e.width <= 0 || e.height <= 0;\n            this._layers = [], u(this.boxes, (t)=>{\n                i && \"chartArea\" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()));\n            }, this), this._layers.forEach((t, e)=>{\n                t._idx = e;\n            }), this.notifyPlugins(\"afterLayout\");\n        }\n        _updateDatasets(t) {\n            if (!1 !== this.notifyPlugins(\"beforeDatasetsUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) {\n                for(let t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.configure();\n                for(let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, S(t) ? t({\n                    datasetIndex: e\n                }) : t);\n                this.notifyPlugins(\"afterDatasetsUpdate\", {\n                    mode: t\n                });\n            }\n        }\n        _updateDataset(t, e) {\n            const i = this.getDatasetMeta(t), s = {\n                meta: i,\n                index: t,\n                mode: e,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetUpdate\", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", s));\n        }\n        render() {\n            !1 !== this.notifyPlugins(\"beforeRender\", {\n                cancelable: !0\n            }) && (xt.has(this) ? this.attached && !xt.running(this) && xt.start(this) : (this.draw(), wn({\n                chart: this\n            })));\n        }\n        draw() {\n            let t;\n            if (this._resizeBeforeDraw) {\n                const { width: t, height: e } = this._resizeBeforeDraw;\n                this._resize(t, e), this._resizeBeforeDraw = null;\n            }\n            if (this.clear(), this.width <= 0 || this.height <= 0) return;\n            if (!1 === this.notifyPlugins(\"beforeDraw\", {\n                cancelable: !0\n            })) return;\n            const e = this._layers;\n            for(t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea);\n            for(this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea);\n            this.notifyPlugins(\"afterDraw\");\n        }\n        _getSortedDatasetMetas(t) {\n            const e = this._sortedMetasets, i = [];\n            let s, n;\n            for(s = 0, n = e.length; s < n; ++s){\n                const n = e[s];\n                t && !n.visible || i.push(n);\n            }\n            return i;\n        }\n        getSortedVisibleDatasetMetas() {\n            return this._getSortedDatasetMetas(!0);\n        }\n        _drawDatasets() {\n            if (!1 === this.notifyPlugins(\"beforeDatasetsDraw\", {\n                cancelable: !0\n            })) return;\n            const t = this.getSortedVisibleDatasetMetas();\n            for(let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]);\n            this.notifyPlugins(\"afterDatasetsDraw\");\n        }\n        _drawDataset(t) {\n            const e = this.ctx, i = t._clip, s = !i.disabled, n = function(t) {\n                const { xScale: e, yScale: i } = t;\n                if (e && i) return {\n                    left: e.left,\n                    right: e.right,\n                    top: i.top,\n                    bottom: i.bottom\n                };\n            }(t) || this.chartArea, o = {\n                meta: t,\n                index: t.index,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetDraw\", o) && (s && Ie(e, {\n                left: !1 === i.left ? 0 : n.left - i.left,\n                right: !1 === i.right ? this.width : n.right + i.right,\n                top: !1 === i.top ? 0 : n.top - i.top,\n                bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom\n            }), t.controller.draw(), s && ze(e), o.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", o));\n        }\n        isPointInArea(t) {\n            return Re(t, this.chartArea, this._minPadding);\n        }\n        getElementsAtEventForMode(t, e, i, s) {\n            const n = Xi.modes[e];\n            return \"function\" == typeof n ? n(this, t, i, s) : [];\n        }\n        getDatasetMeta(t) {\n            const e = this.data.datasets[t], i = this._metasets;\n            let s = i.filter((t)=>t && t._dataset === e).pop();\n            return s || (s = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: e && e.order || 0,\n                index: t,\n                _dataset: e,\n                _parsed: [],\n                _sorted: !1\n            }, i.push(s)), s;\n        }\n        getContext() {\n            return this.$context || (this.$context = Ci(null, {\n                chart: this,\n                type: \"chart\"\n            }));\n        }\n        getVisibleDatasetCount() {\n            return this.getSortedVisibleDatasetMetas().length;\n        }\n        isDatasetVisible(t) {\n            const e = this.data.datasets[t];\n            if (!e) return !1;\n            const i = this.getDatasetMeta(t);\n            return \"boolean\" == typeof i.hidden ? !i.hidden : !e.hidden;\n        }\n        setDatasetVisibility(t, e) {\n            this.getDatasetMeta(t).hidden = !e;\n        }\n        toggleDataVisibility(t) {\n            this._hiddenIndices[t] = !this._hiddenIndices[t];\n        }\n        getDataVisibility(t) {\n            return !this._hiddenIndices[t];\n        }\n        _updateVisibility(t, e, i) {\n            const s = i ? \"show\" : \"hide\", n = this.getDatasetMeta(t), o = n.controller._resolveAnimations(void 0, s);\n            k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {\n                visible: i\n            }), this.update((e)=>e.datasetIndex === t ? s : void 0));\n        }\n        hide(t, e) {\n            this._updateVisibility(t, e, !1);\n        }\n        show(t, e) {\n            this._updateVisibility(t, e, !0);\n        }\n        _destroyDatasetMeta(t) {\n            const e = this._metasets[t];\n            e && e.controller && e.controller._destroy(), delete this._metasets[t];\n        }\n        _stop() {\n            let t, e;\n            for(this.stop(), xt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t);\n        }\n        destroy() {\n            this.notifyPlugins(\"beforeDestroy\");\n            const { canvas: t, ctx: e } = this;\n            this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins(\"afterDestroy\");\n        }\n        toBase64Image(...t) {\n            return this.canvas.toDataURL(...t);\n        }\n        bindEvents() {\n            this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n        }\n        bindUserEvents() {\n            const t = this._listeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (t, e, i)=>{\n                t.offsetX = e, t.offsetY = i, this._eventHandler(t);\n            };\n            u(this.options.events, (t)=>i(t, s));\n        }\n        bindResponsiveEvents() {\n            this._responsiveListeners || (this._responsiveListeners = {});\n            const t = this._responsiveListeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (i, s)=>{\n                t[i] && (e.removeEventListener(this, i, s), delete t[i]);\n            }, n = (t, e)=>{\n                this.canvas && this.resize(t, e);\n            };\n            let o;\n            const a = ()=>{\n                s(\"attach\", a), this.attached = !0, this.resize(), i(\"resize\", n), i(\"detach\", o);\n            };\n            o = ()=>{\n                this.attached = !1, s(\"resize\", n), this._stop(), this._resize(0, 0), i(\"attach\", a);\n            }, e.isAttached(this.canvas) ? a() : o();\n        }\n        unbindEvents() {\n            u(this._listeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._listeners = {}, u(this._responsiveListeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._responsiveListeners = void 0;\n        }\n        updateHoverStyle(t, e, i) {\n            const s = i ? \"set\" : \"remove\";\n            let n, o, a, r;\n            for(\"dataset\" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller[\"_\" + s + \"DatasetHoverStyle\"]()), a = 0, r = t.length; a < r; ++a){\n                o = t[a];\n                const e = o && this.getDatasetMeta(o.datasetIndex).controller;\n                e && e[s + \"HoverStyle\"](o.element, o.datasetIndex, o.index);\n            }\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t) {\n            const e = this._active || [], i = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.getDatasetMeta(t);\n                if (!i) throw new Error(\"No dataset found at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            });\n            !f(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));\n        }\n        notifyPlugins(t, e, i) {\n            return this._plugins.notify(this, t, e, i);\n        }\n        isPluginEnabled(t) {\n            return 1 === this._plugins._cache.filter((e)=>e.plugin.id === t).length;\n        }\n        _updateHoverStyles(t, e, i) {\n            const s = this.options.hover, n = (t, e)=>t.filter((t)=>!e.some((e)=>t.datasetIndex === e.datasetIndex && t.index === e.index)), o = n(e, t), a = i ? t : n(t, e);\n            o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);\n        }\n        _eventHandler(t, e) {\n            const i = {\n                event: t,\n                replay: e,\n                cancelable: !0,\n                inChartArea: this.isPointInArea(t)\n            }, s = (e)=>(e.options.events || this.options.events).includes(t.native.type);\n            if (!1 === this.notifyPlugins(\"beforeEvent\", i, s)) return;\n            const n = this._handleEvent(t, e, i.inChartArea);\n            return i.cancelable = !1, this.notifyPlugins(\"afterEvent\", i, s), (n || i.changed) && this.render(), this;\n        }\n        _handleEvent(t, e, i) {\n            const { _active: s = [], options: n } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function(t, e, i, s) {\n                return i && \"mouseout\" !== t.type ? s ? e : t : null;\n            }(t, this._lastEvent, i, r);\n            i && (this._lastEvent = null, d(n.onHover, [\n                t,\n                a,\n                this\n            ], this), r && d(n.onClick, [\n                t,\n                a,\n                this\n            ], this));\n            const h = !f(a, s);\n            return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h;\n        }\n        _getActiveElements(t, e, i, s) {\n            if (\"mouseout\" === t.type) return [];\n            if (!i) return e;\n            const n = this.options.hover;\n            return this.getElementsAtEventForMode(t, n.mode, n, s);\n        }\n    }\n    function An() {\n        return u(On.instances, (t)=>t._plugins.invalidate());\n    }\n    function Tn() {\n        throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n    }\n    class Ln {\n        static override(t) {\n            Object.assign(Ln.prototype, t);\n        }\n        options;\n        constructor(t){\n            this.options = t || {};\n        }\n        init() {}\n        formats() {\n            return Tn();\n        }\n        parse() {\n            return Tn();\n        }\n        format() {\n            return Tn();\n        }\n        add() {\n            return Tn();\n        }\n        diff() {\n            return Tn();\n        }\n        startOf() {\n            return Tn();\n        }\n        endOf() {\n            return Tn();\n        }\n    }\n    var En = {\n        _date: Ln\n    };\n    function Rn(t) {\n        const e = t.iScale, i = function(t, e) {\n            if (!t._cache.$bar) {\n                const i = t.getMatchingVisibleMetas(e);\n                let s = [];\n                for(let e = 0, n = i.length; e < n; e++)s = s.concat(i[e].controller.getAllParsedValues(t));\n                t._cache.$bar = lt(s.sort((t, e)=>t - e));\n            }\n            return t._cache.$bar;\n        }(e, t.type);\n        let s, n, o, a, r = e._length;\n        const l = ()=>{\n            32767 !== o && -32768 !== o && (k(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o);\n        };\n        for(s = 0, n = i.length; s < n; ++s)o = e.getPixelForValue(i[s]), l();\n        for(a = void 0, s = 0, n = e.ticks.length; s < n; ++s)o = e.getPixelForTick(s), l();\n        return r;\n    }\n    function In(t, e, i, s) {\n        return n(t) ? function(t, e, i, s) {\n            const n = i.parse(t[0], s), o = i.parse(t[1], s), a = Math.min(n, o), r = Math.max(n, o);\n            let l = a, h = r;\n            Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {\n                barStart: l,\n                barEnd: h,\n                start: n,\n                end: o,\n                min: a,\n                max: r\n            };\n        }(t, e, i, s) : e[i.axis] = i.parse(t, s), e;\n    }\n    function zn(t, e, i, s) {\n        const n = t.iScale, o = t.vScale, a = n.getLabels(), r = n === o, l = [];\n        let h, c, d, u;\n        for(h = i, c = i + s; h < c; ++h)u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(In(u, d, o, h));\n        return l;\n    }\n    function Fn(t) {\n        return t && void 0 !== t.barStart && void 0 !== t.barEnd;\n    }\n    function Vn(t, e, i, s) {\n        let n = e.borderSkipped;\n        const o = {};\n        if (!n) return void (t.borderSkipped = o);\n        if (!0 === n) return void (t.borderSkipped = {\n            top: !0,\n            right: !0,\n            bottom: !0,\n            left: !0\n        });\n        const { start: a, end: r, reverse: l, top: h, bottom: c } = function(t) {\n            let e, i, s, n, o;\n            return t.horizontal ? (e = t.base > t.x, i = \"left\", s = \"right\") : (e = t.base < t.y, i = \"bottom\", s = \"top\"), e ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n                start: i,\n                end: s,\n                reverse: e,\n                top: n,\n                bottom: o\n            };\n        }(t);\n        \"middle\" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Bn(c, a, r, l)] = !0, n = h)), o[Bn(n, a, r, l)] = !0, t.borderSkipped = o;\n    }\n    function Bn(t, e, i, s) {\n        var n, o, a;\n        return s ? (a = i, t = Wn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Wn(t, e, i), t;\n    }\n    function Wn(t, e, i) {\n        return \"start\" === t ? e : \"end\" === t ? i : t;\n    }\n    function Nn(t, { inflateAmount: e }, i) {\n        t.inflateAmount = \"auto\" === e ? 1 === i ? .33 : 0 : e;\n    }\n    class Hn extends Ns {\n        static id = \"doughnut\";\n        static defaults = {\n            datasetElementType: !1,\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !1\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"circumference\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\",\n                        \"startAngle\",\n                        \"x\",\n                        \"y\",\n                        \"offset\",\n                        \"borderWidth\",\n                        \"spacing\"\n                    ]\n                }\n            },\n            cutout: \"50%\",\n            rotation: 0,\n            circumference: 360,\n            radius: \"100%\",\n            spacing: 0,\n            indexAxis: \"r\"\n        };\n        static descriptors = {\n            _scriptable: (t)=>\"spacing\" !== t,\n            _indexable: (t)=>\"spacing\" !== t && !t.startsWith(\"borderDash\") && !t.startsWith(\"hoverBorderDash\")\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n        }\n        linkScales() {}\n        parse(t, e) {\n            const i = this.getDataset().data, s = this._cachedMeta;\n            if (!1 === this._parsing) s._parsed = i;\n            else {\n                let n, a, r = (t)=>+i[t];\n                if (o(i[t])) {\n                    const { key: t = \"value\" } = this._parsing;\n                    r = (e)=>+M(i[e], t);\n                }\n                for(n = t, a = t + e; n < a; ++n)s._parsed[n] = r(n);\n            }\n        }\n        _getRotation() {\n            return $(this.options.rotation - 90);\n        }\n        _getCircumference() {\n            return $(this.options.circumference);\n        }\n        _getRotationExtents() {\n            let t = O, e = -O;\n            for(let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const s = this.chart.getDatasetMeta(i).controller, n = s._getRotation(), o = s._getCircumference();\n                t = Math.min(t, n), e = Math.max(e, n + o);\n            }\n            return {\n                rotation: t,\n                circumference: e - t\n            };\n        }\n        update(t) {\n            const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, n = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), r = Math.min(h(this.options.cutout, a), 1), l = this._getRingWeight(this.index), { circumference: d, rotation: u } = this._getRotationExtents(), { ratioX: f, ratioY: g, offsetX: p, offsetY: m } = function(t, e, i) {\n                let s = 1, n = 1, o = 0, a = 0;\n                if (e < O) {\n                    const r = t, l = r + e, h = Math.cos(r), c = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (t, e, s)=>Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i), g = (t, e, s)=>Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i), p = f(0, h, d), m = f(E, c, u), b = g(C, h, d), x = g(C + E, c, u);\n                    s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, a = -(m + x) / 2;\n                }\n                return {\n                    ratioX: s,\n                    ratioY: n,\n                    offsetX: o,\n                    offsetY: a\n                };\n            }(u, d, r), b = (i.width - o) / f, x = (i.height - o) / g, _ = Math.max(Math.min(b, x) / 2, 0), y = c(this.options.radius, _), v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();\n            this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t);\n        }\n        _circumference(t, e) {\n            const i = this.options, s = this._cachedMeta, n = this._getCircumference();\n            return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O);\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.chartArea, r = o.options.animation, l = (a.left + a.right) / 2, h = (a.top + a.bottom) / 2, c = n && r.animateScale, d = c ? 0 : this.innerRadius, u = c ? 0 : this.outerRadius, { sharedOptions: f, includeOptions: g } = this._getSharedOptions(e, s);\n            let p, m = this._getRotation();\n            for(p = 0; p < e; ++p)m += this._circumference(p, n);\n            for(p = e; p < e + i; ++p){\n                const e = this._circumference(p, n), i = t[p], o = {\n                    x: l + this.offsetX,\n                    y: h + this.offsetY,\n                    startAngle: m,\n                    endAngle: m + e,\n                    circumference: e,\n                    outerRadius: u,\n                    innerRadius: d\n                };\n                g && (o.options = f || this.resolveDataElementOptions(p, i.active ? \"active\" : s)), m += e, this.updateElement(i, p, o, s);\n            }\n        }\n        calculateTotal() {\n            const t = this._cachedMeta, e = t.data;\n            let i, s = 0;\n            for(i = 0; i < e.length; i++){\n                const n = t._parsed[i];\n                null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n));\n            }\n            return s;\n        }\n        calculateCircumference(t) {\n            const e = this._cachedMeta.total;\n            return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t], i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        getMaxBorderWidth(t) {\n            let e = 0;\n            const i = this.chart;\n            let s, n, o, a, r;\n            if (!t) {\n                for(s = 0, n = i.data.datasets.length; s < n; ++s)if (i.isDatasetVisible(s)) {\n                    o = i.getDatasetMeta(s), t = o.data, a = o.controller;\n                    break;\n                }\n            }\n            if (!t) return 0;\n            for(s = 0, n = t.length; s < n; ++s)r = a.resolveDataElementOptions(s), \"inner\" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));\n            return e;\n        }\n        getMaxOffset(t) {\n            let e = 0;\n            for(let i = 0, s = t.length; i < s; ++i){\n                const t = this.resolveDataElementOptions(i);\n                e = Math.max(e, t.offset || 0, t.hoverOffset || 0);\n            }\n            return e;\n        }\n        _getRingWeightOffset(t) {\n            let e = 0;\n            for(let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));\n            return e;\n        }\n        _getRingWeight(t) {\n            return Math.max(l(this.chart.data.datasets[t].weight, 1), 0);\n        }\n        _getVisibleDatasetWeightTotal() {\n            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n        }\n    }\n    class jn extends Ns {\n        static id = \"polarArea\";\n        static defaults = {\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !0\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"startAngle\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\"\n                    ]\n                }\n            },\n            indexAxis: \"r\",\n            startAngle: 0\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            },\n            scales: {\n                r: {\n                    type: \"radialLinear\",\n                    angleLines: {\n                        display: !1\n                    },\n                    beginAtZero: !0,\n                    grid: {\n                        circular: !0\n                    },\n                    pointLabels: {\n                        display: !1\n                    },\n                    startAngle: 0\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t].r, i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        parseObjectData(t, e, i, s) {\n            return ii.bind(this)(t, e, i, s);\n        }\n        update(t) {\n            const e = this._cachedMeta.data;\n            this._updateRadius(), this.updateElements(e, 0, e.length, t);\n        }\n        getMinMax() {\n            const t = this._cachedMeta, e = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            };\n            return t.data.forEach((t, i)=>{\n                const s = this.getParsed(i).r;\n                !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s));\n            }), e;\n        }\n        _updateRadius() {\n            const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), n = Math.max(s / 2, 0), o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();\n            this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o;\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.options.animation, r = this._cachedMeta.rScale, l = r.xCenter, h = r.yCenter, c = r.getIndexAngle(0) - .5 * C;\n            let d, u = c;\n            const f = 360 / this.countVisibleElements();\n            for(d = 0; d < e; ++d)u += this._computeAngle(d, s, f);\n            for(d = e; d < e + i; d++){\n                const e = t[d];\n                let i = u, g = u + this._computeAngle(d, s, f), p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;\n                u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));\n                const m = {\n                    x: l,\n                    y: h,\n                    innerRadius: 0,\n                    outerRadius: p,\n                    startAngle: i,\n                    endAngle: g,\n                    options: this.resolveDataElementOptions(d, e.active ? \"active\" : s)\n                };\n                this.updateElement(e, d, m, s);\n            }\n        }\n        countVisibleElements() {\n            const t = this._cachedMeta;\n            let e = 0;\n            return t.data.forEach((t, i)=>{\n                !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++;\n            }), e;\n        }\n        _computeAngle(t, e, i) {\n            return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0;\n        }\n    }\n    var $n = Object.freeze({\n        __proto__: null,\n        BarController: class extends Ns {\n            static id = \"bar\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"bar\",\n                categoryPercentage: .8,\n                barPercentage: .9,\n                grouped: !0,\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"base\",\n                            \"width\",\n                            \"height\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\",\n                        offset: !0,\n                        grid: {\n                            offset: !0\n                        }\n                    },\n                    _value_: {\n                        type: \"linear\",\n                        beginAtZero: !0\n                    }\n                }\n            };\n            parsePrimitiveData(t, e, i, s) {\n                return zn(t, e, i, s);\n            }\n            parseArrayData(t, e, i, s) {\n                return zn(t, e, i, s);\n            }\n            parseObjectData(t, e, i, s) {\n                const { iScale: n, vScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = \"x\" === n.axis ? a : r, h = \"x\" === o.axis ? a : r, c = [];\n                let d, u, f, g;\n                for(d = i, u = i + s; d < u; ++d)g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(In(M(g, h), f, o, d));\n                return c;\n            }\n            updateRangeFromParsed(t, e, i, s) {\n                super.updateRangeFromParsed(t, e, i, s);\n                const n = i._custom;\n                n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max));\n            }\n            getMaxOverflow() {\n                return 0;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, { iScale: i, vScale: s } = e, n = this.getParsed(t), o = n._custom, a = Fn(o) ? \"[\" + o.start + \", \" + o.end + \"]\" : \"\" + s.getLabelForValue(n[s.axis]);\n                return {\n                    label: \"\" + i.getLabelForValue(n[i.axis]),\n                    value: a\n                };\n            }\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n                this._cachedMeta.stack = this.getDataset().stack;\n            }\n            update(t) {\n                const e = this._cachedMeta;\n                this.updateElements(e.data, 0, e.data.length, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), h = r.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);\n                for(let f = e; f < e + i; f++){\n                    const e = this.getParsed(f), i = o || s(e[r.axis]) ? {\n                        base: l,\n                        head: l\n                    } : this._calculateBarValuePixels(f), g = this._calculateBarIndexPixels(f, c), p = (e._stacks || {})[r.axis], m = {\n                        horizontal: h,\n                        base: i.base,\n                        enableBorderRadius: !p || Fn(e._custom) || a === p._top || a === p._bottom,\n                        x: h ? i.head : g.center,\n                        y: h ? g.center : i.head,\n                        height: h ? g.size : Math.abs(i.size),\n                        width: h ? Math.abs(i.size) : g.size\n                    };\n                    u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n                    const b = m.options || t[f].options;\n                    Vn(m, b, p, a), Nn(m, b, c.ratio), this.updateElement(t[f], f, m, n);\n                }\n            }\n            _getStacks(t, e) {\n                const { iScale: i } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t)=>t.controller.options.grouped), o = i.options.stacked, a = [], r = (t)=>{\n                    const i = t.controller.getParsed(e), n = i && i[t.vScale.axis];\n                    if (s(n) || isNaN(n)) return !0;\n                };\n                for (const i of n)if ((void 0 === e || !r(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;\n                return a.length || a.push(void 0), a;\n            }\n            _getStackCount(t) {\n                return this._getStacks(void 0, t).length;\n            }\n            _getStackIndex(t, e, i) {\n                const s = this._getStacks(t, i), n = void 0 !== e ? s.indexOf(e) : -1;\n                return -1 === n ? s.length - 1 : n;\n            }\n            _getRuler() {\n                const t = this.options, e = this._cachedMeta, i = e.iScale, s = [];\n                let n, o;\n                for(n = 0, o = e.data.length; n < o; ++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));\n                const a = t.barThickness;\n                return {\n                    min: a || Rn(e),\n                    pixels: s,\n                    start: i._startPixel,\n                    end: i._endPixel,\n                    stackCount: this._getStackCount(),\n                    scale: i,\n                    grouped: t.grouped,\n                    ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n                };\n            }\n            _calculateBarValuePixels(t) {\n                const { _cachedMeta: { vScale: e, _stacked: i, index: n }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Fn(h);\n                let d, u, f = l[e.axis], g = 0, p = i ? this.applyStack(e, l, i) : f;\n                p !== f && (g = p - f, p = f), c && (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f && F(f) !== F(h.barEnd) && (g = 0), g += f);\n                const m = s(o) || c ? g : o;\n                let b = e.getPixelForValue(m);\n                if (d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : b, u = d - b, Math.abs(u) < a) {\n                    u = function(t, e, i) {\n                        return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);\n                    }(u, e, r) * a, f === r && (b -= u / 2);\n                    const t = e.getPixelForDecimal(0), s = e.getPixelForDecimal(1), o = Math.min(t, s), h = Math.max(t, s);\n                    b = Math.max(Math.min(b, h), o), d = b + u, i && !c && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(b));\n                }\n                if (b === e.getPixelForValue(r)) {\n                    const t = F(u) * e.getLineWidthForValue(r) / 2;\n                    b += t, u -= t;\n                }\n                return {\n                    size: u,\n                    base: b,\n                    head: d,\n                    center: d + u / 2\n                };\n            }\n            _calculateBarIndexPixels(t, e) {\n                const i = e.scale, n = this.options, o = n.skipNull, a = l(n.maxBarThickness, 1 / 0);\n                let r, h;\n                if (e.grouped) {\n                    const i = o ? this._getStackCount(t) : e.stackCount, l = \"flex\" === n.barThickness ? function(t, e, i, s) {\n                        const n = e.pixels, o = n[t];\n                        let a = t > 0 ? n[t - 1] : null, r = t < n.length - 1 ? n[t + 1] : null;\n                        const l = i.categoryPercentage;\n                        null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);\n                        const h = o - (o - Math.min(a, r)) / 2 * l;\n                        return {\n                            chunk: Math.abs(r - a) / 2 * l / s,\n                            ratio: i.barPercentage,\n                            start: h\n                        };\n                    }(t, e, n, i) : function(t, e, i, n) {\n                        const o = i.barThickness;\n                        let a, r;\n                        return s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), {\n                            chunk: a / n,\n                            ratio: r,\n                            start: e.pixels[t] - a / 2\n                        };\n                    }(t, e, n, i), c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n                    r = l.start + l.chunk * c + l.chunk / 2, h = Math.min(a, l.chunk * l.ratio);\n                } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio);\n                return {\n                    base: r - h / 2,\n                    head: r + h / 2,\n                    center: r,\n                    size: h\n                };\n            }\n            draw() {\n                const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;\n                let n = 0;\n                for(; n < s; ++n)null !== this.getParsed(n)[e.axis] && i[n].draw(this._ctx);\n            }\n        },\n        BubbleController: class extends Ns {\n            static id = \"bubble\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"borderWidth\",\n                            \"radius\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n            }\n            parsePrimitiveData(t, e, i, s) {\n                const n = super.parsePrimitiveData(t, e, i, s);\n                for(let t = 0; t < n.length; t++)n[t]._custom = this.resolveDataElementOptions(t + i).radius;\n                return n;\n            }\n            parseArrayData(t, e, i, s) {\n                const n = super.parseArrayData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            parseObjectData(t, e, i, s) {\n                const n = super.parseObjectData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta.data;\n                let e = 0;\n                for(let i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);\n                return e > 0 && e;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y), l = o._custom;\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + (l ? \", \" + l : \"\") + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta.data;\n                this.updateElements(e, 0, e.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = \"reset\" === s, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: r, includeOptions: l } = this._getSharedOptions(e, s), h = o.axis, c = a.axis;\n                for(let d = e; d < e + i; d++){\n                    const e = t[d], i = !n && this.getParsed(d), u = {}, f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]), g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);\n                    u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? \"active\" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s);\n                }\n            }\n            resolveDataElementOptions(t, e) {\n                const i = this.getParsed(t);\n                let s = super.resolveDataElementOptions(t, e);\n                s.$shared && (s = Object.assign({}, s, {\n                    $shared: !1\n                }));\n                const n = s.radius;\n                return \"active\" !== e && (s.radius = 0), s.radius += l(i && i._custom, n), s;\n            }\n        },\n        DoughnutController: Hn,\n        LineController: class extends Ns {\n            static id = \"line\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                showLine: !0,\n                spanGaps: !1\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\"\n                    },\n                    _value_: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n            }\n            update(t) {\n                const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: n } = e, o = this.chart._animationsDisabled;\n                let { start: a, count: r } = pt(e, s, o);\n                this._drawStart = a, this._drawCount = r, mt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;\n                const l = this.resolveDatasetElementOptions(t);\n                this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {\n                    animated: !o,\n                    options: l\n                }, t), this.updateElements(s, a, r, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, { sharedOptions: c, includeOptions: d } = this._getSharedOptions(e, n), u = a.axis, f = r.axis, { spanGaps: g, segment: p } = this.options, m = N(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || \"none\" === n, x = e + i, _ = t.length;\n                let y = e > 0 && this.getParsed(e - 1);\n                for(let i = 0; i < _; ++i){\n                    const g = t[i], _ = b ? g : {};\n                    if (i < e || i >= x) {\n                        _.skip = !0;\n                        continue;\n                    }\n                    const v = this.getParsed(i), M = s(v[f]), w = _[u] = a.getPixelForValue(v[u], i), k = _[f] = o || M ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, v, l) : v[f], i);\n                    _.skip = isNaN(w) || isNaN(k) || M, _.stop = i > 0 && Math.abs(v[u] - y[u]) > m, p && (_.parsed = v, _.raw = h.data[i]), d && (_.options = c || this.resolveDataElementOptions(i, g.active ? \"active\" : n)), b || this.updateElement(g, i, _, n), y = v;\n                }\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, s = t.data || [];\n                if (!s.length) return i;\n                const n = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));\n                return Math.max(i, n, o) / 2;\n            }\n            draw() {\n                const t = this._cachedMeta;\n                t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n            }\n        },\n        PieController: class extends Hn {\n            static id = \"pie\";\n            static defaults = {\n                cutout: 0,\n                rotation: 0,\n                circumference: 360,\n                radius: \"100%\"\n            };\n        },\n        PolarAreaController: jn,\n        RadarController: class extends Ns {\n            static id = \"radar\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                indexAxis: \"r\",\n                showLine: !0,\n                elements: {\n                    line: {\n                        fill: \"start\"\n                    }\n                }\n            };\n            static overrides = {\n                aspectRatio: 1,\n                scales: {\n                    r: {\n                        type: \"radialLinear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta.vScale, i = this.getParsed(t);\n                return {\n                    label: e.getLabels()[t],\n                    value: \"\" + e.getLabelForValue(i[e.axis])\n                };\n            }\n            parseObjectData(t, e, i, s) {\n                return ii.bind(this)(t, e, i, s);\n            }\n            update(t) {\n                const e = this._cachedMeta, i = e.dataset, s = e.data || [], n = e.iScale.getLabels();\n                if (i.points = s, \"resize\" !== t) {\n                    const e = this.resolveDatasetElementOptions(t);\n                    this.options.showLine || (e.borderWidth = 0);\n                    const o = {\n                        _loop: !0,\n                        _fullLoop: n.length === s.length,\n                        options: e\n                    };\n                    this.updateElement(i, void 0, o, t);\n                }\n                this.updateElements(s, 0, s.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = this._cachedMeta.rScale, o = \"reset\" === s;\n                for(let a = e; a < e + i; a++){\n                    const e = t[a], i = this.resolveDataElementOptions(a, e.active ? \"active\" : s), r = n.getPointPositionForValue(a, this.getParsed(a).r), l = o ? n.xCenter : r.x, h = o ? n.yCenter : r.y, c = {\n                        x: l,\n                        y: h,\n                        angle: r.angle,\n                        skip: isNaN(l) || isNaN(h),\n                        options: i\n                    };\n                    this.updateElement(e, a, c, s);\n                }\n            }\n        },\n        ScatterController: class extends Ns {\n            static id = \"scatter\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                showLine: !1,\n                fill: !1\n            };\n            static overrides = {\n                interaction: {\n                    mode: \"point\"\n                },\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y);\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled;\n                let { start: n, count: o } = pt(e, i, s);\n                if (this._drawStart = n, this._drawCount = o, mt(e) && (n = 0, o = i.length), this.options.showLine) {\n                    this.datasetElementType || this.addElements();\n                    const { dataset: n, _dataset: o } = e;\n                    n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;\n                    const a = this.resolveDatasetElementOptions(t);\n                    a.segment = this.options.segment, this.updateElement(n, void 0, {\n                        animated: !s,\n                        options: a\n                    }, t);\n                } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);\n                this.updateElements(i, n, o, t);\n            }\n            addElements() {\n                const { showLine: t } = this.options;\n                !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement(\"line\")), super.addElements();\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, c = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(c), u = this.includeOptions(n, d), f = a.axis, g = r.axis, { spanGaps: p, segment: m } = this.options, b = N(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || \"none\" === n;\n                let _ = e > 0 && this.getParsed(e - 1);\n                for(let c = e; c < e + i; ++c){\n                    const e = t[c], i = this.getParsed(c), p = x ? e : {}, y = s(i[g]), v = p[f] = a.getPixelForValue(i[f], c), M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c);\n                    p.skip = isNaN(v) || isNaN(M) || y, p.stop = c > 0 && Math.abs(i[f] - _[f]) > b, m && (p.parsed = i, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? \"active\" : n)), x || this.updateElement(e, c, p, n), _ = i;\n                }\n                this.updateSharedOptions(d, n, c);\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.data || [];\n                if (!this.options.showLine) {\n                    let t = 0;\n                    for(let i = e.length - 1; i >= 0; --i)t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);\n                    return t > 0 && t;\n                }\n                const i = t.dataset, s = i.options && i.options.borderWidth || 0;\n                if (!e.length) return s;\n                const n = e[0].size(this.resolveDataElementOptions(0)), o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n                return Math.max(s, n, o) / 2;\n            }\n        }\n    });\n    function Yn(t, e, i, s) {\n        const n = vi(t.options.borderRadius, [\n            \"outerStart\",\n            \"outerEnd\",\n            \"innerStart\",\n            \"innerEnd\"\n        ]);\n        const o = (i - e) / 2, a = Math.min(o, s * e / 2), r = (t)=>{\n            const e = (i - Math.min(o, t)) * s / 2;\n            return J(t, 0, Math.min(o, e));\n        };\n        return {\n            outerStart: r(n.outerStart),\n            outerEnd: r(n.outerEnd),\n            innerStart: J(n.innerStart, 0, a),\n            innerEnd: J(n.innerEnd, 0, a)\n        };\n    }\n    function Un(t, e, i, s) {\n        return {\n            x: i + t * Math.cos(e),\n            y: s + t * Math.sin(e)\n        };\n    }\n    function Xn(t, e, i, s, n, o) {\n        const { x: a, y: r, startAngle: l, pixelMargin: h, innerRadius: c } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;\n        let f = 0;\n        const g = n - l;\n        if (s) {\n            const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;\n            f = (g - (0 !== t ? g * t / (t + s) : g)) / 2;\n        }\n        const p = (g - Math.max(.001, g * d - i / C) / d) / 2, m = l + p + f, b = n - p - f, { outerStart: x, outerEnd: _, innerStart: y, innerEnd: v } = Yn(e, u, d, b - m), M = d - x, w = d - _, k = m + x / M, S = b - _ / w, P = u + y, D = u + v, O = m + y / P, A = b - v / D;\n        if (t.beginPath(), o) {\n            const e = (k + S) / 2;\n            if (t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ > 0) {\n                const e = Un(w, S, a, r);\n                t.arc(e.x, e.y, _, S, b + E);\n            }\n            const i = Un(D, b, a, r);\n            if (t.lineTo(i.x, i.y), v > 0) {\n                const e = Un(D, A, a, r);\n                t.arc(e.x, e.y, v, b + E, A + Math.PI);\n            }\n            const s = (b - v / u + (m + y / u)) / 2;\n            if (t.arc(a, r, u, b - v / u, s, !0), t.arc(a, r, u, s, m + y / u, !0), y > 0) {\n                const e = Un(P, O, a, r);\n                t.arc(e.x, e.y, y, O + Math.PI, m - E);\n            }\n            const n = Un(M, m, a, r);\n            if (t.lineTo(n.x, n.y), x > 0) {\n                const e = Un(M, k, a, r);\n                t.arc(e.x, e.y, x, m - E, k);\n            }\n        } else {\n            t.moveTo(a, r);\n            const e = Math.cos(k) * d + a, i = Math.sin(k) * d + r;\n            t.lineTo(e, i);\n            const s = Math.cos(S) * d + a, n = Math.sin(S) * d + r;\n            t.lineTo(s, n);\n        }\n        t.closePath();\n    }\n    function qn(t, e, i, s, n) {\n        const { fullCircles: o, startAngle: a, circumference: r, options: l } = e, { borderWidth: h, borderJoinStyle: c, borderDash: d, borderDashOffset: u } = l, f = \"inner\" === l.borderAlign;\n        if (!h) return;\n        t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || \"round\") : (t.lineWidth = h, t.lineJoin = c || \"bevel\");\n        let g = e.endAngle;\n        if (o) {\n            Xn(t, e, i, s, g, n);\n            for(let e = 0; e < o; ++e)t.stroke();\n            isNaN(r) || (g = a + (r % O || O));\n        }\n        f && function(t, e, i) {\n            const { startAngle: s, pixelMargin: n, x: o, y: a, outerRadius: r, innerRadius: l } = e;\n            let h = n / r;\n            t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + E, s - E), t.closePath(), t.clip();\n        }(t, e, g), o || (Xn(t, e, i, s, g, n), t.stroke());\n    }\n    function Kn(t, e, i = e) {\n        t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor);\n    }\n    function Gn(t, e, i) {\n        t.lineTo(i.x, i.y);\n    }\n    function Zn(t, e, i = {}) {\n        const s = t.length, { start: n = 0, end: o = s - 1 } = i, { start: a, end: r } = e, l = Math.max(n, a), h = Math.min(o, r), c = n < a && o < a || n > r && o > r;\n        return {\n            count: s,\n            start: l,\n            loop: e.loop,\n            ilen: h < l && !c ? s + h - l : h - l\n        };\n    }\n    function Jn(t, e, i, s) {\n        const { points: n, options: o } = e, { count: a, start: r, loop: l, ilen: h } = Zn(n, i, s), c = function(t) {\n            return t.stepped ? Fe : t.tension || \"monotone\" === t.cubicInterpolationMode ? Ve : Gn;\n        }(o);\n        let d, u, f, { move: g = !0, reverse: p } = s || {};\n        for(d = 0; d <= h; ++d)u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);\n        return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l;\n    }\n    function Qn(t, e, i, s) {\n        const n = e.points, { count: o, start: a, ilen: r } = Zn(n, i, s), { move: l = !0, reverse: h } = s || {};\n        let c, d, u, f, g, p, m = 0, b = 0;\n        const x = (t)=>(a + (h ? r - t : t)) % o, _ = ()=>{\n            f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p));\n        };\n        for(l && (d = n[x(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c){\n            if (d = n[x(c)], d.skip) continue;\n            const e = d.x, i = d.y, s = 0 | e;\n            s === u ? (i < f ? f = i : i > g && (g = i), m = (b * m + e) / ++b) : (_(), t.lineTo(e, i), u = s, b = 0, f = g = i), p = i;\n        }\n        _();\n    }\n    function to(t) {\n        const e = t.options, i = e.borderDash && e.borderDash.length;\n        return !(t._decimated || t._loop || e.tension || \"monotone\" === e.cubicInterpolationMode || e.stepped || i) ? Qn : Jn;\n    }\n    const eo = \"function\" == typeof Path2D;\n    function io(t, e, i, s) {\n        eo && !e.options.segment ? function(t, e, i, s) {\n            let n = e._path;\n            n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Kn(t, e.options), t.stroke(n);\n        }(t, e, i, s) : function(t, e, i, s) {\n            const { segments: n, options: o } = e, a = to(e);\n            for (const r of n)Kn(t, o, r.style), t.beginPath(), a(t, e, r, {\n                start: i,\n                end: i + s - 1\n            }) && t.closePath(), t.stroke();\n        }(t, e, i, s);\n    }\n    class so extends Hs {\n        static id = \"line\";\n        static defaults = {\n            borderCapStyle: \"butt\",\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: \"miter\",\n            borderWidth: 3,\n            capBezierPoints: !0,\n            cubicInterpolationMode: \"default\",\n            fill: !1,\n            spanGaps: !1,\n            stepped: !1,\n            tension: 0\n        };\n        static defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n        static descriptors = {\n            _scriptable: !0,\n            _indexable: (t)=>\"borderDash\" !== t && \"fill\" !== t\n        };\n        constructor(t){\n            super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n        }\n        updateControlPoints(t, e) {\n            const i = this.options;\n            if ((i.tension || \"monotone\" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {\n                const s = i.spanGaps ? this._loop : this._fullLoop;\n                hi(this._points, i, t, s, e), this._pointsUpdated = !0;\n            }\n        }\n        set points(t) {\n            this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n        }\n        get points() {\n            return this._points;\n        }\n        get segments() {\n            return this._segments || (this._segments = zi(this, this.options.segment));\n        }\n        first() {\n            const t = this.segments, e = this.points;\n            return t.length && e[t[0].start];\n        }\n        last() {\n            const t = this.segments, e = this.points, i = t.length;\n            return i && e[t[i - 1].end];\n        }\n        interpolate(t, e) {\n            const i = this.options, s = t[e], n = this.points, o = Ii(this, {\n                property: e,\n                start: s,\n                end: s\n            });\n            if (!o.length) return;\n            const a = [], r = function(t) {\n                return t.stepped ? pi : t.tension || \"monotone\" === t.cubicInterpolationMode ? mi : gi;\n            }(i);\n            let l, h;\n            for(l = 0, h = o.length; l < h; ++l){\n                const { start: h, end: c } = o[l], d = n[h], u = n[c];\n                if (d === u) {\n                    a.push(d);\n                    continue;\n                }\n                const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);\n                f[e] = t[e], a.push(f);\n            }\n            return 1 === a.length ? a[0] : a;\n        }\n        pathSegment(t, e, i) {\n            return to(this)(t, this, e, i);\n        }\n        path(t, e, i) {\n            const s = this.segments, n = to(this);\n            let o = this._loop;\n            e = e || 0, i = i || this.points.length - e;\n            for (const a of s)o &= n(t, this, a, {\n                start: e,\n                end: e + i - 1\n            });\n            return !!o;\n        }\n        draw(t, e, i, s) {\n            const n = this.options || {};\n            (this.points || []).length && n.borderWidth && (t.save(), io(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n        }\n    }\n    function no(t, e, i, s) {\n        const n = t.options, { [i]: o } = t.getProps([\n            i\n        ], s);\n        return Math.abs(e - o) < n.radius + n.hitRadius;\n    }\n    function oo(t, e) {\n        const { x: i, y: s, base: n, width: o, height: a } = t.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"width\",\n            \"height\"\n        ], e);\n        let r, l, h, c, d;\n        return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {\n            left: r,\n            top: h,\n            right: l,\n            bottom: c\n        };\n    }\n    function ao(t, e, i, s) {\n        return t ? 0 : J(e, i, s);\n    }\n    function ro(t) {\n        const e = oo(t), i = e.right - e.left, s = e.bottom - e.top, n = function(t, e, i) {\n            const s = t.options.borderWidth, n = t.borderSkipped, o = Mi(s);\n            return {\n                t: ao(n.top, o.top, 0, i),\n                r: ao(n.right, o.right, 0, e),\n                b: ao(n.bottom, o.bottom, 0, i),\n                l: ao(n.left, o.left, 0, e)\n            };\n        }(t, i / 2, s / 2), a = function(t, e, i) {\n            const { enableBorderRadius: s } = t.getProps([\n                \"enableBorderRadius\"\n            ]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);\n            return {\n                topLeft: ao(!h || l.top || l.left, a.topLeft, 0, r),\n                topRight: ao(!h || l.top || l.right, a.topRight, 0, r),\n                bottomLeft: ao(!h || l.bottom || l.left, a.bottomLeft, 0, r),\n                bottomRight: ao(!h || l.bottom || l.right, a.bottomRight, 0, r)\n            };\n        }(t, i / 2, s / 2);\n        return {\n            outer: {\n                x: e.left,\n                y: e.top,\n                w: i,\n                h: s,\n                radius: a\n            },\n            inner: {\n                x: e.left + n.l,\n                y: e.top + n.t,\n                w: i - n.l - n.r,\n                h: s - n.t - n.b,\n                radius: {\n                    topLeft: Math.max(0, a.topLeft - Math.max(n.t, n.l)),\n                    topRight: Math.max(0, a.topRight - Math.max(n.t, n.r)),\n                    bottomLeft: Math.max(0, a.bottomLeft - Math.max(n.b, n.l)),\n                    bottomRight: Math.max(0, a.bottomRight - Math.max(n.b, n.r))\n                }\n            }\n        };\n    }\n    function lo(t, e, i, s) {\n        const n = null === e, o = null === i, a = t && !(n && o) && oo(t, s);\n        return a && (n || tt(e, a.left, a.right)) && (o || tt(i, a.top, a.bottom));\n    }\n    function ho(t, e) {\n        t.rect(e.x, e.y, e.w, e.h);\n    }\n    function co(t, e, i = {}) {\n        const s = t.x !== i.x ? -e : 0, n = t.y !== i.y ? -e : 0, o = (t.x + t.w !== i.x + i.w ? e : 0) - s, a = (t.y + t.h !== i.y + i.h ? e : 0) - n;\n        return {\n            x: t.x + s,\n            y: t.y + n,\n            w: t.w + o,\n            h: t.h + a,\n            radius: t.radius\n        };\n    }\n    var uo = Object.freeze({\n        __proto__: null,\n        ArcElement: class extends Hs {\n            static id = \"arc\";\n            static defaults = {\n                borderAlign: \"center\",\n                borderColor: \"#fff\",\n                borderDash: [],\n                borderDashOffset: 0,\n                borderJoinStyle: void 0,\n                borderRadius: 0,\n                borderWidth: 2,\n                offset: 0,\n                spacing: 0,\n                angle: void 0,\n                circular: !0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\"\n            };\n            static descriptors = {\n                _scriptable: !0,\n                _indexable: (t)=>\"borderDash\" !== t\n            };\n            circumference;\n            endAngle;\n            fullCircles;\n            innerRadius;\n            outerRadius;\n            pixelMargin;\n            startAngle;\n            constructor(t){\n                super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i), { angle: n, distance: o } = X(s, {\n                    x: t,\n                    y: e\n                }), { startAngle: a, endAngle: r, innerRadius: h, outerRadius: c, circumference: d } = this.getProps([\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\",\n                    \"circumference\"\n                ], i), u = (this.options.spacing + this.options.borderWidth) / 2, f = l(d, r - a) >= O || Z(n, a, r), g = tt(o, h + u, c + u);\n                return f && g;\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, startAngle: s, endAngle: n, innerRadius: o, outerRadius: a } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\"\n                ], t), { offset: r, spacing: l } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;\n                return {\n                    x: e + Math.cos(h) * c,\n                    y: i + Math.sin(h) * c\n                };\n            }\n            tooltipPosition(t) {\n                return this.getCenterPoint(t);\n            }\n            draw(t) {\n                const { options: e, circumference: i } = this, s = (e.offset || 0) / 4, n = (e.spacing || 0) / 2, o = e.circular;\n                if (this.pixelMargin = \"inner\" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;\n                t.save();\n                const a = (this.startAngle + this.endAngle) / 2;\n                t.translate(Math.cos(a) * s, Math.sin(a) * s);\n                const r = s * (1 - Math.sin(Math.min(C, i || 0)));\n                t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, function(t, e, i, s, n) {\n                    const { fullCircles: o, startAngle: a, circumference: r } = e;\n                    let l = e.endAngle;\n                    if (o) {\n                        Xn(t, e, i, s, l, n);\n                        for(let e = 0; e < o; ++e)t.fill();\n                        isNaN(r) || (l = a + (r % O || O));\n                    }\n                    Xn(t, e, i, s, l, n), t.fill();\n                }(t, this, r, n, o), qn(t, this, r, n, o), t.restore();\n            }\n        },\n        BarElement: class extends Hs {\n            static id = \"bar\";\n            static defaults = {\n                borderSkipped: \"start\",\n                borderWidth: 0,\n                borderRadius: 0,\n                inflateAmount: \"auto\",\n                pointStyle: void 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n            }\n            draw(t) {\n                const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: n, outer: o } = ro(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : ho;\n                var r;\n                t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, co(o, e, n)), t.clip(), a(t, co(n, -e, o)), t.fillStyle = i, t.fill(\"evenodd\")), t.beginPath(), a(t, co(n, e)), t.fillStyle = s, t.fill(), t.restore();\n            }\n            inRange(t, e, i) {\n                return lo(this, t, e, i);\n            }\n            inXRange(t, e) {\n                return lo(this, t, null, e);\n            }\n            inYRange(t, e) {\n                return lo(this, null, t, e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, base: s, horizontal: n } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"base\",\n                    \"horizontal\"\n                ], t);\n                return {\n                    x: n ? (e + s) / 2 : e,\n                    y: n ? i : (i + s) / 2\n                };\n            }\n            getRange(t) {\n                return \"x\" === t ? this.width / 2 : this.height / 2;\n            }\n        },\n        LineElement: so,\n        PointElement: class extends Hs {\n            static id = \"point\";\n            parsed;\n            skip;\n            stop;\n            static defaults = {\n                borderWidth: 1,\n                hitRadius: 1,\n                hoverBorderWidth: 1,\n                hoverRadius: 4,\n                pointStyle: \"circle\",\n                radius: 3,\n                rotation: 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.options, { x: n, y: o } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i);\n                return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2);\n            }\n            inXRange(t, e) {\n                return no(this, t, \"x\", e);\n            }\n            inYRange(t, e) {\n                return no(this, t, \"y\", e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], t);\n                return {\n                    x: e,\n                    y: i\n                };\n            }\n            size(t) {\n                let e = (t = t || this.options || {}).radius || 0;\n                e = Math.max(e, e && t.hoverRadius || 0);\n                return 2 * (e + (e && t.borderWidth || 0));\n            }\n            draw(t, e) {\n                const i = this.options;\n                this.skip || i.radius < .1 || !Re(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, this.x, this.y));\n            }\n            getRange() {\n                const t = this.options || {};\n                return t.radius + t.hitRadius;\n            }\n        }\n    });\n    function fo(t, e, i, s) {\n        const n = t.indexOf(e);\n        if (-1 === n) return ((t, e, i, s)=>(\"string\" == typeof e ? (i = t.push(e) - 1, s.unshift({\n                index: i,\n                label: e\n            })) : isNaN(e) && (i = null), i))(t, e, i, s);\n        return n !== t.lastIndexOf(e) ? i : n;\n    }\n    function go(t) {\n        const e = this.getLabels();\n        return t >= 0 && t < e.length ? e[t] : t;\n    }\n    function po(t, e, { horizontal: i, minRotation: s }) {\n        const n = $(s), o = (i ? Math.sin(n) : Math.cos(n)) || .001, a = .75 * e * (\"\" + t).length;\n        return Math.min(e / o, a);\n    }\n    class mo extends Js {\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            return s(t) || (\"number\" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t;\n        }\n        handleTickRangeOptions() {\n            const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds();\n            let { min: s, max: n } = this;\n            const o = (t)=>s = e ? s : t, a = (t)=>n = i ? n : t;\n            if (t) {\n                const t = F(s), e = F(n);\n                t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0);\n            }\n            if (s === n) {\n                let e = 0 === n ? 1 : Math.abs(.05 * n);\n                a(n + e), t || o(s - e);\n            }\n            this.min = s, this.max = n;\n        }\n        getTickLimit() {\n            const t = this.options.ticks;\n            let e, { maxTicksLimit: i, stepSize: s } = t;\n            return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e;\n        }\n        computeTickLimit() {\n            return Number.POSITIVE_INFINITY;\n        }\n        buildTicks() {\n            const t = this.options, e = t.ticks;\n            let i = this.getTickLimit();\n            i = Math.max(2, i);\n            const n = function(t, e) {\n                const i = [], { bounds: n, step: o, min: a, max: r, precision: l, count: h, maxTicks: c, maxDigits: d, includeBounds: u } = t, f = o || 1, g = c - 1, { min: p, max: m } = e, b = !s(a), x = !s(r), _ = !s(h), y = (m - p) / (d + 1);\n                let v, M, w, k, S = B((m - p) / g / f) * f;\n                if (S < 1e-14 && !b && !x) return [\n                    {\n                        value: p\n                    },\n                    {\n                        value: m\n                    }\n                ];\n                k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = B(k * S / g / f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), \"ticks\" === n ? (M = Math.floor(p / S) * S, w = Math.ceil(m / S) * S) : (M = p, w = m), b && x && o && H((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, M = a, w = r) : _ ? (M = b ? a : M, w = x ? r : w, k = h - 1, S = (w - M) / k) : (k = (w - M) / S, k = V(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));\n                const P = Math.max(U(S), U(M));\n                v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) / v, w = Math.round(w * v) / v;\n                let D = 0;\n                for(b && (u && M !== a ? (i.push({\n                    value: a\n                }), M < a && D++, V(Math.round((M + D * S) * v) / v, a, po(a, y, t)) && D++) : M < a && D++); D < k; ++D){\n                    const t = Math.round((M + D * S) * v) / v;\n                    if (x && t > r) break;\n                    i.push({\n                        value: t\n                    });\n                }\n                return x && u && w !== r ? i.length && V(i[i.length - 1].value, r, po(r, y, t)) ? i[i.length - 1].value = r : i.push({\n                    value: r\n                }) : x && w !== r || i.push({\n                    value: w\n                }), i;\n            }({\n                maxTicks: i,\n                bounds: t.bounds,\n                min: t.min,\n                max: t.max,\n                precision: e.precision,\n                step: e.stepSize,\n                count: e.count,\n                maxDigits: this._maxDigits(),\n                horizontal: this.isHorizontal(),\n                minRotation: e.minRotation || 0,\n                includeBounds: !1 !== e.includeBounds\n            }, this._range || this);\n            return \"ticks\" === t.bounds && j(n, this, \"value\"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;\n        }\n        configure() {\n            const t = this.ticks;\n            let e = this.min, i = this.max;\n            if (super.configure(), this.options.offset && t.length) {\n                const s = (i - e) / Math.max(t.length - 1, 1) / 2;\n                e -= s, i += s;\n            }\n            this._startValue = e, this._endValue = i, this._valueRange = i - e;\n        }\n        getLabelForValue(t) {\n            return ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n    }\n    class bo extends mo {\n        static id = \"linear\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.numeric\n            }\n        };\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            const t = this.isHorizontal(), e = t ? this.width : this.height, i = $(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, n = this._resolveTickFontOptions(0);\n            return Math.ceil(e / Math.min(40, n.lineHeight / s));\n        }\n        getPixelForValue(t) {\n            return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n        }\n    }\n    const xo = (t)=>Math.floor(z(t)), _o = (t, e)=>Math.pow(10, xo(t) + e);\n    function yo(t) {\n        return 1 === t / Math.pow(10, xo(t));\n    }\n    function vo(t, e, i) {\n        const s = Math.pow(10, i), n = Math.floor(t / s);\n        return Math.ceil(e / s) - n;\n    }\n    function Mo(t, { min: e, max: i }) {\n        e = r(t.min, e);\n        const s = [], n = xo(e);\n        let o = function(t, e) {\n            let i = xo(e - t);\n            for(; vo(t, e, i) > 10;)i++;\n            for(; vo(t, e, i) < 10;)i--;\n            return Math.min(i, xo(t));\n        }(e, i), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1;\n        const l = Math.pow(10, o), h = n > o ? Math.pow(10, n) : 0, c = Math.round((e - h) * a) / a, d = Math.floor((e - h) / l / 10) * l * 10;\n        let u = Math.floor((c - d) / Math.pow(10, o)), f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) / a);\n        for(; f < i;)s.push({\n            value: f,\n            major: yo(f),\n            significand: u\n        }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) / a;\n        const g = r(t.max, f);\n        return s.push({\n            value: g,\n            major: yo(g),\n            significand: u\n        }), s;\n    }\n    class wo extends Js {\n        static id = \"logarithmic\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.logarithmic,\n                major: {\n                    enabled: !0\n                }\n            }\n        };\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            const i = mo.prototype.parse.apply(this, [\n                t,\n                e\n            ]);\n            if (0 !== i) return a(i) && i > 0 ? i : null;\n            this._zero = !0;\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !a(this._userMin) && (this.min = t === _o(this.min, 0) ? _o(this.min, -1) : _o(this.min, 0)), this.handleTickRangeOptions();\n        }\n        handleTickRangeOptions() {\n            const { minDefined: t, maxDefined: e } = this.getUserBounds();\n            let i = this.min, s = this.max;\n            const n = (e)=>i = t ? i : e, o = (t)=>s = e ? s : t;\n            i === s && (i <= 0 ? (n(1), o(10)) : (n(_o(i, -1)), o(_o(s, 1)))), i <= 0 && n(_o(s, -1)), s <= 0 && o(_o(i, 1)), this.min = i, this.max = s;\n        }\n        buildTicks() {\n            const t = this.options, e = Mo({\n                min: this._userMin,\n                max: this._userMax\n            }, this);\n            return \"ticks\" === t.bounds && j(e, this, \"value\"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e;\n        }\n        getLabelForValue(t) {\n            return void 0 === t ? \"0\" : ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n        configure() {\n            const t = this.min;\n            super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t);\n        }\n        getPixelForValue(t) {\n            return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            const e = this.getDecimalForPixel(t);\n            return Math.pow(10, this._startValue + e * this._valueRange);\n        }\n    }\n    function ko(t) {\n        const e = t.ticks;\n        if (e.display && t.display) {\n            const t = ki(e.backdropPadding);\n            return l(e.font && e.font.size, ue.font.size) + t.height;\n        }\n        return 0;\n    }\n    function So(t, e, i, s, n) {\n        return t === s || t === n ? {\n            start: e - i / 2,\n            end: e + i / 2\n        } : t < s || t > n ? {\n            start: e - i,\n            end: e\n        } : {\n            start: e,\n            end: e + i\n        };\n    }\n    function Po(t) {\n        const e = {\n            l: t.left + t._padding.left,\n            r: t.right - t._padding.right,\n            t: t.top + t._padding.top,\n            b: t.bottom - t._padding.bottom\n        }, i = Object.assign({}, e), s = [], o = [], a = t._pointLabels.length, r = t.options.pointLabels, l = r.centerPointLabels ? C / a : 0;\n        for(let u = 0; u < a; u++){\n            const a = r.setContext(t.getPointLabelContext(u));\n            o[u] = a.padding;\n            const f = t.getPointPosition(u, t.drawingArea + o[u], l), g = Si(a.font), p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [\n                d\n            ], {\n                w: Oe(h, c.string, d),\n                h: d.length * c.lineHeight\n            });\n            s[u] = p;\n            const m = G(t.getIndexAngle(u) + l), b = Math.round(Y(m));\n            Do(i, e, m, So(b, f.x, p.w, 0, 180), So(b, f.y, p.h, 90, 270));\n        }\n        var h, c, d;\n        t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function(t, e, i) {\n            const s = [], n = t._pointLabels.length, o = t.options, { centerPointLabels: a, display: r } = o.pointLabels, l = {\n                extra: ko(o) / 2,\n                additionalAngle: a ? C / n : 0\n            };\n            let h;\n            for(let o = 0; o < n; o++){\n                l.padding = i[o], l.size = e[o];\n                const n = Co(t, o, l);\n                s.push(n), \"auto\" === r && (n.visible = Oo(n, h), n.visible && (h = n));\n            }\n            return s;\n        }(t, s, o);\n    }\n    function Do(t, e, i, s, n) {\n        const o = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i));\n        let r = 0, l = 0;\n        s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l));\n    }\n    function Co(t, e, i) {\n        const s = t.drawingArea, { extra: n, additionalAngle: o, padding: a, size: r } = i, l = t.getPointPosition(e, s + n + a, o), h = Math.round(Y(G(l.angle + E))), c = function(t, e, i) {\n            90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);\n            return t;\n        }(l.y, r.h, h), d = function(t) {\n            if (0 === t || 180 === t) return \"center\";\n            if (t < 180) return \"left\";\n            return \"right\";\n        }(h), u = function(t, e, i) {\n            \"right\" === i ? t -= e : \"center\" === i && (t -= e / 2);\n            return t;\n        }(l.x, r.w, d);\n        return {\n            visible: !0,\n            x: l.x,\n            y: c,\n            textAlign: d,\n            left: u,\n            top: c,\n            right: u + r.w,\n            bottom: c + r.h\n        };\n    }\n    function Oo(t, e) {\n        if (!e) return !0;\n        const { left: i, top: s, right: n, bottom: o } = t;\n        return !(Re({\n            x: i,\n            y: s\n        }, e) || Re({\n            x: i,\n            y: o\n        }, e) || Re({\n            x: n,\n            y: s\n        }, e) || Re({\n            x: n,\n            y: o\n        }, e));\n    }\n    function Ao(t, e, i) {\n        const { left: n, top: o, right: a, bottom: r } = i, { backdropColor: l } = e;\n        if (!s(l)) {\n            const i = wi(e.borderRadius), s = ki(e.backdropPadding);\n            t.fillStyle = l;\n            const h = n - s.left, c = o - s.top, d = a - n + s.width, u = r - o + s.height;\n            Object.values(i).some((t)=>0 !== t) ? (t.beginPath(), He(t, {\n                x: h,\n                y: c,\n                w: d,\n                h: u,\n                radius: i\n            }), t.fill()) : t.fillRect(h, c, d, u);\n        }\n    }\n    function To(t, e, i, s) {\n        const { ctx: n } = t;\n        if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);\n        else {\n            let i = t.getPointPosition(0, e);\n            n.moveTo(i.x, i.y);\n            for(let o = 1; o < s; o++)i = t.getPointPosition(o, e), n.lineTo(i.x, i.y);\n        }\n    }\n    class Lo extends mo {\n        static id = \"radialLinear\";\n        static defaults = {\n            display: !0,\n            animate: !0,\n            position: \"chartArea\",\n            angleLines: {\n                display: !0,\n                lineWidth: 1,\n                borderDash: [],\n                borderDashOffset: 0\n            },\n            grid: {\n                circular: !1\n            },\n            startAngle: 0,\n            ticks: {\n                showLabelBackdrop: !0,\n                callback: ae.formatters.numeric\n            },\n            pointLabels: {\n                backdropColor: void 0,\n                backdropPadding: 2,\n                display: !0,\n                font: {\n                    size: 10\n                },\n                callback: (t)=>t,\n                padding: 5,\n                centerPointLabels: !1\n            }\n        };\n        static defaultRoutes = {\n            \"angleLines.color\": \"borderColor\",\n            \"pointLabels.color\": \"color\",\n            \"ticks.color\": \"color\"\n        };\n        static descriptors = {\n            angleLines: {\n                _fallback: \"grid\"\n            }\n        };\n        constructor(t){\n            super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n        }\n        setDimensions() {\n            const t = this._padding = ki(ko(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height;\n            this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!1);\n            this.min = a(t) && !isNaN(t) ? t : 0, this.max = a(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            return Math.ceil(this.drawingArea / ko(this.options));\n        }\n        generateTickLabels(t) {\n            mo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e)=>{\n                const i = d(this.options.pointLabels.callback, [\n                    t,\n                    e\n                ], this);\n                return i || 0 === i ? i : \"\";\n            }).filter((t, e)=>this.chart.getDataVisibility(e));\n        }\n        fit() {\n            const t = this.options;\n            t.display && t.pointLabels.display ? Po(this) : this.setCenterPoint(0, 0, 0, 0);\n        }\n        setCenterPoint(t, e, i, s) {\n            this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));\n        }\n        getIndexAngle(t) {\n            return G(t * (O / (this._pointLabels.length || 1)) + $(this.options.startAngle || 0));\n        }\n        getDistanceFromCenterForValue(t) {\n            if (s(t)) return NaN;\n            const e = this.drawingArea / (this.max - this.min);\n            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n        }\n        getValueForDistanceFromCenter(t) {\n            if (s(t)) return NaN;\n            const e = t / (this.drawingArea / (this.max - this.min));\n            return this.options.reverse ? this.max - e : this.min + e;\n        }\n        getPointLabelContext(t) {\n            const e = this._pointLabels || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return function(t, e, i) {\n                    return Ci(t, {\n                        label: i,\n                        index: e,\n                        type: \"pointLabel\"\n                    });\n                }(this.getContext(), t, i);\n            }\n        }\n        getPointPosition(t, e, i = 0) {\n            const s = this.getIndexAngle(t) - E + i;\n            return {\n                x: Math.cos(s) * e + this.xCenter,\n                y: Math.sin(s) * e + this.yCenter,\n                angle: s\n            };\n        }\n        getPointPositionForValue(t, e) {\n            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n        }\n        getBasePosition(t) {\n            return this.getPointPositionForValue(t || 0, this.getBaseValue());\n        }\n        getPointLabelPosition(t) {\n            const { left: e, top: i, right: s, bottom: n } = this._pointLabelItems[t];\n            return {\n                left: e,\n                top: i,\n                right: s,\n                bottom: n\n            };\n        }\n        drawBackground() {\n            const { backgroundColor: t, grid: { circular: e } } = this.options;\n            if (t) {\n                const i = this.ctx;\n                i.save(), i.beginPath(), To(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();\n            }\n        }\n        drawGrid() {\n            const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: n } = e, o = this._pointLabels.length;\n            let a, r, l;\n            if (e.pointLabels.display && function(t, e) {\n                const { ctx: i, options: { pointLabels: s } } = t;\n                for(let n = e - 1; n >= 0; n--){\n                    const e = t._pointLabelItems[n];\n                    if (!e.visible) continue;\n                    const o = s.setContext(t.getPointLabelContext(n));\n                    Ao(i, o, e);\n                    const a = Si(o.font), { x: r, y: l, textAlign: h } = e;\n                    Ne(i, t._pointLabels[n], r, l + a.lineHeight / 2, a, {\n                        color: o.color,\n                        textAlign: h,\n                        textBaseline: \"middle\"\n                    });\n                }\n            }(this, o), s.display && this.ticks.forEach((t, e)=>{\n                if (0 !== e) {\n                    r = this.getDistanceFromCenterForValue(t.value);\n                    const i = this.getContext(e), a = s.setContext(i), l = n.setContext(i);\n                    !function(t, e, i, s, n) {\n                        const o = t.ctx, a = e.circular, { color: r, lineWidth: l } = e;\n                        !a && !s || !r || !l || i < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash), o.lineDashOffset = n.dashOffset, o.beginPath(), To(t, i, a, s), o.closePath(), o.stroke(), o.restore());\n                    }(this, a, r, o, l);\n                }\n            }), i.display) {\n                for(t.save(), a = o - 1; a >= 0; a--){\n                    const s = i.setContext(this.getPointLabelContext(a)), { color: n, lineWidth: o } = s;\n                    o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n                }\n                t.restore();\n            }\n        }\n        drawBorder() {}\n        drawLabels() {\n            const t = this.ctx, e = this.options, i = e.ticks;\n            if (!i.display) return;\n            const s = this.getIndexAngle(0);\n            let n, o;\n            t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((s, a)=>{\n                if (0 === a && !e.reverse) return;\n                const r = i.setContext(this.getContext(a)), l = Si(r.font);\n                if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {\n                    t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;\n                    const e = ki(r.backdropPadding);\n                    t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height);\n                }\n                Ne(t, s.label, 0, -n, l, {\n                    color: r.color,\n                    strokeColor: r.textStrokeColor,\n                    strokeWidth: r.textStrokeWidth\n                });\n            }), t.restore();\n        }\n        drawTitle() {}\n    }\n    const Eo = {\n        millisecond: {\n            common: !0,\n            size: 1,\n            steps: 1e3\n        },\n        second: {\n            common: !0,\n            size: 1e3,\n            steps: 60\n        },\n        minute: {\n            common: !0,\n            size: 6e4,\n            steps: 60\n        },\n        hour: {\n            common: !0,\n            size: 36e5,\n            steps: 24\n        },\n        day: {\n            common: !0,\n            size: 864e5,\n            steps: 30\n        },\n        week: {\n            common: !1,\n            size: 6048e5,\n            steps: 4\n        },\n        month: {\n            common: !0,\n            size: 2628e6,\n            steps: 12\n        },\n        quarter: {\n            common: !1,\n            size: 7884e6,\n            steps: 4\n        },\n        year: {\n            common: !0,\n            size: 3154e7\n        }\n    }, Ro = Object.keys(Eo);\n    function Io(t, e) {\n        return t - e;\n    }\n    function zo(t, e) {\n        if (s(e)) return null;\n        const i = t._adapter, { parser: n, round: o, isoWeekday: r } = t._parseOpts;\n        let l = e;\n        return \"function\" == typeof n && (l = n(l)), a(l) || (l = \"string\" == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o && (l = \"week\" !== o || !N(r) && !0 !== r ? i.startOf(l, o) : i.startOf(l, \"isoWeek\", r)), +l);\n    }\n    function Fo(t, e, i, s) {\n        const n = Ro.length;\n        for(let o = Ro.indexOf(t); o < n - 1; ++o){\n            const t = Eo[Ro[o]], n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;\n            if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return Ro[o];\n        }\n        return Ro[n - 1];\n    }\n    function Vo(t, e, i) {\n        if (i) {\n            if (i.length) {\n                const { lo: s, hi: n } = et(i, e);\n                t[i[s] >= e ? i[s] : i[n]] = !0;\n            }\n        } else t[e] = !0;\n    }\n    function Bo(t, e, i) {\n        const s = [], n = {}, o = e.length;\n        let a, r;\n        for(a = 0; a < o; ++a)r = e[a], n[r] = a, s.push({\n            value: r,\n            major: !1\n        });\n        return 0 !== o && i ? function(t, e, i, s) {\n            const n = t._adapter, o = +n.startOf(e[0].value, s), a = e[e.length - 1].value;\n            let r, l;\n            for(r = o; r <= a; r = +n.add(r, 1, s))l = i[r], l >= 0 && (e[l].major = !0);\n            return e;\n        }(t, s, n, i) : s;\n    }\n    class Wo extends Js {\n        static id = \"time\";\n        static defaults = {\n            bounds: \"data\",\n            adapters: {},\n            time: {\n                parser: !1,\n                unit: !1,\n                round: !1,\n                isoWeekday: !1,\n                minUnit: \"millisecond\",\n                displayFormats: {}\n            },\n            ticks: {\n                source: \"auto\",\n                callback: !1,\n                major: {\n                    enabled: !1\n                }\n            }\n        };\n        constructor(t){\n            super(t), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n        }\n        init(t, e = {}) {\n            const i = t.time || (t.time = {}), s = this._adapter = new En._date(t.adapters.date);\n            s.init(e), x(i.displayFormats, s.formats()), this._parseOpts = {\n                parser: i.parser,\n                round: i.round,\n                isoWeekday: i.isoWeekday\n            }, super.init(t), this._normalized = e.normalized;\n        }\n        parse(t, e) {\n            return void 0 === t ? null : zo(this, t);\n        }\n        beforeLayout() {\n            super.beforeLayout(), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            };\n        }\n        determineDataLimits() {\n            const t = this.options, e = this._adapter, i = t.time.unit || \"day\";\n            let { min: s, max: n, minDefined: o, maxDefined: r } = this.getUserBounds();\n            function l(t) {\n                o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max));\n            }\n            o && r || (l(this._getLabelBounds()), \"ticks\" === t.bounds && \"labels\" === t.ticks.source || l(this.getMinMax(!1))), s = a(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n);\n        }\n        _getLabelBounds() {\n            const t = this.getLabelTimestamps();\n            let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n            return t.length && (e = t[0], i = t[t.length - 1]), {\n                min: e,\n                max: i\n            };\n        }\n        buildTicks() {\n            const t = this.options, e = t.time, i = t.ticks, s = \"labels\" === i.source ? this.getLabelTimestamps() : this._generate();\n            \"ticks\" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);\n            const n = this.min, o = nt(s, n, this.max);\n            return this._unit = e.unit || (i.autoSkip ? Fo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function(t, e, i, s, n) {\n                for(let o = Ro.length - 1; o >= Ro.indexOf(i); o--){\n                    const i = Ro[o];\n                    if (Eo[i].common && t._adapter.diff(n, s, i) >= e - 1) return i;\n                }\n                return Ro[i ? Ro.indexOf(i) : 0];\n            }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && \"year\" !== this._unit ? function(t) {\n                for(let e = Ro.indexOf(t) + 1, i = Ro.length; e < i; ++e)if (Eo[Ro[e]].common) return Ro[e];\n            }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), Bo(this, o, this._majorUnit);\n        }\n        afterAutoSkip() {\n            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t)=>+t.value));\n        }\n        initOffsets(t = []) {\n            let e, i, s = 0, n = 0;\n            this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);\n            const o = t.length < 3 ? .5 : .25;\n            s = J(s, 0, o), n = J(n, 0, o), this._offsets = {\n                start: s,\n                end: n,\n                factor: 1 / (s + 1 + n)\n            };\n        }\n        _generate() {\n            const t = this._adapter, e = this.min, i = this.max, s = this.options, n = s.time, o = n.unit || Fo(n.minUnit, e, i, this._getLabelCapacity(e)), a = l(s.ticks.stepSize, 1), r = \"week\" === o && n.isoWeekday, h = N(r) || !0 === r, c = {};\n            let d, u, f = e;\n            if (h && (f = +t.startOf(f, \"isoWeek\", r)), f = +t.startOf(f, h ? \"day\" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + \" and \" + i + \" are too far apart with stepSize of \" + a + \" \" + o);\n            const g = \"data\" === s.ticks.source && this.getDataTimestamps();\n            for(d = f, u = 0; d < i; d = +t.add(d, a, o), u++)Vo(c, d, g);\n            return d !== i && \"ticks\" !== s.bounds && 1 !== u || Vo(c, d, g), Object.keys(c).sort(Io).map((t)=>+t);\n        }\n        getLabelForValue(t) {\n            const e = this._adapter, i = this.options.time;\n            return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);\n        }\n        format(t, e) {\n            const i = this.options.time.displayFormats, s = this._unit, n = e || i[s];\n            return this._adapter.format(t, n);\n        }\n        _tickFormatFunction(t, e, i, s) {\n            const n = this.options, o = n.ticks.callback;\n            if (o) return d(o, [\n                t,\n                e,\n                i\n            ], this);\n            const a = n.time.displayFormats, r = this._unit, l = this._majorUnit, h = r && a[r], c = l && a[l], u = i[e], f = l && c && u && u.major;\n            return this._adapter.format(t, s || (f ? c : h));\n        }\n        generateTickLabels(t) {\n            let e, i, s;\n            for(e = 0, i = t.length; e < i; ++e)s = t[e], s.label = this._tickFormatFunction(s.value, e, t);\n        }\n        getDecimalForValue(t) {\n            return null === t ? NaN : (t - this.min) / (this.max - this.min);\n        }\n        getPixelForValue(t) {\n            const e = this._offsets, i = this.getDecimalForValue(t);\n            return this.getPixelForDecimal((e.start + i) * e.factor);\n        }\n        getValueForPixel(t) {\n            const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n            return this.min + i * (this.max - this.min);\n        }\n        _getLabelSize(t) {\n            const e = this.options.ticks, i = this.ctx.measureText(t).width, s = $(this.isHorizontal() ? e.maxRotation : e.minRotation), n = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;\n            return {\n                w: i * n + a * o,\n                h: i * o + a * n\n            };\n        }\n        _getLabelCapacity(t) {\n            const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, n = this._tickFormatFunction(t, 0, Bo(this, [\n                t\n            ], this._majorUnit), s), o = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;\n            return a > 0 ? a : 1;\n        }\n        getDataTimestamps() {\n            let t, e, i = this._cache.data || [];\n            if (i.length) return i;\n            const s = this.getMatchingVisibleMetas();\n            if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);\n            for(t = 0, e = s.length; t < e; ++t)i = i.concat(s[t].controller.getAllParsedValues(this));\n            return this._cache.data = this.normalize(i);\n        }\n        getLabelTimestamps() {\n            const t = this._cache.labels || [];\n            let e, i;\n            if (t.length) return t;\n            const s = this.getLabels();\n            for(e = 0, i = s.length; e < i; ++e)t.push(zo(this, s[e]));\n            return this._cache.labels = this._normalized ? t : this.normalize(t);\n        }\n        normalize(t) {\n            return lt(t.sort(Io));\n        }\n    }\n    function No(t, e, i) {\n        let s, n, o, a, r = 0, l = t.length - 1;\n        i ? (e >= t[r].pos && e <= t[l].pos && ({ lo: r, hi: l } = it(t, \"pos\", e)), { pos: s, time: o } = t[r], { pos: n, time: a } = t[l]) : (e >= t[r].time && e <= t[l].time && ({ lo: r, hi: l } = it(t, \"time\", e)), { time: s, pos: o } = t[r], { time: n, pos: a } = t[l]);\n        const h = n - s;\n        return h ? o + (a - o) * (e - s) / h : o;\n    }\n    var Ho = Object.freeze({\n        __proto__: null,\n        CategoryScale: class extends Js {\n            static id = \"category\";\n            static defaults = {\n                ticks: {\n                    callback: go\n                }\n            };\n            constructor(t){\n                super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n            }\n            init(t) {\n                const e = this._addedLabels;\n                if (e.length) {\n                    const t = this.getLabels();\n                    for (const { index: i, label: s } of e)t[i] === s && t.splice(i, 1);\n                    this._addedLabels = [];\n                }\n                super.init(t);\n            }\n            parse(t, e) {\n                if (s(t)) return null;\n                const i = this.getLabels();\n                return ((t, e)=>null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : fo(i, t, l(e, t), this._addedLabels), i.length - 1);\n            }\n            determineDataLimits() {\n                const { minDefined: t, maxDefined: e } = this.getUserBounds();\n                let { min: i, max: s } = this.getMinMax(!0);\n                \"ticks\" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;\n            }\n            buildTicks() {\n                const t = this.min, e = this.max, i = this.options.offset, s = [];\n                let n = this.getLabels();\n                n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);\n                for(let i = t; i <= e; i++)s.push({\n                    value: i\n                });\n                return s;\n            }\n            getLabelForValue(t) {\n                return go.call(this, t);\n            }\n            configure() {\n                super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n            }\n            getPixelForValue(t) {\n                return \"number\" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n            }\n            getPixelForTick(t) {\n                const e = this.ticks;\n                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n            }\n            getValueForPixel(t) {\n                return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n            }\n            getBasePixel() {\n                return this.bottom;\n            }\n        },\n        LinearScale: bo,\n        LogarithmicScale: wo,\n        RadialLinearScale: Lo,\n        TimeScale: Wo,\n        TimeSeriesScale: class extends Wo {\n            static id = \"timeseries\";\n            static defaults = Wo.defaults;\n            constructor(t){\n                super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n            }\n            initOffsets() {\n                const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);\n                this._minPos = No(e, this.min), this._tableRange = No(e, this.max) - this._minPos, super.initOffsets(t);\n            }\n            buildLookupTable(t) {\n                const { min: e, max: i } = this, s = [], n = [];\n                let o, a, r, l, h;\n                for(o = 0, a = t.length; o < a; ++o)l = t[o], l >= e && l <= i && s.push(l);\n                if (s.length < 2) return [\n                    {\n                        time: e,\n                        pos: 0\n                    },\n                    {\n                        time: i,\n                        pos: 1\n                    }\n                ];\n                for(o = 0, a = s.length; o < a; ++o)h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({\n                    time: l,\n                    pos: o / (a - 1)\n                });\n                return n;\n            }\n            _generate() {\n                const t = this.min, e = this.max;\n                let i = super.getDataTimestamps();\n                return i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort((t, e)=>t - e);\n            }\n            _getTimestampsForTable() {\n                let t = this._cache.all || [];\n                if (t.length) return t;\n                const e = this.getDataTimestamps(), i = this.getLabelTimestamps();\n                return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t;\n            }\n            getDecimalForValue(t) {\n                return (No(this._table, t) - this._minPos) / this._tableRange;\n            }\n            getValueForPixel(t) {\n                const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n                return No(this._table, i * this._tableRange + this._minPos, !0);\n            }\n        }\n    });\n    const jo = [\n        \"rgb(54, 162, 235)\",\n        \"rgb(255, 99, 132)\",\n        \"rgb(255, 159, 64)\",\n        \"rgb(255, 205, 86)\",\n        \"rgb(75, 192, 192)\",\n        \"rgb(153, 102, 255)\",\n        \"rgb(201, 203, 207)\"\n    ], $o = jo.map((t)=>t.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\n    function Yo(t) {\n        return jo[t % jo.length];\n    }\n    function Uo(t) {\n        return $o[t % $o.length];\n    }\n    function Xo(t) {\n        let e = 0;\n        return (i, s)=>{\n            const n = t.getDatasetMeta(s).controller;\n            n instanceof Hn ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Yo(e++)), e;\n            }(i, e) : n instanceof jn ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Uo(e++)), e;\n            }(i, e) : n && (e = function(t, e) {\n                return t.borderColor = Yo(e), t.backgroundColor = Uo(e), ++e;\n            }(i, e));\n        };\n    }\n    function qo(t) {\n        let e;\n        for(e in t)if (t[e].borderColor || t[e].backgroundColor) return !0;\n        return !1;\n    }\n    var Ko = {\n        id: \"colors\",\n        defaults: {\n            enabled: !0,\n            forceOverride: !1\n        },\n        beforeLayout (t, e, i) {\n            if (!i.enabled) return;\n            const { data: { datasets: s }, options: n } = t.config, { elements: o } = n;\n            if (!i.forceOverride && (qo(s) || (a = n) && (a.borderColor || a.backgroundColor) || o && qo(o))) return;\n            var a;\n            const r = Xo(t);\n            s.forEach(r);\n        }\n    };\n    function Go(t) {\n        if (t._decimated) {\n            const e = t._data;\n            delete t._decimated, delete t._data, Object.defineProperty(t, \"data\", {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0,\n                value: e\n            });\n        }\n    }\n    function Zo(t) {\n        t.data.datasets.forEach((t)=>{\n            Go(t);\n        });\n    }\n    var Jo = {\n        id: \"decimation\",\n        defaults: {\n            algorithm: \"min-max\",\n            enabled: !1\n        },\n        beforeElementsUpdate: (t, e, i)=>{\n            if (!i.enabled) return void Zo(t);\n            const n = t.width;\n            t.data.datasets.forEach((e, o)=>{\n                const { _data: a, indexAxis: r } = e, l = t.getDatasetMeta(o), h = a || e.data;\n                if (\"y\" === Pi([\n                    r,\n                    t.options.indexAxis\n                ])) return;\n                if (!l.controller.supportsDecimation) return;\n                const c = t.scales[l.xAxisID];\n                if (\"linear\" !== c.type && \"time\" !== c.type) return;\n                if (t.options.parsing) return;\n                let { start: d, count: u } = function(t, e) {\n                    const i = e.length;\n                    let s, n = 0;\n                    const { iScale: o } = t, { min: a, max: r, minDefined: l, maxDefined: h } = o.getUserBounds();\n                    return l && (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n : i - n, {\n                        start: n,\n                        count: s\n                    };\n                }(l, h);\n                if (u <= (i.threshold || 4 * n)) return void Go(e);\n                let f;\n                switch(s(a) && (e._data = h, delete e.data, Object.defineProperty(e, \"data\", {\n                    configurable: !0,\n                    enumerable: !0,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(t) {\n                        this._data = t;\n                    }\n                })), i.algorithm){\n                    case \"lttb\":\n                        f = function(t, e, i, s, n) {\n                            const o = n.samples || s;\n                            if (o >= i) return t.slice(e, e + i);\n                            const a = [], r = (i - 2) / (o - 2);\n                            let l = 0;\n                            const h = e + i - 1;\n                            let c, d, u, f, g, p = e;\n                            for(a[l++] = t[p], c = 0; c < o - 2; c++){\n                                let s, n = 0, o = 0;\n                                const h = Math.floor((c + 1) * r) + 1 + e, m = Math.min(Math.floor((c + 2) * r) + 1, i) + e, b = m - h;\n                                for(s = h; s < m; s++)n += t[s].x, o += t[s].y;\n                                n /= b, o /= b;\n                                const x = Math.floor(c * r) + 1 + e, _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e, { x: y, y: v } = t[p];\n                                for(u = f = -1, s = x; s < _; s++)f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);\n                                a[l++] = d, p = g;\n                            }\n                            return a[l++] = t[h], a;\n                        }(h, d, u, n, i);\n                        break;\n                    case \"min-max\":\n                        f = function(t, e, i, n) {\n                            let o, a, r, l, h, c, d, u, f, g, p = 0, m = 0;\n                            const b = [], x = e + i - 1, _ = t[e].x, y = t[x].x - _;\n                            for(o = e; o < e + i; ++o){\n                                a = t[o], r = (a.x - _) / y * n, l = a.y;\n                                const e = 0 | r;\n                                if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;\n                                else {\n                                    const i = o - 1;\n                                    if (!s(c) && !s(d)) {\n                                        const e = Math.min(c, d), s = Math.max(c, d);\n                                        e !== u && e !== i && b.push({\n                                            ...t[e],\n                                            x: p\n                                        }), s !== u && s !== i && b.push({\n                                            ...t[s],\n                                            x: p\n                                        });\n                                    }\n                                    o > 0 && i !== u && b.push(t[i]), b.push(a), h = e, m = 0, f = g = l, c = d = u = o;\n                                }\n                            }\n                            return b;\n                        }(h, d, u, n);\n                        break;\n                    default:\n                        throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`);\n                }\n                e._decimated = f;\n            });\n        },\n        destroy (t) {\n            Zo(t);\n        }\n    };\n    function Qo(t, e, i, s) {\n        if (s) return;\n        let n = e[t], o = i[t];\n        return \"angle\" === t && (n = G(n), o = G(o)), {\n            property: t,\n            start: n,\n            end: o\n        };\n    }\n    function ta(t, e, i) {\n        for(; e > t; e--){\n            const t = i[e];\n            if (!isNaN(t.x) && !isNaN(t.y)) break;\n        }\n        return e;\n    }\n    function ea(t, e, i, s) {\n        return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;\n    }\n    function ia(t, e) {\n        let i = [], s = !1;\n        return n(t) ? (s = !0, i = t) : i = function(t, e) {\n            const { x: i = null, y: s = null } = t || {}, n = e.points, o = [];\n            return e.segments.forEach(({ start: t, end: e })=>{\n                e = ta(t, e, n);\n                const a = n[t], r = n[e];\n                null !== s ? (o.push({\n                    x: a.x,\n                    y: s\n                }), o.push({\n                    x: r.x,\n                    y: s\n                })) : null !== i && (o.push({\n                    x: i,\n                    y: a.y\n                }), o.push({\n                    x: i,\n                    y: r.y\n                }));\n            }), o;\n        }(t, e), i.length ? new so({\n            points: i,\n            options: {\n                tension: 0\n            },\n            _loop: s,\n            _fullLoop: s\n        }) : null;\n    }\n    function sa(t) {\n        return t && !1 !== t.fill;\n    }\n    function na(t, e, i) {\n        let s = t[e].fill;\n        const n = [\n            e\n        ];\n        let o;\n        if (!i) return s;\n        for(; !1 !== s && -1 === n.indexOf(s);){\n            if (!a(s)) return s;\n            if (o = t[s], !o) return !1;\n            if (o.visible) return s;\n            n.push(s), s = o.fill;\n        }\n        return !1;\n    }\n    function oa(t, e, i) {\n        const s = function(t) {\n            const e = t.options, i = e.fill;\n            let s = l(i && i.target, i);\n            void 0 === s && (s = !!e.backgroundColor);\n            if (!1 === s || null === s) return !1;\n            if (!0 === s) return \"origin\";\n            return s;\n        }(t);\n        if (o(s)) return !isNaN(s.value) && s;\n        let n = parseFloat(s);\n        return a(n) && Math.floor(n) === n ? function(t, e, i, s) {\n            \"-\" !== t && \"+\" !== t || (i = e + i);\n            if (i === e || i < 0 || i >= s) return !1;\n            return i;\n        }(s[0], e, n, i) : [\n            \"origin\",\n            \"start\",\n            \"end\",\n            \"stack\",\n            \"shape\"\n        ].indexOf(s) >= 0 && s;\n    }\n    function aa(t, e, i) {\n        const s = [];\n        for(let n = 0; n < i.length; n++){\n            const o = i[n], { first: a, last: r, point: l } = ra(o, e, \"x\");\n            if (!(!l || a && r)) {\n                if (a) s.unshift(l);\n                else if (t.push(l), !r) break;\n            }\n        }\n        t.push(...s);\n    }\n    function ra(t, e, i) {\n        const s = t.interpolate(e, i);\n        if (!s) return {};\n        const n = s[i], o = t.segments, a = t.points;\n        let r = !1, l = !1;\n        for(let t = 0; t < o.length; t++){\n            const e = o[t], s = a[e.start][i], h = a[e.end][i];\n            if (tt(n, s, h)) {\n                r = n === s, l = n === h;\n                break;\n            }\n        }\n        return {\n            first: r,\n            last: l,\n            point: s\n        };\n    }\n    class la {\n        constructor(t){\n            this.x = t.x, this.y = t.y, this.radius = t.radius;\n        }\n        pathSegment(t, e, i) {\n            const { x: s, y: n, radius: o } = this;\n            return e = e || {\n                start: 0,\n                end: O\n            }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds;\n        }\n        interpolate(t) {\n            const { x: e, y: i, radius: s } = this, n = t.angle;\n            return {\n                x: e + Math.cos(n) * s,\n                y: i + Math.sin(n) * s,\n                angle: n\n            };\n        }\n    }\n    function ha(t) {\n        const { chart: e, fill: i, line: s } = t;\n        if (a(i)) return function(t, e) {\n            const i = t.getDatasetMeta(e), s = i && t.isDatasetVisible(e);\n            return s ? i.dataset : null;\n        }(e, i);\n        if (\"stack\" === i) return function(t) {\n            const { scale: e, index: i, line: s } = t, n = [], o = s.segments, a = s.points, r = function(t, e) {\n                const i = [], s = t.getMatchingVisibleMetas(\"line\");\n                for(let t = 0; t < s.length; t++){\n                    const n = s[t];\n                    if (n.index === e) break;\n                    n.hidden || i.unshift(n.dataset);\n                }\n                return i;\n            }(e, i);\n            r.push(ia({\n                x: null,\n                y: e.bottom\n            }, s));\n            for(let t = 0; t < o.length; t++){\n                const e = o[t];\n                for(let t = e.start; t <= e.end; t++)aa(n, a[t], r);\n            }\n            return new so({\n                points: n,\n                options: {}\n            });\n        }(t);\n        if (\"shape\" === i) return !0;\n        const n = function(t) {\n            const e = t.scale || {};\n            if (e.getPointPositionForValue) return function(t) {\n                const { scale: e, fill: i } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function(t, e, i) {\n                    let s;\n                    return s = \"start\" === t ? i : \"end\" === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s;\n                }(i, e, a), l = [];\n                if (s.grid.circular) {\n                    const t = e.getPointPositionForValue(0, a);\n                    return new la({\n                        x: t.x,\n                        y: t.y,\n                        radius: e.getDistanceFromCenterForValue(r)\n                    });\n                }\n                for(let t = 0; t < n; ++t)l.push(e.getPointPositionForValue(t, r));\n                return l;\n            }(t);\n            return function(t) {\n                const { scale: e = {}, fill: i } = t, s = function(t, e) {\n                    let i = null;\n                    return \"start\" === t ? i = e.bottom : \"end\" === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;\n                }(i, e);\n                if (a(s)) {\n                    const t = e.isHorizontal();\n                    return {\n                        x: t ? s : null,\n                        y: t ? null : s\n                    };\n                }\n                return null;\n            }(t);\n        }(t);\n        return n instanceof la ? n : ia(n, s);\n    }\n    function ca(t, e, i) {\n        const s = ha(e), { line: n, scale: o, axis: a } = e, r = n.options, l = r.fill, h = r.backgroundColor, { above: c = h, below: d = h } = l || {};\n        s && n.points.length && (Ie(t, i), function(t, e) {\n            const { line: i, target: s, above: n, below: o, area: a, scale: r } = e, l = i._loop ? \"angle\" : e.axis;\n            t.save(), \"x\" === l && o !== n && (da(t, s, a.top), ua(t, {\n                line: i,\n                target: s,\n                color: n,\n                scale: r,\n                property: l\n            }), t.restore(), t.save(), da(t, s, a.bottom));\n            ua(t, {\n                line: i,\n                target: s,\n                color: o,\n                scale: r,\n                property: l\n            }), t.restore();\n        }(t, {\n            line: n,\n            target: s,\n            above: c,\n            below: d,\n            area: i,\n            scale: o,\n            axis: a\n        }), ze(t));\n    }\n    function da(t, e, i) {\n        const { segments: s, points: n } = e;\n        let o = !0, a = !1;\n        t.beginPath();\n        for (const r of s){\n            const { start: s, end: l } = r, h = n[s], c = n[ta(s, l, n)];\n            o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {\n                move: a\n            }), a ? t.closePath() : t.lineTo(c.x, i);\n        }\n        t.lineTo(e.first().x, i), t.closePath(), t.clip();\n    }\n    function ua(t, e) {\n        const { line: i, target: s, property: n, color: o, scale: a } = e, r = function(t, e, i) {\n            const s = t.segments, n = t.points, o = e.points, a = [];\n            for (const t of s){\n                let { start: s, end: r } = t;\n                r = ta(s, r, n);\n                const l = Qo(i, n[s], n[r], t.loop);\n                if (!e.segments) {\n                    a.push({\n                        source: t,\n                        target: l,\n                        start: n[s],\n                        end: n[r]\n                    });\n                    continue;\n                }\n                const h = Ii(e, l);\n                for (const e of h){\n                    const s = Qo(i, o[e.start], o[e.end], e.loop), r = Ri(t, n, s);\n                    for (const t of r)a.push({\n                        source: t,\n                        target: e,\n                        start: {\n                            [i]: ea(l, s, \"start\", Math.max)\n                        },\n                        end: {\n                            [i]: ea(l, s, \"end\", Math.min)\n                        }\n                    });\n                }\n            }\n            return a;\n        }(i, s, n);\n        for (const { source: e, target: l, start: h, end: c } of r){\n            const { style: { backgroundColor: r = o } = {} } = e, d = !0 !== s;\n            t.save(), t.fillStyle = r, fa(t, a, d && Qo(n, h, c)), t.beginPath();\n            const u = !!i.pathSegment(t, e);\n            let f;\n            if (d) {\n                u ? t.closePath() : ga(t, s, c, n);\n                const e = !!s.pathSegment(t, l, {\n                    move: u,\n                    reverse: !0\n                });\n                f = u && e, f || ga(t, s, h, n);\n            }\n            t.closePath(), t.fill(f ? \"evenodd\" : \"nonzero\"), t.restore();\n        }\n    }\n    function fa(t, e, i) {\n        const { top: s, bottom: n } = e.chart.chartArea, { property: o, start: a, end: r } = i || {};\n        \"x\" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip());\n    }\n    function ga(t, e, i, s) {\n        const n = e.interpolate(i, s);\n        n && t.lineTo(n.x, n.y);\n    }\n    var pa = {\n        id: \"filler\",\n        afterDatasetsUpdate (t, e, i) {\n            const s = (t.data.datasets || []).length, n = [];\n            let o, a, r, l;\n            for(a = 0; a < s; ++a)o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof so && (l = {\n                visible: t.isDatasetVisible(a),\n                index: a,\n                fill: oa(r, a, s),\n                chart: t,\n                axis: o.controller.options.indexAxis,\n                scale: o.vScale,\n                line: r\n            }), o.$filler = l, n.push(l);\n            for(a = 0; a < s; ++a)l = n[a], l && !1 !== l.fill && (l.fill = na(n, a, i.propagate));\n        },\n        beforeDraw (t, e, i) {\n            const s = \"beforeDraw\" === i.drawTime, n = t.getSortedVisibleDatasetMetas(), o = t.chartArea;\n            for(let e = n.length - 1; e >= 0; --e){\n                const i = n[e].$filler;\n                i && (i.line.updateControlPoints(o, i.axis), s && i.fill && ca(t.ctx, i, o));\n            }\n        },\n        beforeDatasetsDraw (t, e, i) {\n            if (\"beforeDatasetsDraw\" !== i.drawTime) return;\n            const s = t.getSortedVisibleDatasetMetas();\n            for(let e = s.length - 1; e >= 0; --e){\n                const i = s[e].$filler;\n                sa(i) && ca(t.ctx, i, t.chartArea);\n            }\n        },\n        beforeDatasetDraw (t, e, i) {\n            const s = e.meta.$filler;\n            sa(s) && \"beforeDatasetDraw\" === i.drawTime && ca(t.ctx, s, t.chartArea);\n        },\n        defaults: {\n            propagate: !0,\n            drawTime: \"beforeDatasetDraw\"\n        }\n    };\n    const ma = (t, e)=>{\n        let { boxHeight: i = e, boxWidth: s = e } = t;\n        return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {\n            boxWidth: s,\n            boxHeight: i,\n            itemHeight: Math.max(e, i)\n        };\n    };\n    class ba extends Hs {\n        constructor(t){\n            super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e, i) {\n            this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n        }\n        buildLabels() {\n            const t = this.options.labels || {};\n            let e = d(t.generateLabels, [\n                this.chart\n            ], this) || [];\n            t.filter && (e = e.filter((e)=>t.filter(e, this.chart.data))), t.sort && (e = e.sort((e, i)=>t.sort(e, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n        }\n        fit() {\n            const { options: t, ctx: e } = this;\n            if (!t.display) return void (this.width = this.height = 0);\n            const i = t.labels, s = Si(i.font), n = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: r } = ma(i, n);\n            let l, h;\n            e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n        }\n        _fitRows(t, e, i, s) {\n            const { ctx: n, maxWidth: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [\n                0\n            ], h = s + a;\n            let c = t;\n            n.textAlign = \"left\", n.textBaseline = \"middle\";\n            let d = -1, u = -h;\n            return this.legendItems.forEach((t, f)=>{\n                const g = i + e / 2 + n.measureText(t.text).width;\n                (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {\n                    left: 0,\n                    top: u,\n                    row: d,\n                    width: g,\n                    height: s\n                }, l[l.length - 1] += g + a;\n            }), c;\n        }\n        _fitCols(t, e, i, s) {\n            const { ctx: n, maxHeight: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;\n            let c = a, d = 0, u = 0, f = 0, g = 0;\n            return this.legendItems.forEach((t, o)=>{\n                const { itemWidth: p, itemHeight: m } = function(t, e, i, s, n) {\n                    const o = function(t, e, i, s) {\n                        let n = t.text;\n                        n && \"string\" != typeof n && (n = n.reduce((t, e)=>t.length > e.length ? t : e));\n                        return e + i.size / 2 + s.measureText(n).width;\n                    }(s, t, e, i), a = function(t, e, i) {\n                        let s = t;\n                        \"string\" != typeof e.text && (s = xa(e, i));\n                        return s;\n                    }(n, s, e.lineHeight);\n                    return {\n                        itemWidth: o,\n                        itemHeight: a\n                    };\n                }(i, e, n, t, s);\n                o > 0 && u + m + 2 * a > h && (c += d + a, l.push({\n                    width: d,\n                    height: u\n                }), f += d + a, g++, d = u = 0), r[o] = {\n                    left: f,\n                    top: u,\n                    col: g,\n                    width: p,\n                    height: m\n                }, d = Math.max(d, p), u += m + a;\n            }), c += d, l.push({\n                width: d,\n                height: u\n            }), c;\n        }\n        adjustHitBoxes() {\n            if (!this.options.display) return;\n            const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: n } } = this, o = Oi(n, this.left, this.width);\n            if (this.isHorizontal()) {\n                let n = 0, a = ft(i, this.left + s, this.right - this.lineWidths[n]);\n                for (const r of e)n !== r.row && (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s;\n            } else {\n                let n = 0, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height);\n                for (const r of e)r.col !== n && (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s;\n            }\n        }\n        isHorizontal() {\n            return \"top\" === this.options.position || \"bottom\" === this.options.position;\n        }\n        draw() {\n            if (this.options.display) {\n                const t = this.ctx;\n                Ie(t, this), this._draw(), ze(t);\n            }\n        }\n        _draw() {\n            const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: n, labels: o } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), { padding: c } = o, d = h.size, u = d / 2;\n            let f;\n            this.drawTitle(), s.textAlign = r.textAlign(\"left\"), s.textBaseline = \"middle\", s.lineWidth = .5, s.font = h.string;\n            const { boxWidth: g, boxHeight: p, itemHeight: m } = ma(o, d), b = this.isHorizontal(), x = this._computeTitleHeight();\n            f = b ? {\n                x: ft(n, this.left + c, this.right - i[0]),\n                y: this.top + c + x,\n                line: 0\n            } : {\n                x: this.left + c,\n                y: ft(n, this.top + x + c, this.bottom - e[0].height),\n                line: 0\n            }, Ai(this.ctx, t.textDirection);\n            const _ = m + c;\n            this.legendItems.forEach((y, v)=>{\n                s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor;\n                const M = s.measureText(y.text).width, w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)), k = g + u + M;\n                let S = f.x, P = f.y;\n                r.setWidth(this.width), b ? v > 0 && S + k + c > this.right && (P = f.y += _, f.line++, S = f.x = ft(n, this.left + c, this.right - i[f.line])) : v > 0 && P + _ > this.bottom && (S = f.x = S + e[f.line].width + c, f.line++, P = f.y = ft(n, this.top + x + c, this.bottom - e[f.line].height));\n                if (function(t, e, i) {\n                    if (isNaN(g) || g <= 0 || isNaN(p) || p < 0) return;\n                    s.save();\n                    const n = l(i.lineWidth, 1);\n                    if (s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, \"butt\"), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, \"miter\"), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle) {\n                        const a = {\n                            radius: p * Math.SQRT2 / 2,\n                            pointStyle: i.pointStyle,\n                            rotation: i.rotation,\n                            borderWidth: n\n                        }, l = r.xPlus(t, g / 2);\n                        Ee(s, a, l, e + u, o.pointStyleWidth && g);\n                    } else {\n                        const o = e + Math.max((d - p) / 2, 0), a = r.leftForLtr(t, g), l = wi(i.borderRadius);\n                        s.beginPath(), Object.values(l).some((t)=>0 !== t) ? He(s, {\n                            x: a,\n                            y: o,\n                            w: g,\n                            h: p,\n                            radius: l\n                        }) : s.rect(a, o, g, p), s.fill(), 0 !== n && s.stroke();\n                    }\n                    s.restore();\n                }(r.x(S), P, y), S = gt(w, S + g + u, b ? S + k : this.right, t.rtl), function(t, e, i) {\n                    Ne(s, i.text, t, e + m / 2, h, {\n                        strikethrough: i.hidden,\n                        textAlign: r.textAlign(i.textAlign)\n                    });\n                }(r.x(S), P, y), b) f.x += k + c;\n                else if (\"string\" != typeof y.text) {\n                    const t = h.lineHeight;\n                    f.y += xa(y, t) + c;\n                } else f.y += _;\n            }), Ti(this.ctx, t.textDirection);\n        }\n        drawTitle() {\n            const t = this.options, e = t.title, i = Si(e.font), s = ki(e.padding);\n            if (!e.display) return;\n            const n = Oi(t.rtl, this.left, this.width), o = this.ctx, a = e.position, r = i.size / 2, l = s.top + r;\n            let h, c = this.left, d = this.width;\n            if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);\n            else {\n                const e = this.columnSizes.reduce((t, e)=>Math.max(t, e.height), 0);\n                h = l + ft(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight());\n            }\n            const u = ft(a, c, c + d);\n            o.textAlign = n.textAlign(ut(a)), o.textBaseline = \"middle\", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i);\n        }\n        _computeTitleHeight() {\n            const t = this.options.title, e = Si(t.font), i = ki(t.padding);\n            return t.display ? e.lineHeight + i.height : 0;\n        }\n        _getLegendItemAt(t, e) {\n            let i, s, n;\n            if (tt(t, this.left, this.right) && tt(e, this.top, this.bottom)) {\n                for(n = this.legendHitBoxes, i = 0; i < n.length; ++i)if (s = n[i], tt(t, s.left, s.left + s.width) && tt(e, s.top, s.top + s.height)) return this.legendItems[i];\n            }\n            return null;\n        }\n        handleEvent(t) {\n            const e = this.options;\n            if (!function(t, e) {\n                if ((\"mousemove\" === t || \"mouseout\" === t) && (e.onHover || e.onLeave)) return !0;\n                if (e.onClick && (\"click\" === t || \"mouseup\" === t)) return !0;\n                return !1;\n            }(t.type, e)) return;\n            const i = this._getLegendItemAt(t.x, t.y);\n            if (\"mousemove\" === t.type || \"mouseout\" === t.type) {\n                const o = this._hoveredItem, a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);\n                o && !a && d(e.onLeave, [\n                    t,\n                    o,\n                    this\n                ], this), this._hoveredItem = i, i && !a && d(e.onHover, [\n                    t,\n                    i,\n                    this\n                ], this);\n            } else i && d(e.onClick, [\n                t,\n                i,\n                this\n            ], this);\n            var s, n;\n        }\n    }\n    function xa(t, e) {\n        return e * (t.text ? t.text.length : 0);\n    }\n    var _a = {\n        id: \"legend\",\n        _element: ba,\n        start (t, e, i) {\n            const s = t.legend = new ba({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, t.legend), delete t.legend;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.legend;\n            as.configure(t, s, i), s.options = i;\n        },\n        afterUpdate (t) {\n            const e = t.legend;\n            e.buildLabels(), e.adjustHitBoxes();\n        },\n        afterEvent (t, e) {\n            e.replay || t.legend.handleEvent(e.event);\n        },\n        defaults: {\n            display: !0,\n            position: \"top\",\n            align: \"center\",\n            fullSize: !0,\n            reverse: !1,\n            weight: 1e3,\n            onClick (t, e, i) {\n                const s = e.datasetIndex, n = i.chart;\n                n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1);\n            },\n            onHover: null,\n            onLeave: null,\n            labels: {\n                color: (t)=>t.chart.options.color,\n                boxWidth: 40,\n                padding: 10,\n                generateLabels (t) {\n                    const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: s, textAlign: n, color: o, useBorderRadius: a, borderRadius: r } } = t.legend.options;\n                    return t._getSortedDatasetMetas().map((t)=>{\n                        const l = t.controller.getStyle(i ? 0 : void 0), h = ki(l.borderWidth);\n                        return {\n                            text: e[t.index].label,\n                            fillStyle: l.backgroundColor,\n                            fontColor: o,\n                            hidden: !t.visible,\n                            lineCap: l.borderCapStyle,\n                            lineDash: l.borderDash,\n                            lineDashOffset: l.borderDashOffset,\n                            lineJoin: l.borderJoinStyle,\n                            lineWidth: (h.width + h.height) / 4,\n                            strokeStyle: l.borderColor,\n                            pointStyle: s || l.pointStyle,\n                            rotation: l.rotation,\n                            textAlign: n || l.textAlign,\n                            borderRadius: a && (r || l.borderRadius),\n                            datasetIndex: t.index\n                        };\n                    }, this);\n                }\n            },\n            title: {\n                color: (t)=>t.chart.options.color,\n                display: !1,\n                position: \"center\",\n                text: \"\"\n            }\n        },\n        descriptors: {\n            _scriptable: (t)=>!t.startsWith(\"on\"),\n            labels: {\n                _scriptable: (t)=>![\n                        \"generateLabels\",\n                        \"filter\",\n                        \"sort\"\n                    ].includes(t)\n            }\n        }\n    };\n    class ya extends Hs {\n        constructor(t){\n            super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e) {\n            const i = this.options;\n            if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0);\n            this.width = this.right = t, this.height = this.bottom = e;\n            const s = n(i.text) ? i.text.length : 1;\n            this._padding = ki(i.padding);\n            const o = s * Si(i.font).lineHeight + this._padding.height;\n            this.isHorizontal() ? this.height = o : this.width = o;\n        }\n        isHorizontal() {\n            const t = this.options.position;\n            return \"top\" === t || \"bottom\" === t;\n        }\n        _drawArgs(t) {\n            const { top: e, left: i, bottom: s, right: n, options: o } = this, a = o.align;\n            let r, l, h, c = 0;\n            return this.isHorizontal() ? (l = ft(a, i, n), h = e + t, r = n - i) : (\"left\" === o.position ? (l = i + t, h = ft(a, s, e), c = -0.5 * C) : (l = n - t, h = ft(a, e, s), c = .5 * C), r = s - e), {\n                titleX: l,\n                titleY: h,\n                maxWidth: r,\n                rotation: c\n            };\n        }\n        draw() {\n            const t = this.ctx, e = this.options;\n            if (!e.display) return;\n            const i = Si(e.font), s = i.lineHeight / 2 + this._padding.top, { titleX: n, titleY: o, maxWidth: a, rotation: r } = this._drawArgs(s);\n            Ne(t, e.text, 0, 0, i, {\n                color: e.color,\n                maxWidth: a,\n                rotation: r,\n                textAlign: ut(e.align),\n                textBaseline: \"middle\",\n                translation: [\n                    n,\n                    o\n                ]\n            });\n        }\n    }\n    var va = {\n        id: \"title\",\n        _element: ya,\n        start (t, e, i) {\n            !function(t, e) {\n                const i = new ya({\n                    ctx: t.ctx,\n                    options: e,\n                    chart: t\n                });\n                as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i;\n            }(t, i);\n        },\n        stop (t) {\n            const e = t.titleBlock;\n            as.removeBox(t, e), delete t.titleBlock;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.titleBlock;\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"bold\"\n            },\n            fullSize: !0,\n            padding: 10,\n            position: \"top\",\n            text: \"\",\n            weight: 2e3\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const Ma = new WeakMap;\n    var wa = {\n        id: \"subtitle\",\n        start (t, e, i) {\n            const s = new ya({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s), Ma.set(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, Ma.get(t)), Ma.delete(t);\n        },\n        beforeUpdate (t, e, i) {\n            const s = Ma.get(t);\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"normal\"\n            },\n            fullSize: !0,\n            padding: 0,\n            position: \"top\",\n            text: \"\",\n            weight: 1500\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const ka = {\n        average (t) {\n            if (!t.length) return !1;\n            let e, i, s = 0, n = 0, o = 0;\n            for(e = 0, i = t.length; e < i; ++e){\n                const i = t[e].element;\n                if (i && i.hasValue()) {\n                    const t = i.tooltipPosition();\n                    s += t.x, n += t.y, ++o;\n                }\n            }\n            return {\n                x: s / o,\n                y: n / o\n            };\n        },\n        nearest (t, e) {\n            if (!t.length) return !1;\n            let i, s, n, o = e.x, a = e.y, r = Number.POSITIVE_INFINITY;\n            for(i = 0, s = t.length; i < s; ++i){\n                const s = t[i].element;\n                if (s && s.hasValue()) {\n                    const t = q(e, s.getCenterPoint());\n                    t < r && (r = t, n = s);\n                }\n            }\n            if (n) {\n                const t = n.tooltipPosition();\n                o = t.x, a = t.y;\n            }\n            return {\n                x: o,\n                y: a\n            };\n        }\n    };\n    function Sa(t, e) {\n        return e && (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;\n    }\n    function Pa(t) {\n        return (\"string\" == typeof t || t instanceof String) && t.indexOf(\"\\n\") > -1 ? t.split(\"\\n\") : t;\n    }\n    function Da(t, e) {\n        const { element: i, datasetIndex: s, index: n } = e, o = t.getDatasetMeta(s).controller, { label: a, value: r } = o.getLabelAndValue(n);\n        return {\n            chart: t,\n            label: a,\n            parsed: o.getParsed(n),\n            raw: t.data.datasets[s].data[n],\n            formattedValue: r,\n            dataset: o.getDataset(),\n            dataIndex: n,\n            datasetIndex: s,\n            element: i\n        };\n    }\n    function Ca(t, e) {\n        const i = t.chart.ctx, { body: s, footer: n, title: o } = t, { boxWidth: a, boxHeight: r } = e, l = Si(e.bodyFont), h = Si(e.titleFont), c = Si(e.footerFont), d = o.length, f = n.length, g = s.length, p = ki(e.padding);\n        let m = p.height, b = 0, x = s.reduce((t, e)=>t + e.before.length + e.lines.length + e.after.length, 0);\n        if (x += t.beforeBody.length + t.afterBody.length, d && (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), x) m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (x - g) * l.lineHeight + (x - 1) * e.bodySpacing;\n        f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);\n        let _ = 0;\n        const y = function(t) {\n            b = Math.max(b, i.measureText(t).width + _);\n        };\n        return i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t)=>{\n            u(t.before, y), u(t.lines, y), u(t.after, y);\n        }), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), b += p.width, {\n            width: b,\n            height: m\n        };\n    }\n    function Oa(t, e, i, s) {\n        const { x: n, width: o } = i, { width: a, chartArea: { left: r, right: l } } = t;\n        let h = \"center\";\n        return \"center\" === s ? h = n <= (r + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? h = \"left\" : n >= a - o / 2 && (h = \"right\"), function(t, e, i, s) {\n            const { x: n, width: o } = s, a = i.caretSize + i.caretPadding;\n            return \"left\" === t && n + o + a > e.width || \"right\" === t && n - o - a < 0 || void 0;\n        }(h, t, e, i) && (h = \"center\"), h;\n    }\n    function Aa(t, e, i) {\n        const s = i.yAlign || e.yAlign || function(t, e) {\n            const { y: i, height: s } = e;\n            return i < s / 2 ? \"top\" : i > t.height - s / 2 ? \"bottom\" : \"center\";\n        }(t, i);\n        return {\n            xAlign: i.xAlign || e.xAlign || Oa(t, e, i, s),\n            yAlign: s\n        };\n    }\n    function Ta(t, e, i, s) {\n        const { caretSize: n, caretPadding: o, cornerRadius: a } = t, { xAlign: r, yAlign: l } = i, h = n + o, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(a);\n        let g = function(t, e) {\n            let { x: i, width: s } = t;\n            return \"right\" === e ? i -= s : \"center\" === e && (i -= s / 2), i;\n        }(e, r);\n        const p = function(t, e, i) {\n            let { y: s, height: n } = t;\n            return \"top\" === e ? s += i : s -= \"bottom\" === e ? n + i : n / 2, s;\n        }(e, l, h);\n        return \"center\" === l ? \"left\" === r ? g += h : \"right\" === r && (g -= h) : \"left\" === r ? g -= Math.max(c, u) + n : \"right\" === r && (g += Math.max(d, f) + n), {\n            x: J(g, 0, s.width - e.width),\n            y: J(p, 0, s.height - e.height)\n        };\n    }\n    function La(t, e, i) {\n        const s = ki(i.padding);\n        return \"center\" === e ? t.x + t.width / 2 : \"right\" === e ? t.x + t.width - s.right : t.x + s.left;\n    }\n    function Ea(t) {\n        return Sa([], Pa(t));\n    }\n    function Ra(t, e) {\n        const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;\n        return i ? t.override(i) : t;\n    }\n    const Ia = {\n        beforeTitle: e,\n        title (t) {\n            if (t.length > 0) {\n                const e = t[0], i = e.chart.data.labels, s = i ? i.length : 0;\n                if (this && this.options && \"dataset\" === this.options.mode) return e.dataset.label || \"\";\n                if (e.label) return e.label;\n                if (s > 0 && e.dataIndex < s) return i[e.dataIndex];\n            }\n            return \"\";\n        },\n        afterTitle: e,\n        beforeBody: e,\n        beforeLabel: e,\n        label (t) {\n            if (this && this.options && \"dataset\" === this.options.mode) return t.label + \": \" + t.formattedValue || t.formattedValue;\n            let e = t.dataset.label || \"\";\n            e && (e += \": \");\n            const i = t.formattedValue;\n            return s(i) || (e += i), e;\n        },\n        labelColor (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                borderColor: e.borderColor,\n                backgroundColor: e.backgroundColor,\n                borderWidth: e.borderWidth,\n                borderDash: e.borderDash,\n                borderDashOffset: e.borderDashOffset,\n                borderRadius: 0\n            };\n        },\n        labelTextColor () {\n            return this.options.bodyColor;\n        },\n        labelPointStyle (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                pointStyle: e.pointStyle,\n                rotation: e.rotation\n            };\n        },\n        afterLabel: e,\n        afterBody: e,\n        beforeFooter: e,\n        footer: e,\n        afterFooter: e\n    };\n    function za(t, e, i, s) {\n        const n = t[e].call(i, s);\n        return void 0 === n ? Ia[e].call(i, s) : n;\n    }\n    class Fa extends Hs {\n        static positioners = ka;\n        constructor(t){\n            super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n        }\n        initialize(t) {\n            this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n        }\n        _resolveAnimations() {\n            const t = this._cachedAnimations;\n            if (t) return t;\n            const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, n = new Os(this.chart, s);\n            return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n;\n        }\n        getContext() {\n            var t, e, i;\n            return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ci(t, {\n                tooltip: e,\n                tooltipItems: i,\n                type: \"tooltip\"\n            })));\n        }\n        getTitle(t, e) {\n            const { callbacks: i } = e, s = za(i, \"beforeTitle\", this, t), n = za(i, \"title\", this, t), o = za(i, \"afterTitle\", this, t);\n            let a = [];\n            return a = Sa(a, Pa(s)), a = Sa(a, Pa(n)), a = Sa(a, Pa(o)), a;\n        }\n        getBeforeBody(t, e) {\n            return Ea(za(e.callbacks, \"beforeBody\", this, t));\n        }\n        getBody(t, e) {\n            const { callbacks: i } = e, s = [];\n            return u(t, (t)=>{\n                const e = {\n                    before: [],\n                    lines: [],\n                    after: []\n                }, n = Ra(i, t);\n                Sa(e.before, Pa(za(n, \"beforeLabel\", this, t))), Sa(e.lines, za(n, \"label\", this, t)), Sa(e.after, Pa(za(n, \"afterLabel\", this, t))), s.push(e);\n            }), s;\n        }\n        getAfterBody(t, e) {\n            return Ea(za(e.callbacks, \"afterBody\", this, t));\n        }\n        getFooter(t, e) {\n            const { callbacks: i } = e, s = za(i, \"beforeFooter\", this, t), n = za(i, \"footer\", this, t), o = za(i, \"afterFooter\", this, t);\n            let a = [];\n            return a = Sa(a, Pa(s)), a = Sa(a, Pa(n)), a = Sa(a, Pa(o)), a;\n        }\n        _createItems(t) {\n            const e = this._active, i = this.chart.data, s = [], n = [], o = [];\n            let a, r, l = [];\n            for(a = 0, r = e.length; a < r; ++a)l.push(Da(this.chart, e[a]));\n            return t.filter && (l = l.filter((e, s, n)=>t.filter(e, s, n, i))), t.itemSort && (l = l.sort((e, s)=>t.itemSort(e, s, i))), u(l, (e)=>{\n                const i = Ra(t.callbacks, e);\n                s.push(za(i, \"labelColor\", this, e)), n.push(za(i, \"labelPointStyle\", this, e)), o.push(za(i, \"labelTextColor\", this, e));\n            }), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l;\n        }\n        update(t, e) {\n            const i = this.options.setContext(this.getContext()), s = this._active;\n            let n, o = [];\n            if (s.length) {\n                const t = ka[i.position].call(this, s, this._eventPosition);\n                o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);\n                const e = this._size = Ca(this, i), a = Object.assign({}, t, e), r = Aa(this.chart, i, a), l = Ta(i, a, r, this.chart);\n                this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {\n                    opacity: 1,\n                    x: l.x,\n                    y: l.y,\n                    width: e.width,\n                    height: e.height,\n                    caretX: t.x,\n                    caretY: t.y\n                };\n            } else 0 !== this.opacity && (n = {\n                opacity: 0\n            });\n            this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay: e\n            });\n        }\n        drawCaret(t, e, i, s) {\n            const n = this.getCaretPosition(t, i, s);\n            e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);\n        }\n        getCaretPosition(t, e, i) {\n            const { xAlign: s, yAlign: n } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: r, topRight: l, bottomLeft: h, bottomRight: c } = wi(a), { x: d, y: u } = t, { width: f, height: g } = e;\n            let p, m, b, x, _, y;\n            return \"center\" === n ? (_ = u + g / 2, \"left\" === s ? (p = d, m = p - o, x = _ + o, y = _ - o) : (p = d + f, m = p + o, x = _ - o, y = _ + o), b = p) : (m = \"left\" === s ? d + Math.max(r, h) + o : \"right\" === s ? d + f - Math.max(l, c) - o : this.caretX, \"top\" === n ? (x = u, _ = x - o, p = m - o, b = m + o) : (x = u + g, _ = x + o, p = m + o, b = m - o), y = x), {\n                x1: p,\n                x2: m,\n                x3: b,\n                y1: x,\n                y2: _,\n                y3: y\n            };\n        }\n        drawTitle(t, e, i) {\n            const s = this.title, n = s.length;\n            let o, a, r;\n            if (n) {\n                const l = Oi(i.rtl, this.x, this.width);\n                for(t.x = La(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = \"middle\", o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r)e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a);\n            }\n        }\n        _drawColorBox(t, e, i, s, n) {\n            const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: h } = n, c = Si(n.bodyFont), d = La(this, \"left\", n), u = s.x(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = e.y + f;\n            if (n.usePointStyle) {\n                const e = {\n                    radius: Math.min(h, l) / 2,\n                    pointStyle: r.pointStyle,\n                    rotation: r.rotation,\n                    borderWidth: 1\n                }, i = s.leftForLtr(u, h) + h / 2, o = g + l / 2;\n                t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o);\n            } else {\n                t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;\n                const e = s.leftForLtr(u, h), i = s.leftForLtr(s.xPlus(u, 1), h - 2), r = wi(a.borderRadius);\n                Object.values(r).some((t)=>0 !== t) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, {\n                    x: e,\n                    y: g,\n                    w: h,\n                    h: l,\n                    radius: r\n                }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, {\n                    x: i,\n                    y: g + 1,\n                    w: h - 2,\n                    h: l - 2,\n                    radius: r\n                }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2));\n            }\n            t.fillStyle = this.labelTextColors[i];\n        }\n        drawBody(t, e, i) {\n            const { body: s } = this, { bodySpacing: n, bodyAlign: o, displayColors: a, boxHeight: r, boxWidth: l, boxPadding: h } = i, c = Si(i.bodyFont);\n            let d = c.lineHeight, f = 0;\n            const g = Oi(i.rtl, this.x, this.width), p = function(i) {\n                e.fillText(i, g.x(t.x + f), t.y + d / 2), t.y += d + n;\n            }, m = g.textAlign(o);\n            let b, x, _, y, v, M, w;\n            for(e.textAlign = o, e.textBaseline = \"middle\", e.font = c.string, t.x = La(this, m, i), e.fillStyle = i.bodyColor, u(this.beforeBody, p), f = a && \"right\" !== m ? \"center\" === o ? l / 2 + h : l + 2 + h : 0, y = 0, M = s.length; y < M; ++y){\n                for(b = s[y], x = this.labelTextColors[y], e.fillStyle = x, u(b.before, p), _ = b.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.length; v < w; ++v)p(_[v]), d = c.lineHeight;\n                u(b.after, p);\n            }\n            f = 0, d = c.lineHeight, u(this.afterBody, p), t.y -= n;\n        }\n        drawFooter(t, e, i) {\n            const s = this.footer, n = s.length;\n            let o, a;\n            if (n) {\n                const r = Oi(i.rtl, this.x, this.width);\n                for(t.x = La(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = \"middle\", o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a)e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;\n            }\n        }\n        drawBackground(t, e, i, s) {\n            const { xAlign: n, yAlign: o } = this, { x: a, y: r } = t, { width: l, height: h } = i, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(s.cornerRadius);\n            e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), \"top\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), \"center\" === o && \"right\" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), \"bottom\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), \"center\" === o && \"left\" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();\n        }\n        _updateAnimationTarget(t) {\n            const e = this.chart, i = this.$animations, s = i && i.x, n = i && i.y;\n            if (s || n) {\n                const i = ka[t.position].call(this, this._active, this._eventPosition);\n                if (!i) return;\n                const o = this._size = Ca(this, t), a = Object.assign({}, i, this._size), r = Aa(e, t, a), l = Ta(t, a, r, e);\n                s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l));\n            }\n        }\n        _willRender() {\n            return !!this.opacity;\n        }\n        draw(t) {\n            const e = this.options.setContext(this.getContext());\n            let i = this.opacity;\n            if (!i) return;\n            this._updateAnimationTarget(e);\n            const s = {\n                width: this.width,\n                height: this.height\n            }, n = {\n                x: this.x,\n                y: this.y\n            };\n            i = Math.abs(i) < .001 ? 0 : i;\n            const o = ki(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n            e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore());\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t, e) {\n            const i = this._active, s = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.chart.getDatasetMeta(t);\n                if (!i) throw new Error(\"Cannot find a dataset at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            }), n = !f(i, s), o = this._positionChanged(s, e);\n            (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n        }\n        handleEvent(t, e, i = !0) {\n            if (e && this._ignoreReplayEvents) return !1;\n            this._ignoreReplayEvents = !1;\n            const s = this.options, n = this._active || [], o = this._getActiveElements(t, n, e, i), a = this._positionChanged(o, t), r = e || !f(o, n) || a;\n            return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {\n                x: t.x,\n                y: t.y\n            }, this.update(!0, e))), r;\n        }\n        _getActiveElements(t, e, i, s) {\n            const n = this.options;\n            if (\"mouseout\" === t.type) return [];\n            if (!s) return e;\n            const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);\n            return n.reverse && o.reverse(), o;\n        }\n        _positionChanged(t, e) {\n            const { caretX: i, caretY: s, options: n } = this, o = ka[n.position].call(this, t, e);\n            return !1 !== o && (i !== o.x || s !== o.y);\n        }\n    }\n    var Va = {\n        id: \"tooltip\",\n        _element: Fa,\n        positioners: ka,\n        afterInit (t, e, i) {\n            i && (t.tooltip = new Fa({\n                chart: t,\n                options: i\n            }));\n        },\n        beforeUpdate (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        reset (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        afterDraw (t) {\n            const e = t.tooltip;\n            if (e && e._willRender()) {\n                const i = {\n                    tooltip: e\n                };\n                if (!1 === t.notifyPlugins(\"beforeTooltipDraw\", {\n                    ...i,\n                    cancelable: !0\n                })) return;\n                e.draw(t.ctx), t.notifyPlugins(\"afterTooltipDraw\", i);\n            }\n        },\n        afterEvent (t, e) {\n            if (t.tooltip) {\n                const i = e.replay;\n                t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);\n            }\n        },\n        defaults: {\n            enabled: !0,\n            external: null,\n            position: \"average\",\n            backgroundColor: \"rgba(0,0,0,0.8)\",\n            titleColor: \"#fff\",\n            titleFont: {\n                weight: \"bold\"\n            },\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleAlign: \"left\",\n            bodyColor: \"#fff\",\n            bodySpacing: 2,\n            bodyFont: {},\n            bodyAlign: \"left\",\n            footerColor: \"#fff\",\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFont: {\n                weight: \"bold\"\n            },\n            footerAlign: \"left\",\n            padding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            boxHeight: (t, e)=>e.bodyFont.size,\n            boxWidth: (t, e)=>e.bodyFont.size,\n            multiKeyBackground: \"#fff\",\n            displayColors: !0,\n            boxPadding: 0,\n            borderColor: \"rgba(0,0,0,0)\",\n            borderWidth: 0,\n            animation: {\n                duration: 400,\n                easing: \"easeOutQuart\"\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"width\",\n                        \"height\",\n                        \"caretX\",\n                        \"caretY\"\n                    ]\n                },\n                opacity: {\n                    easing: \"linear\",\n                    duration: 200\n                }\n            },\n            callbacks: Ia\n        },\n        defaultRoutes: {\n            bodyFont: \"font\",\n            footerFont: \"font\",\n            titleFont: \"font\"\n        },\n        descriptors: {\n            _scriptable: (t)=>\"filter\" !== t && \"itemSort\" !== t && \"external\" !== t,\n            _indexable: !1,\n            callbacks: {\n                _scriptable: !1,\n                _indexable: !1\n            },\n            animation: {\n                _fallback: !1\n            },\n            animations: {\n                _fallback: \"animation\"\n            }\n        },\n        additionalOptionScopes: [\n            \"interaction\"\n        ]\n    };\n    return On.register($n, Ho, uo, t), On.helpers = {\n        ...Wi\n    }, On._adapters = En, On.Animation = Cs, On.Animations = Os, On.animator = xt, On.controllers = en.controllers.items, On.DatasetController = Ns, On.Element = Hs, On.elements = uo, On.Interaction = Xi, On.layouts = as, On.platforms = Ss, On.Scale = Js, On.Ticks = ae, Object.assign(On, $n, Ho, uo, t, Ss), On.Chart = On, \"undefined\" != typeof window && (window.Chart = On), On;\n});\n\n//# sourceMappingURL=index.2e60a0a1.js.map\n","/*!\n * Chart.js v4.3.3\n * https://www.chartjs.org\n * (c) 2023 Chart.js Contributors\n * Released under the MIT License\n */\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).Chart=e()}(this,(function(){\"use strict\";var t=Object.freeze({__proto__:null,get Colors(){return Ko},get Decimation(){return Jo},get Filler(){return pa},get Legend(){return _a},get SubTitle(){return wa},get Title(){return va},get Tooltip(){return Va}});function e(){}const i=(()=>{let t=0;return()=>t++})();function s(t){return null==t}function n(t){if(Array.isArray&&Array.isArray(t))return!0;const e=Object.prototype.toString.call(t);return\"[object\"===e.slice(0,7)&&\"Array]\"===e.slice(-6)}function o(t){return null!==t&&\"[object Object]\"===Object.prototype.toString.call(t)}function a(t){return(\"number\"==typeof t||t instanceof Number)&&isFinite(+t)}function r(t,e){return a(t)?t:e}function l(t,e){return void 0===t?e:t}const h=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100:+t/e,c=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100*e:+t;function d(t,e,i){if(t&&\"function\"==typeof t.call)return t.apply(i,e)}function u(t,e,i,s){let a,r,l;if(n(t))if(r=t.length,s)for(a=r-1;a>=0;a--)e.call(i,t[a],a);else for(a=0;a<r;a++)e.call(i,t[a],a);else if(o(t))for(l=Object.keys(t),r=l.length,a=0;a<r;a++)e.call(i,t[l[a]],l[a])}function f(t,e){let i,s,n,o;if(!t||!e||t.length!==e.length)return!1;for(i=0,s=t.length;i<s;++i)if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)return!1;return!0}function g(t){if(n(t))return t.map(g);if(o(t)){const e=Object.create(null),i=Object.keys(t),s=i.length;let n=0;for(;n<s;++n)e[i[n]]=g(t[i[n]]);return e}return t}function p(t){return-1===[\"__proto__\",\"prototype\",\"constructor\"].indexOf(t)}function m(t,e,i,s){if(!p(t))return;const n=e[t],a=i[t];o(n)&&o(a)?b(n,a,s):e[t]=g(a)}function b(t,e,i){const s=n(e)?e:[e],a=s.length;if(!o(t))return t;const r=(i=i||{}).merger||m;let l;for(let e=0;e<a;++e){if(l=s[e],!o(l))continue;const n=Object.keys(l);for(let e=0,s=n.length;e<s;++e)r(n[e],t,l,i)}return t}function x(t,e){return b(t,e,{merger:_})}function _(t,e,i){if(!p(t))return;const s=e[t],n=i[t];o(s)&&o(n)?x(s,n):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=g(n))}const y={\"\":t=>t,x:t=>t.x,y:t=>t.y};function v(t){const e=t.split(\".\"),i=[];let s=\"\";for(const t of e)s+=t,s.endsWith(\"\\\\\")?s=s.slice(0,-1)+\".\":(i.push(s),s=\"\");return i}function M(t,e){const i=y[e]||(y[e]=function(t){const e=v(t);return t=>{for(const i of e){if(\"\"===i)break;t=t&&t[i]}return t}}(e));return i(t)}function w(t){return t.charAt(0).toUpperCase()+t.slice(1)}const k=t=>void 0!==t,S=t=>\"function\"==typeof t,P=(t,e)=>{if(t.size!==e.size)return!1;for(const i of t)if(!e.has(i))return!1;return!0};function D(t){return\"mouseup\"===t.type||\"click\"===t.type||\"contextmenu\"===t.type}const C=Math.PI,O=2*C,A=O+C,T=Number.POSITIVE_INFINITY,L=C/180,E=C/2,R=C/4,I=2*C/3,z=Math.log10,F=Math.sign;function V(t,e,i){return Math.abs(t-e)<i}function B(t){const e=Math.round(t);t=V(t,e,t/1e3)?e:t;const i=Math.pow(10,Math.floor(z(t))),s=t/i;return(s<=1?1:s<=2?2:s<=5?5:10)*i}function W(t){const e=[],i=Math.sqrt(t);let s;for(s=1;s<i;s++)t%s==0&&(e.push(s),e.push(t/s));return i===(0|i)&&e.push(i),e.sort(((t,e)=>t-e)).pop(),e}function N(t){return!isNaN(parseFloat(t))&&isFinite(t)}function H(t,e){const i=Math.round(t);return i-e<=t&&i+e>=t}function j(t,e,i){let s,n,o;for(s=0,n=t.length;s<n;s++)o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}function $(t){return t*(C/180)}function Y(t){return t*(180/C)}function U(t){if(!a(t))return;let e=1,i=0;for(;Math.round(t*e)/e!==t;)e*=10,i++;return i}function X(t,e){const i=e.x-t.x,s=e.y-t.y,n=Math.sqrt(i*i+s*s);let o=Math.atan2(s,i);return o<-.5*C&&(o+=O),{angle:o,distance:n}}function q(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function K(t,e){return(t-e+A)%O-C}function G(t){return(t%O+O)%O}function Z(t,e,i,s){const n=G(t),o=G(e),a=G(i),r=G(o-n),l=G(a-n),h=G(n-o),c=G(n-a);return n===o||n===a||s&&o===a||r>l&&h<c}function J(t,e,i){return Math.max(e,Math.min(i,t))}function Q(t){return J(t,-32768,32767)}function tt(t,e,i,s=1e-6){return t>=Math.min(e,i)-s&&t<=Math.max(e,i)+s}function et(t,e,i){i=i||(i=>t[i]<e);let s,n=t.length-1,o=0;for(;n-o>1;)s=o+n>>1,i(s)?o=s:n=s;return{lo:o,hi:n}}const it=(t,e,i,s)=>et(t,i,s?s=>{const n=t[s][e];return n<i||n===i&&t[s+1][e]===i}:s=>t[s][e]<i),st=(t,e,i)=>et(t,i,(s=>t[s][e]>=i));function nt(t,e,i){let s=0,n=t.length;for(;s<n&&t[s]<e;)s++;for(;n>s&&t[n-1]>i;)n--;return s>0||n<t.length?t.slice(s,n):t}const ot=[\"push\",\"pop\",\"shift\",\"splice\",\"unshift\"];function at(t,e){t._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,\"_chartjs\",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),ot.forEach((e=>{const i=\"_onData\"+w(e),s=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value(...e){const n=s.apply(this,e);return t._chartjs.listeners.forEach((t=>{\"function\"==typeof t[i]&&t[i](...e)})),n}})})))}function rt(t,e){const i=t._chartjs;if(!i)return;const s=i.listeners,n=s.indexOf(e);-1!==n&&s.splice(n,1),s.length>0||(ot.forEach((e=>{delete t[e]})),delete t._chartjs)}function lt(t){const e=new Set(t);return e.size===t.length?t:Array.from(e)}const ht=\"undefined\"==typeof window?function(t){return t()}:window.requestAnimationFrame;function ct(t,e){let i=[],s=!1;return function(...n){i=n,s||(s=!0,ht.call(window,(()=>{s=!1,t.apply(e,i)})))}}function dt(t,e){let i;return function(...s){return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}}const ut=t=>\"start\"===t?\"left\":\"end\"===t?\"right\":\"center\",ft=(t,e,i)=>\"start\"===t?e:\"end\"===t?i:(e+i)/2,gt=(t,e,i,s)=>t===(s?\"left\":\"right\")?i:\"center\"===t?(e+i)/2:e;function pt(t,e,i){const s=e.length;let n=0,o=s;if(t._sorted){const{iScale:a,_parsed:r}=t,l=a.axis,{min:h,max:c,minDefined:d,maxDefined:u}=a.getUserBounds();d&&(n=J(Math.min(it(r,l,h).lo,i?s:it(e,l,a.getPixelForValue(h)).lo),0,s-1)),o=u?J(Math.max(it(r,a.axis,c,!0).hi+1,i?0:it(e,l,a.getPixelForValue(c),!0).hi+1),n,s)-n:s-n}return{start:n,count:o}}function mt(t){const{xScale:e,yScale:i,_scaleRanges:s}=t,n={xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};if(!s)return t._scaleRanges=n,!0;const o=s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;return Object.assign(s,n),o}class bt{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,s){const n=e.listeners[s],o=e.duration;n.forEach((s=>s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)})))}_refresh(){this._request||(this._running=!0,this._request=ht.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(t=Date.now()){let e=0;this._charts.forEach(((i,s)=>{if(!i.running||!i.items.length)return;const n=i.items;let o,a=n.length-1,r=!1;for(;a>=0;--a)o=n[a],o._active?(o._total>i.duration&&(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());r&&(s.draw(),this._notify(s,i,t,\"progress\")),n.length||(i.running=!1,this._notify(s,i,t,\"complete\"),i.initial=!1),e+=n.length})),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let s=i.length-1;for(;s>=0;--s)i[s].cancel();e.items=[],this._notify(t,e,Date.now(),\"complete\")}remove(t){return this._charts.delete(t)}}var xt=new bt;\n/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */function _t(t){return t+.5|0}const yt=(t,e,i)=>Math.max(Math.min(t,i),e);function vt(t){return yt(_t(2.55*t),0,255)}function Mt(t){return yt(_t(255*t),0,255)}function wt(t){return yt(_t(t/2.55)/100,0,1)}function kt(t){return yt(_t(100*t),0,100)}const St={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Pt=[...\"0123456789ABCDEF\"],Dt=t=>Pt[15&t],Ct=t=>Pt[(240&t)>>4]+Pt[15&t],Ot=t=>(240&t)>>4==(15&t);function At(t){var e=(t=>Ot(t.r)&&Ot(t.g)&&Ot(t.b)&&Ot(t.a))(t)?Dt:Ct;return t?\"#\"+e(t.r)+e(t.g)+e(t.b)+((t,e)=>t<255?e(t):\"\")(t.a,e):void 0}const Tt=/^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;function Lt(t,e,i){const s=e*Math.min(i,1-i),n=(e,n=(e+t/30)%12)=>i-s*Math.max(Math.min(n-3,9-n,1),-1);return[n(0),n(8),n(4)]}function Et(t,e,i){const s=(s,n=(s+t/60)%6)=>i-i*e*Math.max(Math.min(n,4-n,1),0);return[s(5),s(3),s(1)]}function Rt(t,e,i){const s=Lt(t,1,.5);let n;for(e+i>1&&(n=1/(e+i),e*=n,i*=n),n=0;n<3;n++)s[n]*=1-e-i,s[n]+=e;return s}function It(t){const e=t.r/255,i=t.g/255,s=t.b/255,n=Math.max(e,i,s),o=Math.min(e,i,s),a=(n+o)/2;let r,l,h;return n!==o&&(h=n-o,l=a>.5?h/(2-n-o):h/(n+o),r=function(t,e,i,s,n){return t===n?(e-i)/s+(e<i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}(e,i,s,h,n),r=60*r+.5),[0|r,l||0,a]}function zt(t,e,i,s){return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(Mt)}function Ft(t,e,i){return zt(Lt,t,e,i)}function Vt(t){return(t%360+360)%360}function Bt(t){const e=Tt.exec(t);let i,s=255;if(!e)return;e[5]!==i&&(s=e[6]?vt(+e[5]):Mt(+e[5]));const n=Vt(+e[2]),o=+e[3]/100,a=+e[4]/100;return i=\"hwb\"===e[1]?function(t,e,i){return zt(Rt,t,e,i)}(n,o,a):\"hsv\"===e[1]?function(t,e,i){return zt(Et,t,e,i)}(n,o,a):Ft(n,o,a),{r:i[0],g:i[1],b:i[2],a:s}}const Wt={x:\"dark\",Z:\"light\",Y:\"re\",X:\"blu\",W:\"gr\",V:\"medium\",U:\"slate\",A:\"ee\",T:\"ol\",S:\"or\",B:\"ra\",C:\"lateg\",D:\"ights\",R:\"in\",Q:\"turquois\",E:\"hi\",P:\"ro\",O:\"al\",N:\"le\",M:\"de\",L:\"yello\",F:\"en\",K:\"ch\",G:\"arks\",H:\"ea\",I:\"ightg\",J:\"wh\"},Nt={OiceXe:\"f0f8ff\",antiquewEte:\"faebd7\",aqua:\"ffff\",aquamarRe:\"7fffd4\",azuY:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"0\",blanKedOmond:\"ffebcd\",Xe:\"ff\",XeviTet:\"8a2be2\",bPwn:\"a52a2a\",burlywood:\"deb887\",caMtXe:\"5f9ea0\",KartYuse:\"7fff00\",KocTate:\"d2691e\",cSO:\"ff7f50\",cSnflowerXe:\"6495ed\",cSnsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"ffff\",xXe:\"8b\",xcyan:\"8b8b\",xgTMnPd:\"b8860b\",xWay:\"a9a9a9\",xgYF:\"6400\",xgYy:\"a9a9a9\",xkhaki:\"bdb76b\",xmagFta:\"8b008b\",xTivegYF:\"556b2f\",xSange:\"ff8c00\",xScEd:\"9932cc\",xYd:\"8b0000\",xsOmon:\"e9967a\",xsHgYF:\"8fbc8f\",xUXe:\"483d8b\",xUWay:\"2f4f4f\",xUgYy:\"2f4f4f\",xQe:\"ced1\",xviTet:\"9400d3\",dAppRk:\"ff1493\",dApskyXe:\"bfff\",dimWay:\"696969\",dimgYy:\"696969\",dodgerXe:\"1e90ff\",fiYbrick:\"b22222\",flSOwEte:\"fffaf0\",foYstWAn:\"228b22\",fuKsia:\"ff00ff\",gaRsbSo:\"dcdcdc\",ghostwEte:\"f8f8ff\",gTd:\"ffd700\",gTMnPd:\"daa520\",Way:\"808080\",gYF:\"8000\",gYFLw:\"adff2f\",gYy:\"808080\",honeyMw:\"f0fff0\",hotpRk:\"ff69b4\",RdianYd:\"cd5c5c\",Rdigo:\"4b0082\",ivSy:\"fffff0\",khaki:\"f0e68c\",lavFMr:\"e6e6fa\",lavFMrXsh:\"fff0f5\",lawngYF:\"7cfc00\",NmoncEffon:\"fffacd\",ZXe:\"add8e6\",ZcSO:\"f08080\",Zcyan:\"e0ffff\",ZgTMnPdLw:\"fafad2\",ZWay:\"d3d3d3\",ZgYF:\"90ee90\",ZgYy:\"d3d3d3\",ZpRk:\"ffb6c1\",ZsOmon:\"ffa07a\",ZsHgYF:\"20b2aa\",ZskyXe:\"87cefa\",ZUWay:\"778899\",ZUgYy:\"778899\",ZstAlXe:\"b0c4de\",ZLw:\"ffffe0\",lime:\"ff00\",limegYF:\"32cd32\",lRF:\"faf0e6\",magFta:\"ff00ff\",maPon:\"800000\",VaquamarRe:\"66cdaa\",VXe:\"cd\",VScEd:\"ba55d3\",VpurpN:\"9370db\",VsHgYF:\"3cb371\",VUXe:\"7b68ee\",VsprRggYF:\"fa9a\",VQe:\"48d1cc\",VviTetYd:\"c71585\",midnightXe:\"191970\",mRtcYam:\"f5fffa\",mistyPse:\"ffe4e1\",moccasR:\"ffe4b5\",navajowEte:\"ffdead\",navy:\"80\",Tdlace:\"fdf5e6\",Tive:\"808000\",TivedBb:\"6b8e23\",Sange:\"ffa500\",SangeYd:\"ff4500\",ScEd:\"da70d6\",pOegTMnPd:\"eee8aa\",pOegYF:\"98fb98\",pOeQe:\"afeeee\",pOeviTetYd:\"db7093\",papayawEp:\"ffefd5\",pHKpuff:\"ffdab9\",peru:\"cd853f\",pRk:\"ffc0cb\",plum:\"dda0dd\",powMrXe:\"b0e0e6\",purpN:\"800080\",YbeccapurpN:\"663399\",Yd:\"ff0000\",Psybrown:\"bc8f8f\",PyOXe:\"4169e1\",saddNbPwn:\"8b4513\",sOmon:\"fa8072\",sandybPwn:\"f4a460\",sHgYF:\"2e8b57\",sHshell:\"fff5ee\",siFna:\"a0522d\",silver:\"c0c0c0\",skyXe:\"87ceeb\",UXe:\"6a5acd\",UWay:\"708090\",UgYy:\"708090\",snow:\"fffafa\",sprRggYF:\"ff7f\",stAlXe:\"4682b4\",tan:\"d2b48c\",teO:\"8080\",tEstN:\"d8bfd8\",tomato:\"ff6347\",Qe:\"40e0d0\",viTet:\"ee82ee\",JHt:\"f5deb3\",wEte:\"ffffff\",wEtesmoke:\"f5f5f5\",Lw:\"ffff00\",LwgYF:\"9acd32\"};let Ht;function jt(t){Ht||(Ht=function(){const t={},e=Object.keys(Nt),i=Object.keys(Wt);let s,n,o,a,r;for(s=0;s<e.length;s++){for(a=r=e[s],n=0;n<i.length;n++)o=i[n],r=r.replace(o,Wt[o]);o=parseInt(Nt[a],16),t[r]=[o>>16&255,o>>8&255,255&o]}return t}(),Ht.transparent=[0,0,0,0]);const e=Ht[t.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const $t=/^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;const Yt=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,Ut=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);function Xt(t,e,i){if(t){let s=It(t);s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=Ft(s),t.r=s[0],t.g=s[1],t.b=s[2]}}function qt(t,e){return t?Object.assign(e||{},t):t}function Kt(t){var e={r:0,g:0,b:0,a:255};return Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(e.a=Mt(t[3]))):(e=qt(t,{r:0,g:0,b:0,a:1})).a=Mt(e.a),e}function Gt(t){return\"r\"===t.charAt(0)?function(t){const e=$t.exec(t);let i,s,n,o=255;if(e){if(e[7]!==i){const t=+e[7];o=e[8]?vt(t):yt(255*t,0,255)}return i=+e[1],s=+e[3],n=+e[5],i=255&(e[2]?vt(i):yt(i,0,255)),s=255&(e[4]?vt(s):yt(s,0,255)),n=255&(e[6]?vt(n):yt(n,0,255)),{r:i,g:s,b:n,a:o}}}(t):Bt(t)}class Zt{constructor(t){if(t instanceof Zt)return t;const e=typeof t;let i;var s,n,o;\"object\"===e?i=Kt(t):\"string\"===e&&(o=(s=t).length,\"#\"===s[0]&&(4===o||5===o?n={r:255&17*St[s[1]],g:255&17*St[s[2]],b:255&17*St[s[3]],a:5===o?17*St[s[4]]:255}:7!==o&&9!==o||(n={r:St[s[1]]<<4|St[s[2]],g:St[s[3]]<<4|St[s[4]],b:St[s[5]]<<4|St[s[6]],a:9===o?St[s[7]]<<4|St[s[8]]:255})),i=n||jt(t)||Gt(t)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=qt(this._rgb);return t&&(t.a=wt(t.a)),t}set rgb(t){this._rgb=Kt(t)}rgbString(){return this._valid?(t=this._rgb)&&(t.a<255?`rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;var t}hexString(){return this._valid?At(this._rgb):void 0}hslString(){return this._valid?function(t){if(!t)return;const e=It(t),i=e[0],s=kt(e[1]),n=kt(e[2]);return t.a<255?`hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}(this._rgb):void 0}mix(t,e){if(t){const i=this.rgb,s=t.rgb;let n;const o=e===n?.5:e,a=2*o-1,r=i.a-s.a,l=((a*r==-1?a:(a+r)/(1+a*r))+1)/2;n=1-l,i.r=255&l*i.r+n*s.r+.5,i.g=255&l*i.g+n*s.g+.5,i.b=255&l*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}return this}interpolate(t,e){return t&&(this._rgb=function(t,e,i){const s=Ut(wt(t.r)),n=Ut(wt(t.g)),o=Ut(wt(t.b));return{r:Mt(Yt(s+i*(Ut(wt(e.r))-s))),g:Mt(Yt(n+i*(Ut(wt(e.g))-n))),b:Mt(Yt(o+i*(Ut(wt(e.b))-o))),a:t.a+i*(e.a-t.a)}}(this._rgb,t._rgb,e)),this}clone(){return new Zt(this.rgb)}alpha(t){return this._rgb.a=Mt(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=_t(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return Xt(this._rgb,2,t),this}darken(t){return Xt(this._rgb,2,-t),this}saturate(t){return Xt(this._rgb,1,t),this}desaturate(t){return Xt(this._rgb,1,-t),this}rotate(t){return function(t,e){var i=It(t);i[0]=Vt(i[0]+e),i=Ft(i),t.r=i[0],t.g=i[1],t.b=i[2]}(this._rgb,t),this}}function Jt(t){if(t&&\"object\"==typeof t){const e=t.toString();return\"[object CanvasPattern]\"===e||\"[object CanvasGradient]\"===e}return!1}function Qt(t){return Jt(t)?t:new Zt(t)}function te(t){return Jt(t)?t:new Zt(t).saturate(.5).darken(.1).hexString()}const ee=[\"x\",\"y\",\"borderWidth\",\"radius\",\"tension\"],ie=[\"color\",\"borderColor\",\"backgroundColor\"];const se=new Map;function ne(t,e,i){return function(t,e){e=e||{};const i=t+JSON.stringify(e);let s=se.get(i);return s||(s=new Intl.NumberFormat(t,e),se.set(i,s)),s}(e,i).format(t)}const oe={values:t=>n(t)?t:\"\"+t,numeric(t,e,i){if(0===t)return\"0\";const s=this.chart.options.locale;let n,o=t;if(i.length>1){const e=Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));(e<1e-4||e>1e15)&&(n=\"scientific\"),o=function(t,e){let i=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(i)>=1&&t!==Math.floor(t)&&(i=t-Math.floor(t));return i}(t,i)}const a=z(Math.abs(o)),r=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),l={notation:n,minimumFractionDigits:r,maximumFractionDigits:r};return Object.assign(l,this.options.ticks.format),ne(t,s,l)},logarithmic(t,e,i){if(0===t)return\"0\";const s=i[e].significand||t/Math.pow(10,Math.floor(z(t)));return[1,2,3,5,10,15].includes(s)||e>.8*i.length?oe.numeric.call(this,t,e,i):\"\"}};var ae={formatters:oe};const re=Object.create(null),le=Object.create(null);function he(t,e){if(!e)return t;const i=e.split(\".\");for(let e=0,s=i.length;e<s;++e){const s=i[e];t=t[s]||(t[s]=Object.create(null))}return t}function ce(t,e,i){return\"string\"==typeof e?b(he(t,e),i):b(he(t,\"\"),e)}class de{constructor(t,e){this.animation=void 0,this.backgroundColor=\"rgba(0,0,0,0.1)\",this.borderColor=\"rgba(0,0,0,0.1)\",this.color=\"#666\",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=[\"mousemove\",\"mouseout\",\"click\",\"touchstart\",\"touchmove\"],this.font={family:\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",size:12,style:\"normal\",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(t,e)=>te(e.backgroundColor),this.hoverBorderColor=(t,e)=>te(e.borderColor),this.hoverColor=(t,e)=>te(e.color),this.indexAxis=\"x\",this.interaction={mode:\"nearest\",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return ce(this,t,e)}get(t){return he(this,t)}describe(t,e){return ce(le,t,e)}override(t,e){return ce(re,t,e)}route(t,e,i,s){const n=he(this,t),a=he(this,i),r=\"_\"+e;Object.defineProperties(n,{[r]:{value:n[e],writable:!0},[e]:{enumerable:!0,get(){const t=this[r],e=a[s];return o(t)?Object.assign({},e,t):l(t,e)},set(t){this[r]=t}}})}apply(t){t.forEach((t=>t(this)))}}var ue=new de({_scriptable:t=>!t.startsWith(\"on\"),_indexable:t=>\"events\"!==t,hover:{_fallback:\"interaction\"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set(\"animation\",{delay:void 0,duration:1e3,easing:\"easeOutQuart\",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe(\"animation\",{_fallback:!1,_indexable:!1,_scriptable:t=>\"onProgress\"!==t&&\"onComplete\"!==t&&\"fn\"!==t}),t.set(\"animations\",{colors:{type:\"color\",properties:ie},numbers:{type:\"number\",properties:ee}}),t.describe(\"animations\",{_fallback:\"animation\"}),t.set(\"transitions\",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:\"transparent\"},visible:{type:\"boolean\",duration:0}}},hide:{animations:{colors:{to:\"transparent\"},visible:{type:\"boolean\",easing:\"linear\",fn:t=>0|t}}}})},function(t){t.set(\"layout\",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(t){t.set(\"scale\",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:\"ticks\",grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:\"\",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:\"\",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:ae.formatters.values,minor:{},major:{},align:\"center\",crossAlign:\"near\",showLabelBackdrop:!1,backdropColor:\"rgba(255, 255, 255, 0.75)\",backdropPadding:2}}),t.route(\"scale.ticks\",\"color\",\"\",\"color\"),t.route(\"scale.grid\",\"color\",\"\",\"borderColor\"),t.route(\"scale.border\",\"color\",\"\",\"borderColor\"),t.route(\"scale.title\",\"color\",\"\",\"color\"),t.describe(\"scale\",{_fallback:!1,_scriptable:t=>!t.startsWith(\"before\")&&!t.startsWith(\"after\")&&\"callback\"!==t&&\"parser\"!==t,_indexable:t=>\"borderDash\"!==t&&\"tickBorderDash\"!==t&&\"dash\"!==t}),t.describe(\"scales\",{_fallback:\"scale\"}),t.describe(\"scale.ticks\",{_scriptable:t=>\"backdropPadding\"!==t&&\"callback\"!==t,_indexable:t=>\"backdropPadding\"!==t})}]);function fe(){return\"undefined\"!=typeof window&&\"undefined\"!=typeof document}function ge(t){let e=t.parentNode;return e&&\"[object ShadowRoot]\"===e.toString()&&(e=e.host),e}function pe(t,e,i){let s;return\"string\"==typeof t?(s=parseInt(t,10),-1!==t.indexOf(\"%\")&&(s=s/100*e.parentNode[i])):s=t,s}const me=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);function be(t,e){return me(t).getPropertyValue(e)}const xe=[\"top\",\"right\",\"bottom\",\"left\"];function _e(t,e,i){const s={};i=i?\"-\"+i:\"\";for(let n=0;n<4;n++){const o=xe[n];s[o]=parseFloat(t[e+\"-\"+o+i])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}const ye=(t,e,i)=>(t>0||e>0)&&(!i||!i.shadowRoot);function ve(t,e){if(\"native\"in t)return t;const{canvas:i,currentDevicePixelRatio:s}=e,n=me(i),o=\"border-box\"===n.boxSizing,a=_e(n,\"padding\"),r=_e(n,\"border\",\"width\"),{x:l,y:h,box:c}=function(t,e){const i=t.touches,s=i&&i.length?i[0]:t,{offsetX:n,offsetY:o}=s;let a,r,l=!1;if(ye(n,o,t.target))a=n,r=o;else{const t=e.getBoundingClientRect();a=s.clientX-t.left,r=s.clientY-t.top,l=!0}return{x:a,y:r,box:l}}(t,i),d=a.left+(c&&r.left),u=a.top+(c&&r.top);let{width:f,height:g}=e;return o&&(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((l-d)/f*i.width/s),y:Math.round((h-u)/g*i.height/s)}}const Me=t=>Math.round(10*t)/10;function we(t,e,i,s){const n=me(t),o=_e(n,\"margin\"),a=pe(n.maxWidth,t,\"clientWidth\")||T,r=pe(n.maxHeight,t,\"clientHeight\")||T,l=function(t,e,i){let s,n;if(void 0===e||void 0===i){const o=ge(t);if(o){const t=o.getBoundingClientRect(),a=me(o),r=_e(a,\"border\",\"width\"),l=_e(a,\"padding\");e=t.width-l.width-r.width,i=t.height-l.height-r.height,s=pe(a.maxWidth,o,\"clientWidth\"),n=pe(a.maxHeight,o,\"clientHeight\")}else e=t.clientWidth,i=t.clientHeight}return{width:e,height:i,maxWidth:s||T,maxHeight:n||T}}(t,e,i);let{width:h,height:c}=l;if(\"content-box\"===n.boxSizing){const t=_e(n,\"border\",\"width\"),e=_e(n,\"padding\");h-=e.width+t.width,c-=e.height+t.height}h=Math.max(0,h-o.width),c=Math.max(0,s?h/s:c-o.height),h=Me(Math.min(h,a,l.maxWidth)),c=Me(Math.min(c,r,l.maxHeight)),h&&!c&&(c=Me(h/2));return(void 0!==e||void 0!==i)&&s&&l.height&&c>l.height&&(c=l.height,h=Me(Math.floor(c*s))),{width:h,height:c}}function ke(t,e,i){const s=e||1,n=Math.floor(t.height*s),o=Math.floor(t.width*s);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const a=t.canvas;return a.style&&(i||!a.style.height&&!a.style.width)&&(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&&(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}const Se=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};window.addEventListener(\"test\",null,e),window.removeEventListener(\"test\",null,e)}catch(t){}return t}();function Pe(t,e){const i=be(t,e),s=i&&i.match(/^(\\d+)(\\.\\d+)?px$/);return s?+s[1]:void 0}function De(t){return!t||s(t.size)||s(t.family)?null:(t.style?t.style+\" \":\"\")+(t.weight?t.weight+\" \":\"\")+t.size+\"px \"+t.family}function Ce(t,e,i,s,n){let o=e[n];return o||(o=e[n]=t.measureText(n).width,i.push(n)),o>s&&(s=o),s}function Oe(t,e,i,s){let o=(s=s||{}).data=s.data||{},a=s.garbageCollect=s.garbageCollect||[];s.font!==e&&(o=s.data={},a=s.garbageCollect=[],s.font=e),t.save(),t.font=e;let r=0;const l=i.length;let h,c,d,u,f;for(h=0;h<l;h++)if(u=i[h],null==u||n(u)){if(n(u))for(c=0,d=u.length;c<d;c++)f=u[c],null==f||n(f)||(r=Ce(t,o,a,r,f))}else r=Ce(t,o,a,r,u);t.restore();const g=a.length/2;if(g>i.length){for(h=0;h<g;h++)delete o[a[h]];a.splice(0,g)}return r}function Ae(t,e,i){const s=t.currentDevicePixelRatio,n=0!==i?Math.max(i/2,.5):0;return Math.round((e-n)*s)/s+n}function Te(t,e){(e=e||t.getContext(\"2d\")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore()}function Le(t,e,i,s){Ee(t,e,i,s,null)}function Ee(t,e,i,s,n){let o,a,r,l,h,c,d,u;const f=e.pointStyle,g=e.rotation,p=e.radius;let m=(g||0)*L;if(f&&\"object\"==typeof f&&(o=f.toString(),\"[object HTMLImageElement]\"===o||\"[object HTMLCanvasElement]\"===o))return t.save(),t.translate(i,s),t.rotate(m),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();if(!(isNaN(p)||p<=0)){switch(t.beginPath(),f){default:n?t.ellipse(i,s,n/2,p,0,0,O):t.arc(i,s,p,0,O),t.closePath();break;case\"triangle\":c=n?n/2:p,t.moveTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),t.closePath();break;case\"rectRounded\":h=.516*p,l=p-h,a=Math.cos(m+R)*l,d=Math.cos(m+R)*(n?n/2-h:l),r=Math.sin(m+R)*l,u=Math.sin(m+R)*(n?n/2-h:l),t.arc(i-d,s-r,h,m-C,m-E),t.arc(i+u,s-a,h,m-E,m),t.arc(i+d,s+r,h,m,m+E),t.arc(i-u,s+a,h,m+E,m+C),t.closePath();break;case\"rect\":if(!g){l=Math.SQRT1_2*p,c=n?n/2:l,t.rect(i-c,s-l,2*c,2*l);break}m+=R;case\"rectRot\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+u,s-a),t.lineTo(i+d,s+r),t.lineTo(i-u,s+a),t.closePath();break;case\"crossRot\":m+=R;case\"cross\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"star\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a),m+=R,d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"line\":a=n?n/2:Math.cos(m)*p,r=Math.sin(m)*p,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r);break;case\"dash\":t.moveTo(i,s),t.lineTo(i+Math.cos(m)*(n?n/2:p),s+Math.sin(m)*p);break;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}function Re(t,e,i){return i=i||.5,!e||t&&t.x>e.left-i&&t.x<e.right+i&&t.y>e.top-i&&t.y<e.bottom+i}function Ie(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}function ze(t){t.restore()}function Fe(t,e,i,s,n){if(!e)return t.lineTo(i.x,i.y);if(\"middle\"===n){const s=(e.x+i.x)/2;t.lineTo(s,e.y),t.lineTo(s,i.y)}else\"after\"===n!=!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);t.lineTo(i.x,i.y)}function Ve(t,e,i,s){if(!e)return t.lineTo(i.x,i.y);t.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}function Be(t,e,i,s,n){if(n.strikethrough||n.underline){const o=t.measureText(s),a=e-o.actualBoundingBoxLeft,r=e+o.actualBoundingBoxRight,l=i-o.actualBoundingBoxAscent,h=i+o.actualBoundingBoxDescent,c=n.strikethrough?(l+h)/2:h;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}}function We(t,e){const i=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}function Ne(t,e,i,o,a,r={}){const l=n(e)?e:[e],h=r.strokeWidth>0&&\"\"!==r.strokeColor;let c,d;for(t.save(),t.font=a.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),s(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.textBaseline=e.textBaseline)}(t,r),c=0;c<l.length;++c)d=l[c],r.backdrop&&We(t,r.backdrop),h&&(r.strokeColor&&(t.strokeStyle=r.strokeColor),s(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,i,o,r.maxWidth)),t.fillText(d,i,o,r.maxWidth),Be(t,i,o,d,r),o+=Number(a.lineHeight);t.restore()}function He(t,e){const{x:i,y:s,w:n,h:o,radius:a}=e;t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,-E,C,!0),t.lineTo(i,s+o-a.bottomLeft),t.arc(i+a.bottomLeft,s+o-a.bottomLeft,a.bottomLeft,C,E,!0),t.lineTo(i+n-a.bottomRight,s+o),t.arc(i+n-a.bottomRight,s+o-a.bottomRight,a.bottomRight,E,0,!0),t.lineTo(i+n,s+a.topRight),t.arc(i+n-a.topRight,s+a.topRight,a.topRight,0,-E,!0),t.lineTo(i+a.topLeft,s)}function je(t,e=[\"\"],i,s,n=(()=>t[0])){const o=i||t;void 0===s&&(s=ti(\"_fallback\",t));const a={[Symbol.toStringTag]:\"Object\",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:i=>je([i,...t],e,o,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete e._keys,delete t[0][i],!0),get:(i,s)=>qe(i,s,(()=>function(t,e,i,s){let n;for(const o of e)if(n=ti(Ue(o,t),i),void 0!==n)return Xe(t,n)?Je(i,s,t,n):n}(s,e,t,i))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>ei(t).includes(e),ownKeys:t=>ei(t),set(t,e,i){const s=t._storage||(t._storage=n());return t[e]=s[e]=i,delete t._keys,!0}})}function $e(t,e,i,s){const a={_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ye(t,s),setContext:e=>$e(t,e,i,s),override:n=>$e(t.override(n),e,i,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete t[i],!0),get:(t,e,i)=>qe(t,e,(()=>function(t,e,i){const{_proxy:s,_context:a,_subProxy:r,_descriptors:l}=t;let h=s[e];S(h)&&l.isScriptable(e)&&(h=function(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=i;if(r.has(t))throw new Error(\"Recursion detected: \"+Array.from(r).join(\"->\")+\"->\"+t);r.add(t);let l=e(o,a||s);r.delete(t),Xe(t,l)&&(l=Je(n._scopes,n,t,l));return l}(e,h,t,i));n(h)&&h.length&&(h=function(t,e,i,s){const{_proxy:n,_context:a,_subProxy:r,_descriptors:l}=i;if(void 0!==a.index&&s(t))return e[a.index%e.length];if(o(e[0])){const i=e,s=n._scopes.filter((t=>t!==i));e=[];for(const o of i){const i=Je(s,n,t,o);e.push($e(i,a,r&&r[t],l))}}return e}(e,h,t,l.isIndexable));Xe(e,h)&&(h=$e(h,a,r&&r[e],l));return h}(t,e,i))),getOwnPropertyDescriptor:(e,i)=>e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,i)=>Reflect.has(t,i),ownKeys:()=>Reflect.ownKeys(t),set:(e,i,s)=>(t[i]=s,delete e[i],!0)})}function Ye(t,e={scriptable:!0,indexable:!0}){const{_scriptable:i=e.scriptable,_indexable:s=e.indexable,_allKeys:n=e.allKeys}=t;return{allKeys:n,scriptable:i,indexable:s,isScriptable:S(i)?i:()=>i,isIndexable:S(s)?s:()=>s}}const Ue=(t,e)=>t?t+w(e):e,Xe=(t,e)=>o(e)&&\"adapters\"!==t&&(null===Object.getPrototypeOf(e)||e.constructor===Object);function qe(t,e,i){if(Object.prototype.hasOwnProperty.call(t,e))return t[e];const s=i();return t[e]=s,s}function Ke(t,e,i){return S(t)?t(e,i):t}const Ge=(t,e)=>!0===t?e:\"string\"==typeof t?M(e,t):void 0;function Ze(t,e,i,s,n){for(const o of e){const e=Ge(i,o);if(e){t.add(e);const o=Ke(e._fallback,i,n);if(void 0!==o&&o!==i&&o!==s)return o}else if(!1===e&&void 0!==s&&i!==s)return null}return!1}function Je(t,e,i,s){const a=e._rootScopes,r=Ke(e._fallback,i,s),l=[...t,...a],h=new Set;h.add(s);let c=Qe(h,l,i,r||i,s);return null!==c&&((void 0===r||r===i||(c=Qe(h,l,r,c,s),null!==c))&&je(Array.from(h),[\"\"],a,r,(()=>function(t,e,i){const s=t._getTarget();e in s||(s[e]={});const a=s[e];if(n(a)&&o(i))return i;return a||{}}(e,i,s))))}function Qe(t,e,i,s,n){for(;i;)i=Ze(t,e,i,s,n);return i}function ti(t,e){for(const i of e){if(!i)continue;const e=i[t];if(void 0!==e)return e}}function ei(t){let e=t._keys;return e||(e=t._keys=function(t){const e=new Set;for(const i of t)for(const t of Object.keys(i).filter((t=>!t.startsWith(\"_\"))))e.add(t);return Array.from(e)}(t._scopes)),e}function ii(t,e,i,s){const{iScale:n}=t,{key:o=\"r\"}=this._parsing,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={r:n.parse(M(c,o),h)};return a}const si=Number.EPSILON||1e-14,ni=(t,e)=>e<t.length&&!t[e].skip&&t[e],oi=t=>\"x\"===t?\"y\":\"x\";function ai(t,e,i,s){const n=t.skip?e:t,o=e,a=i.skip?e:i,r=q(o,n),l=q(a,o);let h=r/(r+l),c=l/(r+l);h=isNaN(h)?0:h,c=isNaN(c)?0:c;const d=s*h,u=s*c;return{previous:{x:o.x-d*(a.x-n.x),y:o.y-d*(a.y-n.y)},next:{x:o.x+u*(a.x-n.x),y:o.y+u*(a.y-n.y)}}}function ri(t,e=\"x\"){const i=oi(e),s=t.length,n=Array(s).fill(0),o=Array(s);let a,r,l,h=ni(t,0);for(a=0;a<s;++a)if(r=l,l=h,h=ni(t,a+1),l){if(h){const t=h[e]-l[e];n[a]=0!==t?(h[i]-l[i])/t:0}o[a]=r?h?F(n[a-1])!==F(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}!function(t,e,i){const s=t.length;let n,o,a,r,l,h=ni(t,0);for(let c=0;c<s-1;++c)l=h,h=ni(t,c+1),l&&h&&(V(e[c],0,si)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r<=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}(t,n,o),function(t,e,i=\"x\"){const s=oi(i),n=t.length;let o,a,r,l=ni(t,0);for(let h=0;h<n;++h){if(a=r,r=l,l=ni(t,h+1),!r)continue;const n=r[i],c=r[s];a&&(o=(n-a[i])/3,r[`cp1${i}`]=n-o,r[`cp1${s}`]=c-o*e[h]),l&&(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}}(t,o,e)}function li(t,e,i){return Math.max(Math.min(t,i),e)}function hi(t,e,i,s,n){let o,a,r,l;if(e.spanGaps&&(t=t.filter((t=>!t.skip))),\"monotone\"===e.cubicInterpolationMode)ri(t,n);else{let i=s?t[t.length-1]:t[0];for(o=0,a=t.length;o<a;++o)r=t[o],l=ai(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.previous.x,r.cp1y=l.previous.y,r.cp2x=l.next.x,r.cp2y=l.next.y,i=r}e.capBezierPoints&&function(t,e){let i,s,n,o,a,r=Re(t[0],e);for(i=0,s=t.length;i<s;++i)a=o,o=r,r=i<s-1&&Re(t[i+1],e),o&&(n=t[i],a&&(n.cp1x=li(n.cp1x,e.left,e.right),n.cp1y=li(n.cp1y,e.top,e.bottom)),r&&(n.cp2x=li(n.cp2x,e.left,e.right),n.cp2y=li(n.cp2y,e.top,e.bottom)))}(t,i)}const ci=t=>0===t||1===t,di=(t,e,i)=>-Math.pow(2,10*(t-=1))*Math.sin((t-e)*O/i),ui=(t,e,i)=>Math.pow(2,-10*t)*Math.sin((t-e)*O/i)+1,fi={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*E),easeOutSine:t=>Math.sin(t*E),easeInOutSine:t=>-.5*(Math.cos(C*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>ci(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>ci(t)?t:di(t,.075,.3),easeOutElastic:t=>ci(t)?t:ui(t,.075,.3),easeInOutElastic(t){const e=.1125;return ci(t)?t:t<.5?.5*di(2*t,e,.45):.5+.5*ui(2*t-1,e,.45)},easeInBack(t){const e=1.70158;return t*t*((e+1)*t-e)},easeOutBack(t){const e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-fi.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,i=2.75;return t<1/i?e*t*t:t<2/i?e*(t-=1.5/i)*t+.75:t<2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375},easeInOutBounce:t=>t<.5?.5*fi.easeInBounce(2*t):.5*fi.easeOutBounce(2*t-1)+.5};function gi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}function pi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:\"middle\"===s?i<.5?t.y:e.y:\"after\"===s?i<1?t.y:e.y:i>0?e.y:t.y}}function mi(t,e,i,s){const n={x:t.cp2x,y:t.cp2y},o={x:e.cp1x,y:e.cp1y},a=gi(t,n,i),r=gi(n,o,i),l=gi(o,e,i),h=gi(a,r,i),c=gi(r,l,i);return gi(h,c,i)}const bi=/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/,xi=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function _i(t,e){const i=(\"\"+t).match(bi);if(!i||\"normal\"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case\"px\":return t;case\"%\":t/=100}return e*t}const yi=t=>+t||0;function vi(t,e){const i={},s=o(e),n=s?Object.keys(e):e,a=o(t)?s?i=>l(t[i],t[e[i]]):e=>t[e]:()=>t;for(const t of n)i[t]=yi(a(t));return i}function Mi(t){return vi(t,{top:\"y\",right:\"x\",bottom:\"y\",left:\"x\"})}function wi(t){return vi(t,[\"topLeft\",\"topRight\",\"bottomLeft\",\"bottomRight\"])}function ki(t){const e=Mi(t);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Si(t,e){t=t||{},e=e||ue.font;let i=l(t.size,e.size);\"string\"==typeof i&&(i=parseInt(i,10));let s=l(t.style,e.style);s&&!(\"\"+s).match(xi)&&(console.warn('Invalid font style specified: \"'+s+'\"'),s=void 0);const n={family:l(t.family,e.family),lineHeight:_i(l(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:l(t.weight,e.weight),string:\"\"};return n.string=De(n),n}function Pi(t,e,i,s){let o,a,r,l=!0;for(o=0,a=t.length;o<a;++o)if(r=t[o],void 0!==r&&(void 0!==e&&\"function\"==typeof r&&(r=r(e),l=!1),void 0!==i&&n(r)&&(r=r[i%r.length],l=!1),void 0!==r))return s&&!l&&(s.cacheable=!1),r}function Di(t,e,i){const{min:s,max:n}=t,o=c(e,(n-s)/2),a=(t,e)=>i&&0===t?0:t+e;return{min:a(s,-Math.abs(o)),max:a(n,o)}}function Ci(t,e){return Object.assign(Object.create(t),e)}function Oi(t,e,i){return t?function(t,e){return{x:i=>t+t+e-i,setWidth(t){e=t},textAlign:t=>\"center\"===t?t:\"right\"===t?\"left\":\"right\",xPlus:(t,e)=>t-e,leftForLtr:(t,e)=>t-e}}(e,i):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function Ai(t,e){let i,s;\"ltr\"!==e&&\"rtl\"!==e||(i=t.canvas.style,s=[i.getPropertyValue(\"direction\"),i.getPropertyPriority(\"direction\")],i.setProperty(\"direction\",e,\"important\"),t.prevTextDirection=s)}function Ti(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty(\"direction\",e[0],e[1]))}function Li(t){return\"angle\"===t?{between:Z,compare:K,normalize:G}:{between:tt,compare:(t,e)=>t-e,normalize:t=>t}}function Ei({start:t,end:e,count:i,loop:s,style:n}){return{start:t%i,end:e%i,loop:s&&(e-t+1)%i==0,style:n}}function Ri(t,e,i){if(!i)return[t];const{property:s,start:n,end:o}=i,a=e.length,{compare:r,between:l,normalize:h}=Li(s),{start:c,end:d,loop:u,style:f}=function(t,e,i){const{property:s,start:n,end:o}=i,{between:a,normalize:r}=Li(s),l=e.length;let h,c,{start:d,end:u,loop:f}=t;if(f){for(d+=l,u+=l,h=0,c=l;h<c&&a(r(e[d%l][s]),n,o);++h)d--,u--;d%=l,u%=l}return u<d&&(u+=l),{start:d,end:u,loop:f,style:t.style}}(t,e,i),g=[];let p,m,b,x=!1,_=null;const y=()=>x||l(n,b,p)&&0!==r(n,b),v=()=>!x||0===r(o,p)||l(o,b,p);for(let t=c,i=c;t<=d;++t)m=e[t%a],m.skip||(p=h(m[s]),p!==b&&(x=l(p,n,o),null===_&&y()&&(_=0===r(p,n)?t:i),null!==_&&v()&&(g.push(Ei({start:_,end:t,loop:u,count:a,style:f})),_=null),i=t,b=p));return null!==_&&g.push(Ei({start:_,end:d,loop:u,count:a,style:f})),g}function Ii(t,e){const i=[],s=t.segments;for(let n=0;n<s.length;n++){const o=Ri(s[n],t.points,e);o.length&&i.push(...o)}return i}function zi(t,e){const i=t.points,s=t.options.spanGaps,n=i.length;if(!n)return[];const o=!!t._loop,{start:a,end:r}=function(t,e,i,s){let n=0,o=e-1;if(i&&!s)for(;n<e&&!t[n].skip;)n++;for(;n<e&&t[n].skip;)n++;for(n%=e,i&&(o+=n);o>n&&t[o%e].skip;)o--;return o%=e,{start:n,end:o}}(i,n,o,s);if(!0===s)return Fi(t,[{start:a,end:r,loop:o}],i,e);return Fi(t,function(t,e,i,s){const n=t.length,o=[];let a,r=e,l=t[e];for(a=e+1;a<=i;++a){const i=t[a%n];i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&&(e=a)),l=i}return null!==r&&o.push({start:e%n,end:r%n,loop:s}),o}(i,a,r<a?r+n:r,!!t._fullLoop&&0===a&&r===n-1),i,e)}function Fi(t,e,i,s){return s&&s.setContext&&i?function(t,e,i,s){const n=t._chart.getContext(),o=Vi(t.options),{_datasetIndex:a,options:{spanGaps:r}}=t,l=i.length,h=[];let c=o,d=e[0].start,u=d;function f(t,e,s,n){const o=r?-1:1;if(t!==e){for(t+=l;i[t%l].skip;)t-=o;for(;i[e%l].skip;)e+=o;t%l!=e%l&&(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}}for(const t of e){d=r?d:t.start;let e,o=i[d%l];for(u=d+1;u<=t.end;u++){const r=i[u%l];e=Vi(s.setContext(Ci(n,{type:\"segment\",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Bi(e,c)&&f(d,u-1,t.loop,c),o=r,c=e}d<u-1&&f(d,u-1,t.loop,c)}return h}(t,e,i,s):e}function Vi(t){return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}function Bi(t,e){if(!e)return!1;const i=[],s=function(t,e){return Jt(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e};return JSON.stringify(t,s)!==JSON.stringify(e,s)}var Wi=Object.freeze({__proto__:null,HALF_PI:E,INFINITY:T,PI:C,PITAU:A,QUARTER_PI:R,RAD_PER_DEG:L,TAU:O,TWO_THIRDS_PI:I,_addGrace:Di,_alignPixel:Ae,_alignStartEnd:ft,_angleBetween:Z,_angleDiff:K,_arrayUnique:lt,_attachContext:$e,_bezierCurveTo:Ve,_bezierInterpolation:mi,_boundSegment:Ri,_boundSegments:Ii,_capitalize:w,_computeSegments:zi,_createResolver:je,_decimalPlaces:U,_deprecated:function(t,e,i,s){void 0!==e&&console.warn(t+': \"'+i+'\" is deprecated. Please use \"'+s+'\" instead')},_descriptors:Ye,_elementsEqual:f,_factorize:W,_filterBetween:nt,_getParentNode:ge,_getStartAndCountOfVisiblePoints:pt,_int16Range:Q,_isBetween:tt,_isClickEvent:D,_isDomSupported:fe,_isPointInArea:Re,_limitValue:J,_longestText:Oe,_lookup:et,_lookupByKey:it,_measureText:Ce,_merger:m,_mergerIf:_,_normalizeAngle:G,_parseObjectDataRadialScale:ii,_pointInLine:gi,_readValueToProps:vi,_rlookupByKey:st,_scaleRangesChanged:mt,_setMinAndMaxByKey:j,_splitKey:v,_steppedInterpolation:pi,_steppedLineTo:Fe,_textX:gt,_toLeftRightCenter:ut,_updateBezierControlPoints:hi,addRoundedRectPath:He,almostEquals:V,almostWhole:H,callback:d,clearCanvas:Te,clipArea:Ie,clone:g,color:Qt,createContext:Ci,debounce:dt,defined:k,distanceBetweenPoints:q,drawPoint:Le,drawPointLegend:Ee,each:u,easingEffects:fi,finiteOrDefault:r,fontString:function(t,e,i){return e+\" \"+t+\"px \"+i},formatNumber:ne,getAngleFromPoint:X,getHoverColor:te,getMaximumSize:we,getRelativePosition:ve,getRtlAdapter:Oi,getStyle:be,isArray:n,isFinite:a,isFunction:S,isNullOrUndef:s,isNumber:N,isObject:o,isPatternOrGradient:Jt,listenArrayEvents:at,log10:z,merge:b,mergeIf:x,niceNum:B,noop:e,overrideTextDirection:Ai,readUsedSize:Pe,renderText:Ne,requestAnimFrame:ht,resolve:Pi,resolveObjectKey:M,restoreTextDirection:Ti,retinaScale:ke,setsEqual:P,sign:F,splineCurve:ai,splineCurveMonotone:ri,supportsEventListenerOptions:Se,throttled:ct,toDegrees:Y,toDimension:c,toFont:Si,toFontString:De,toLineHeight:_i,toPadding:ki,toPercentage:h,toRadians:$,toTRBL:Mi,toTRBLCorners:wi,uid:i,unclipArea:ze,unlistenArrayEvents:rt,valueOrDefault:l});function Ni(t,e,i,s){const{controller:n,data:o,_sorted:a}=t,r=n._cachedMeta.iScale;if(r&&e===r.axis&&\"r\"!==e&&a&&o.length){const t=r._reversePixels?st:it;if(!s)return t(o,e,i);if(n._sharedOptions){const s=o[0],n=\"function\"==typeof s.getRange&&s.getRange(e);if(n){const s=t(o,e,i-n),a=t(o,e,i+n);return{lo:s.lo,hi:a.hi}}}}return{lo:0,hi:o.length-1}}function Hi(t,e,i,s,n){const o=t.getSortedVisibleDatasetMetas(),a=i[e];for(let t=0,i=o.length;t<i;++t){const{index:i,data:r}=o[t],{lo:l,hi:h}=Ni(o[t],e,a,n);for(let t=l;t<=h;++t){const e=r[t];e.skip||s(e,i,t)}}}function ji(t,e,i,s,n){const o=[];if(!n&&!t.isPointInArea(e))return o;return Hi(t,i,e,(function(i,a,r){(n||Re(i,t.chartArea,0))&&i.inRange(e.x,e.y,s)&&o.push({element:i,datasetIndex:a,index:r})}),!0),o}function $i(t,e,i,s,n,o){let a=[];const r=function(t){const e=-1!==t.indexOf(\"x\"),i=-1!==t.indexOf(\"y\");return function(t,s){const n=e?Math.abs(t.x-s.x):0,o=i?Math.abs(t.y-s.y):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}}(i);let l=Number.POSITIVE_INFINITY;return Hi(t,i,e,(function(i,h,c){const d=i.inRange(e.x,e.y,n);if(s&&!d)return;const u=i.getCenterPoint(n);if(!(!!o||t.isPointInArea(u))&&!d)return;const f=r(e,u);f<l?(a=[{element:i,datasetIndex:h,index:c}],l=f):f===l&&a.push({element:i,datasetIndex:h,index:c})})),a}function Yi(t,e,i,s,n,o){return o||t.isPointInArea(e)?\"r\"!==i||s?$i(t,e,i,s,n,o):function(t,e,i,s){let n=[];return Hi(t,i,e,(function(t,i,o){const{startAngle:a,endAngle:r}=t.getProps([\"startAngle\",\"endAngle\"],s),{angle:l}=X(t,{x:e.x,y:e.y});Z(l,a,r)&&n.push({element:t,datasetIndex:i,index:o})})),n}(t,e,i,n):[]}function Ui(t,e,i,s,n){const o=[],a=\"x\"===i?\"inXRange\":\"inYRange\";let r=!1;return Hi(t,i,e,((t,s,l)=>{t[a](e[i],n)&&(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(e.x,e.y,n))})),s&&!r?[]:o}var Xi={evaluateInteractionItems:Hi,modes:{index(t,e,i,s){const n=ve(e,t),o=i.axis||\"x\",a=i.includeInvisible||!1,r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a),l=[];return r.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=r[0].index,i=t.data[e];i&&!i.skip&&l.push({element:i,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;let r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a);if(r.length>0){const e=r[0].datasetIndex,i=t.getDatasetMeta(e).data;r=[];for(let t=0;t<i.length;++t)r.push({element:i[t],datasetIndex:e,index:t})}return r},point:(t,e,i,s)=>ji(t,ve(e,t),i.axis||\"xy\",s,i.includeInvisible||!1),nearest(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;return Yi(t,n,o,i.intersect,s,a)},x:(t,e,i,s)=>Ui(t,ve(e,t),\"x\",i.intersect,s),y:(t,e,i,s)=>Ui(t,ve(e,t),\"y\",i.intersect,s)}};const qi=[\"left\",\"top\",\"right\",\"bottom\"];function Ki(t,e){return t.filter((t=>t.pos===e))}function Gi(t,e){return t.filter((t=>-1===qi.indexOf(t.pos)&&t.box.axis===e))}function Zi(t,e){return t.sort(((t,i)=>{const s=e?i:t,n=e?t:i;return s.weight===n.weight?s.index-n.index:s.weight-n.weight}))}function Ji(t,e){const i=function(t){const e={};for(const i of t){const{stack:t,pos:s,stackWeight:n}=i;if(!t||!qi.includes(s))continue;const o=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=n}return e}(t),{vBoxMaxWidth:s,hBoxMaxHeight:n}=e;let o,a,r;for(o=0,a=t.length;o<a;++o){r=t[o];const{fullSize:a}=r.box,l=i[r.stack],h=l&&r.stackWeight/l.weight;r.horizontal?(r.width=h?h*s:a&&e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&&e.availableHeight)}return i}function Qi(t,e,i,s){return Math.max(t[i],e[i])+Math.max(t[s],e[s])}function ts(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}function es(t,e,i,s){const{pos:n,box:a}=i,r=t.maxPadding;if(!o(n)){i.size&&(t[n]-=i.size);const e=s[i.stack]||{size:0,count:1};e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[n]+=i.size}a.getPadding&&ts(r,a.getPadding());const l=Math.max(0,e.outerWidth-Qi(r,t,\"left\",\"right\")),h=Math.max(0,e.outerHeight-Qi(r,t,\"top\",\"bottom\")),c=l!==t.w,d=h!==t.h;return t.w=l,t.h=h,i.horizontal?{same:c,other:d}:{same:d,other:c}}function is(t,e){const i=e.maxPadding;function s(t){const s={left:0,top:0,right:0,bottom:0};return t.forEach((t=>{s[t]=Math.max(e[t],i[t])})),s}return s(t?[\"left\",\"right\"]:[\"top\",\"bottom\"])}function ss(t,e,i,s){const n=[];let o,a,r,l,h,c;for(o=0,a=t.length,h=0;o<a;++o){r=t[o],l=r.box,l.update(r.width||e.w,r.height||e.h,is(r.horizontal,e));const{same:a,other:d}=es(e,i,r,s);h|=a&&n.length,c=c||d,l.fullSize||n.push(r)}return h&&ss(n,e,i,s)||c}function ns(t,e,i,s,n){t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}function os(t,e,i,s){const n=i.padding;let{x:o,y:a}=e;for(const r of t){const t=r.box,l=s[r.stack]||{count:1,placed:0,weight:1},h=r.stackWeight/l.weight||1;if(r.horizontal){const s=e.w*h,o=l.size||t.height;k(l.start)&&(a=l.start),t.fullSize?ns(t,n.left,a,i.outerWidth-n.right-n.left,o):ns(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}else{const s=e.h*h,a=l.size||t.width;k(l.start)&&(o=l.start),t.fullSize?ns(t,o,n.top,a,i.outerHeight-n.bottom-n.top):ns(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}}e.x=o,e.y=a}var as={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||\"top\",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure(t,e,i){e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight},update(t,e,i,s){if(!t)return;const n=ki(t.options.layout.padding),o=Math.max(e-n.width,0),a=Math.max(i-n.height,0),r=function(t){const e=function(t){const e=[];let i,s,n,o,a,r;for(i=0,s=(t||[]).length;i<s;++i)n=t[i],({position:o,options:{stack:a,stackWeight:r=1}}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&&o+a,stackWeight:r});return e}(t),i=Zi(e.filter((t=>t.box.fullSize)),!0),s=Zi(Ki(e,\"left\"),!0),n=Zi(Ki(e,\"right\")),o=Zi(Ki(e,\"top\"),!0),a=Zi(Ki(e,\"bottom\")),r=Gi(e,\"x\"),l=Gi(e,\"y\");return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:Ki(e,\"chartArea\"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}(t.boxes),l=r.vertical,h=r.horizontal;u(t.boxes,(t=>{\"function\"==typeof t.beforeLayout&&t.beforeLayout()}));const c=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,d=Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/c,hBoxMaxHeight:a/2}),f=Object.assign({},n);ts(f,ki(s));const g=Object.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),p=Ji(l.concat(h),d);ss(r.fullSize,g,d,p),ss(l,g,d,p),ss(h,g,d,p)&&ss(l,g,d,p),function(t){const e=t.maxPadding;function i(i){const s=Math.max(e[i]-t[i],0);return t[i]+=s,s}t.y+=i(\"top\"),t.x+=i(\"left\"),i(\"right\"),i(\"bottom\")}(g),os(r.leftAndTop,g,d,p),g.x+=g.w,g.y+=g.h,os(r.rightAndBottom,g,d,p),t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w},u(r.chartArea,(e=>{const i=e.box;Object.assign(i,t.chartArea),i.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}))}};class rs{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,i,s){return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}isAttached(t){return!0}updateConfig(t){}}class ls extends rs{acquireContext(t){return t&&t.getContext&&t.getContext(\"2d\")||null}updateConfig(t){t.options.animation=!1}}const hs=\"$chartjs\",cs={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\",pointerenter:\"mouseenter\",pointerdown:\"mousedown\",pointermove:\"mousemove\",pointerup:\"mouseup\",pointerleave:\"mouseout\",pointerout:\"mouseout\"},ds=t=>null===t||\"\"===t;const us=!!Se&&{passive:!0};function fs(t,e,i){t.canvas.removeEventListener(e,i,us)}function gs(t,e){for(const i of t)if(i===e||i.contains(e))return!0}function ps(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.addedNodes,s),e=e&&!gs(i.removedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}function ms(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.removedNodes,s),e=e&&!gs(i.addedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}const bs=new Map;let xs=0;function _s(){const t=window.devicePixelRatio;t!==xs&&(xs=t,bs.forEach(((e,i)=>{i.currentDevicePixelRatio!==t&&e()})))}function ys(t,e,i){const s=t.canvas,n=s&&ge(s);if(!n)return;const o=ct(((t,e)=>{const s=n.clientWidth;i(t,e),s<n.clientWidth&&i()}),window),a=new ResizeObserver((t=>{const e=t[0],i=e.contentRect.width,s=e.contentRect.height;0===i&&0===s||o(i,s)}));return a.observe(n),function(t,e){bs.size||window.addEventListener(\"resize\",_s),bs.set(t,e)}(t,o),a}function vs(t,e,i){i&&i.disconnect(),\"resize\"===e&&function(t){bs.delete(t),bs.size||window.removeEventListener(\"resize\",_s)}(t)}function Ms(t,e,i){const s=t.canvas,n=ct((e=>{null!==t.ctx&&i(function(t,e){const i=cs[t.type]||t.type,{x:s,y:n}=ve(t,e);return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}(e,t))}),t);return function(t,e,i){t.addEventListener(e,i,us)}(s,e,n),n}class ws extends rs{acquireContext(t,e){const i=t&&t.getContext&&t.getContext(\"2d\");return i&&i.canvas===t?(function(t,e){const i=t.style,s=t.getAttribute(\"height\"),n=t.getAttribute(\"width\");if(t[hs]={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||\"block\",i.boxSizing=i.boxSizing||\"border-box\",ds(n)){const e=Pe(t,\"width\");void 0!==e&&(t.width=e)}if(ds(s))if(\"\"===t.style.height)t.height=t.width/(e||2);else{const e=Pe(t,\"height\");void 0!==e&&(t.height=e)}}(t,e),i):null}releaseContext(t){const e=t.canvas;if(!e[hs])return!1;const i=e[hs].initial;[\"height\",\"width\"].forEach((t=>{const n=i[t];s(n)?e.removeAttribute(t):e.setAttribute(t,n)}));const n=i.style||{};return Object.keys(n).forEach((t=>{e.style[t]=n[t]})),e.width=e.width,delete e[hs],!0}addEventListener(t,e,i){this.removeEventListener(t,e);const s=t.$proxies||(t.$proxies={}),n={attach:ps,detach:ms,resize:ys}[e]||Ms;s[e]=n(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),s=i[e];if(!s)return;({attach:vs,detach:vs,resize:vs}[e]||fs)(t,e,s),i[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,i,s){return we(t,e,i,s)}isAttached(t){const e=ge(t);return!(!e||!e.isConnected)}}function ks(t){return!fe()||\"undefined\"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?ls:ws}var Ss=Object.freeze({__proto__:null,BasePlatform:rs,BasicPlatform:ls,DomPlatform:ws,_detectPlatform:ks});const Ps=\"transparent\",Ds={boolean:(t,e,i)=>i>.5?e:t,color(t,e,i){const s=Qt(t||Ps),n=s.valid&&Qt(e||Ps);return n&&n.valid?n.mix(s,i).hexString():e},number:(t,e,i)=>t+(e-t)*i};class Cs{constructor(t,e,i,s){const n=e[i];s=Pi([t.to,s,n,t.from]);const o=Pi([t.from,n,s]);this._active=!0,this._fn=t.fn||Ds[t.type||typeof o],this._easing=fi[t.easing]||fi.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(!1);const s=this._target[this._prop],n=i-this._start,o=this._duration-n;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Pi([t.to,e,s,t.from]),this._from=Pi([t.from,s,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,s=this._prop,n=this._from,o=this._loop,a=this._to;let r;if(this._active=n!==a&&(o||e<i),!this._active)return this._target[s]=a,void this._notify(!0);e<0?this._target[s]=n:(r=e/i%2,r=o&&r>1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,i)=>{t.push({res:e,rej:i})}))}_notify(t){const e=t?\"res\":\"rej\",i=this._promises||[];for(let t=0;t<i.length;t++)i[t][e]()}}class Os{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!o(t))return;const e=Object.keys(ue.animation),i=this._properties;Object.getOwnPropertyNames(t).forEach((s=>{const a=t[s];if(!o(a))return;const r={};for(const t of e)r[t]=a[t];(n(a.properties)&&a.properties||[s]).forEach((t=>{t!==s&&i.has(t)||i.set(t,r)}))}))}_animateOptions(t,e){const i=e.options,s=function(t,e){if(!e)return;let i=t.options;if(!i)return void(t.options=e);i.$shared&&(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));return i}(t,i);if(!s)return[];const n=this._createAnimations(s,i);return i.$shared&&function(t,e){const i=[],s=Object.keys(e);for(let e=0;e<s.length;e++){const n=t[s[e]];n&&n.active()&&i.push(n.wait())}return Promise.all(i)}(t.options.$animations,i).then((()=>{t.options=i}),(()=>{})),n}_createAnimations(t,e){const i=this._properties,s=[],n=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let r;for(r=o.length-1;r>=0;--r){const l=o[r];if(\"$\"===l.charAt(0))continue;if(\"options\"===l){s.push(...this._animateOptions(t,e));continue}const h=e[l];let c=n[l];const d=i.get(l);if(c){if(d&&c.active()){c.update(d,h,a);continue}c.cancel()}d&&d.duration?(n[l]=c=new Cs(d,t,l,h),s.push(c)):t[l]=h}return s}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const i=this._createAnimations(t,e);return i.length?(xt.add(this._chart,i),!0):void 0}}function As(t,e){const i=t&&t.options||{},s=i.reverse,n=void 0===i.min?e:0,o=void 0===i.max?e:0;return{start:s?o:n,end:s?n:o}}function Ts(t,e){const i=[],s=t._getSortedDatasetMetas(e);let n,o;for(n=0,o=s.length;n<o;++n)i.push(s[n].index);return i}function Ls(t,e,i,s={}){const n=t.keys,o=\"single\"===s.mode;let r,l,h,c;if(null!==e){for(r=0,l=n.length;r<l;++r){if(h=+n[r],h===i){if(s.all)continue;break}c=t.values[h],a(c)&&(o||0===e||F(e)===F(c))&&(e+=c)}return e}}function Es(t,e){const i=t&&t.options.stacked;return i||void 0===i&&void 0!==e.stack}function Rs(t,e,i){const s=t[e]||(t[e]={});return s[i]||(s[i]={})}function Is(t,e,i,s){for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=t[n.index];if(i&&e>0||!i&&e<0)return n.index}return null}function zs(t,e){const{chart:i,_cachedMeta:s}=t,n=i._stacks||(i._stacks={}),{iScale:o,vScale:a,index:r}=s,l=o.axis,h=a.axis,c=function(t,e,i){return`${t.id}.${e.id}.${i.stack||i.type}`}(o,a,s),d=e.length;let u;for(let t=0;t<d;++t){const i=e[t],{[l]:o,[h]:d}=i;u=(i._stacks||(i._stacks={}))[h]=Rs(n,c,o),u[r]=d,u._top=Is(u,a,!0,s.type),u._bottom=Is(u,a,!1,s.type);(u._visualValues||(u._visualValues={}))[r]=d}}function Fs(t,e){const i=t.scales;return Object.keys(i).filter((t=>i[t].axis===e)).shift()}function Vs(t,e){const i=t.controller.index,s=t.vScale&&t.vScale.axis;if(s){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[s]||void 0===e[s][i])return;delete e[s][i],void 0!==e[s]._visualValues&&void 0!==e[s]._visualValues[i]&&delete e[s]._visualValues[i]}}}const Bs=t=>\"reset\"===t||\"none\"===t,Ws=(t,e)=>e?t:Object.assign({},t);class Ns{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Es(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled(\"filler\")&&console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\")}updateIndex(t){this.index!==t&&Vs(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,i=this.getDataset(),s=(t,e,i,s)=>\"x\"===t?e:\"r\"===t?s:i,n=e.xAxisID=l(i.xAxisID,Fs(t,\"x\")),o=e.yAxisID=l(i.yAxisID,Fs(t,\"y\")),a=e.rAxisID=l(i.rAxisID,Fs(t,\"r\")),r=e.indexAxis,h=e.iAxisID=s(r,n,o,a),c=e.vAxisID=s(r,o,n,a);e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update(\"reset\")}_destroy(){const t=this._cachedMeta;this._data&&rt(this._data,this),t._stacked&&Vs(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),i=this._data;if(o(e))this._data=function(t){const e=Object.keys(t),i=new Array(e.length);let s,n,o;for(s=0,n=e.length;s<n;++s)o=e[s],i[s]={x:o,y:t[o]};return i}(e);else if(i!==e){if(i){rt(i,this);const t=this._cachedMeta;Vs(t),t._parsed=[]}e&&Object.isExtensible(e)&&at(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,i=this.getDataset();let s=!1;this._dataCheck();const n=e._stacked;e._stacked=Es(e.vScale,e),e.stack!==i.stack&&(s=!0,Vs(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&&zs(this,e._parsed)}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),i=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:i,_data:s}=this,{iScale:a,_stacked:r}=i,l=a.axis;let h,c,d,u=0===t&&e===s.length||i._sorted,f=t>0&&i._parsed[t-1];if(!1===this._parsing)i._parsed=s,i._sorted=!0,d=s;else{d=n(s[t])?this.parseArrayData(i,s,t,e):o(s[t])?this.parseObjectData(i,s,t,e):this.parsePrimitiveData(i,s,t,e);const a=()=>null===c[l]||f&&c[l]<f[l];for(h=0;h<e;++h)i._parsed[h+t]=c=d[h],u&&(a()&&(u=!1),f=c);i._sorted=u}r&&zs(this,d)}parsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=t,a=n.axis,r=o.axis,l=n.getLabels(),h=n===o,c=new Array(s);let d,u,f;for(d=0,u=s;d<u;++d)f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};return c}parseArrayData(t,e,i,s){const{xScale:n,yScale:o}=t,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};return a}parseObjectData(t,e,i,s){const{xScale:n,yScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=new Array(s);let h,c,d,u;for(h=0,c=s;h<c;++h)d=h+i,u=e[d],l[h]={x:n.parse(M(u,a),d),y:o.parse(M(u,r),d)};return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,i){const s=this.chart,n=this._cachedMeta,o=e[t.axis];return Ls({keys:Ts(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}updateRangeFromParsed(t,e,i,s){const n=i[e.axis];let o=null===n?NaN:n;const a=s&&i._stacks[e.axis];s&&a&&(s.values=a,o=Ls(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const i=this._cachedMeta,s=i._parsed,n=i._sorted&&t===i.iScale,o=s.length,r=this._getOtherScale(t),l=((t,e,i)=>t&&!e.hidden&&e._stacked&&{keys:Ts(i,!0),values:null})(e,i,this.chart),h={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:d}=function(t){const{min:e,max:i,minDefined:s,maxDefined:n}=t.getUserBounds();return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}(r);let u,f;function g(){f=s[u];const e=f[r.axis];return!a(f[t.axis])||c>e||d<e}for(u=0;u<o&&(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);if(n)for(u=o-1;u>=0;--u)if(!g()){this.updateRangeFromParsed(h,t,f,l);break}return h}getAllParsedValues(t){const e=this._cachedMeta._parsed,i=[];let s,n,o;for(s=0,n=e.length;s<n;++s)o=e[s][t.axis],a(o)&&i.push(o);return i}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,i=e.iScale,s=e.vScale,n=this.getParsed(t);return{label:i?\"\"+i.getLabelForValue(n[i.axis]):\"\",value:s?\"\"+s.getLabelForValue(n[s.axis]):\"\"}}_update(t){const e=this._cachedMeta;this.update(t||\"default\"),e._clip=function(t){let e,i,s,n;return o(t)?(e=t.top,i=t.right,s=t.bottom,n=t.left):e=i=s=n=t,{top:e,right:i,bottom:s,left:n,disabled:!1===t}}(l(this.options.clip,function(t,e,i){if(!1===i)return!1;const s=As(t,i),n=As(e,i);return{top:n.end,right:s.end,bottom:n.start,left:s.start}}(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,i=this._cachedMeta,s=i.data||[],n=e.chartArea,o=[],a=this._drawStart||0,r=this._drawCount||s.length-a,l=this.options.drawActiveElementsOnTop;let h;for(i.dataset&&i.dataset.draw(t,n,a,r),h=a;h<a+r;++h){const e=s[h];e.hidden||(e.active&&l?o.push(e):e.draw(t,n))}for(h=0;h<o.length;++h)o[h].draw(t,n)}getStyle(t,e){const i=e?\"active\":\"default\";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}getContext(t,e,i){const s=this.getDataset();let n;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){return Ci(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:\"default\",type:\"data\"})}(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}else n=this.$context||(this.$context=function(t,e){return Ci(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:\"default\",type:\"dataset\"})}(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;return n.active=!!e,n.mode=i,n}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e=\"default\",i){const s=\"active\"===e,n=this._cachedDataOpts,o=t+\"-\"+e,a=n[o],r=this.enableOptionSharing&&k(i);if(a)return Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,\"hover\",t,\"\"]:[t,\"\"],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getContext(i,s,e)),c);return f.$shared&&(f.$shared=r,n[o]=Object.freeze(Ws(f,r))),f}_resolveAnimations(t,e,i){const s=this.chart,n=this._cachedDataOpts,o=`animation-${e}`,a=n[o];if(a)return a;let r;if(!1!==s.options.animation){const s=this.chart.config,n=s.datasetAnimationScopeKeys(this._type,e),o=s.getOptionScopes(this.getDataset(),n);r=s.createResolver(o,this.getContext(t,i,e))}const l=new Os(s,r&&r.animations);return r&&r._cacheable&&(n[o]=Object.freeze(l)),l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||Bs(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const i=this.resolveDataElementOptions(t,e),s=this._sharedOptions,n=this.getSharedOptions(i),o=this.includeOptions(e,n)||n!==s;return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}updateElement(t,e,i,s){Bs(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}updateSharedOptions(t,e,i){t&&!Bs(e)&&this._resolveAnimations(void 0,e).update(t,i)}_setStyle(t,e,i,s){t.active=s;const n=this.getStyle(e,s);this._resolveAnimations(e,i,s).update(t,{options:!s&&this.getSharedOptions(n)||n})}removeHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!1)}setHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!0)}_resyncElements(t){const e=this._data,i=this._cachedMeta.data;for(const[t,e,i]of this._syncList)this[t](e,i);this._syncList=[];const s=i.length,n=e.length,o=Math.min(n,s);o&&this.parse(0,o),n>s?this._insertElements(s,n-s,t):n<s&&this._removeElements(n,s-n)}_insertElements(t,e,i=!0){const s=this._cachedMeta,n=s.data,o=t+e;let a;const r=t=>{for(t.length+=e,a=t.length-1;a>=o;a--)t[a]=t[a-e]};for(r(n),a=t;a<o;++a)n[a]=new this.dataElementType;this._parsing&&r(s._parsed),this.parse(t,e),i&&this.updateElements(n,t,e,\"reset\")}updateElements(t,e,i,s){}_removeElements(t,e){const i=this._cachedMeta;if(this._parsing){const s=i._parsed.splice(t,e);i._stacked&&Vs(i,s)}i.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,i,s]=t;this[e](i,s)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync([\"_insertElements\",this.getDataset().data.length-t,t])}_onDataPop(){this._sync([\"_removeElements\",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync([\"_removeElements\",0,1])}_onDataSplice(t,e){e&&this._sync([\"_removeElements\",t,e]);const i=arguments.length-2;i&&this._sync([\"_insertElements\",t,i])}_onDataUnshift(){this._sync([\"_insertElements\",0,arguments.length])}}class Hs{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}hasValue(){return N(this.x)&&N(this.y)}getProps(t,e){const i=this.$animations;if(!e||!i)return this;const s={};return t.forEach((t=>{s[t]=i[t]&&i[t].active()?i[t]._to:this[t]})),s}}function js(t,e){const i=t.options.ticks,n=function(t){const e=t.options.offset,i=t._tickSize(),s=t._length/i+(e?0:1),n=t._maxLength/i;return Math.floor(Math.min(s,n))}(t),o=Math.min(i.maxTicksLimit||n,n),a=i.major.enabled?function(t){const e=[];let i,s;for(i=0,s=t.length;i<s;i++)t[i].major&&e.push(i);return e}(e):[],r=a.length,l=a[0],h=a[r-1],c=[];if(r>o)return function(t,e,i,s){let n,o=0,a=i[0];for(s=Math.ceil(s),n=0;n<t.length;n++)n===a&&(e.push(t[n]),o++,a=i[o*s])}(e,c,a,r/o),c;const d=function(t,e,i){const s=function(t){const e=t.length;let i,s;if(e<2)return!1;for(s=t[0],i=1;i<e;++i)if(t[i]-t[i-1]!==s)return!1;return s}(t),n=e.length/i;if(!s)return Math.max(n,1);const o=W(s);for(let t=0,e=o.length-1;t<e;t++){const e=o[t];if(e>n)return e}return Math.max(n,1)}(a,e,o);if(r>0){let t,i;const n=r>1?Math.round((h-l)/(r-1)):null;for($s(e,c,d,s(n)?0:l-n,l),t=0,i=r-1;t<i;t++)$s(e,c,d,a[t],a[t+1]);return $s(e,c,d,h,s(n)?e.length:h+n),c}return $s(e,c,d),c}function $s(t,e,i,s,n){const o=l(s,0),a=Math.min(l(n,t.length),t.length);let r,h,c,d=0;for(i=Math.ceil(i),n&&(r=n-s,i=r/Math.floor(r/i)),c=o;c<0;)d++,c=Math.round(o+d*i);for(h=Math.max(o,0);h<a;h++)h===c&&(e.push(t[h]),d++,c=Math.round(o+d*i))}const Ys=(t,e,i)=>\"top\"===e||\"left\"===e?t[e]+i:t[e]-i,Us=(t,e)=>Math.min(e||t,t);function Xs(t,e){const i=[],s=t.length/e,n=t.length;let o=0;for(;o<n;o+=s)i.push(t[Math.floor(o)]);return i}function qs(t,e,i){const s=t.ticks.length,n=Math.min(e,s-1),o=t._startPixel,a=t._endPixel,r=1e-6;let l,h=t.getPixelForTick(n);if(!(i&&(l=1===s?Math.max(h-o,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(n-1))/2,h+=n<e?l:-l,h<o-r||h>a+r)))return h}function Ks(t){return t.drawTicks?t.tickLength:0}function Gs(t,e){if(!t.display)return 0;const i=Si(t.font,e),s=ki(t.padding);return(n(t.text)?t.text.length:1)*i.lineHeight+s.height}function Zs(t,e,i){let s=ut(t);return(i&&\"right\"!==e||!i&&\"right\"===e)&&(s=(t=>\"left\"===t?\"right\":\"right\"===t?\"left\":t)(s)),s}class Js extends Hs{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=this;return t=r(t,Number.POSITIVE_INFINITY),e=r(e,Number.NEGATIVE_INFINITY),i=r(i,Number.POSITIVE_INFINITY),s=r(s,Number.NEGATIVE_INFINITY),{min:r(t,i),max:r(e,s),minDefined:a(t),maxDefined:a(e)}}getMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=this.getUserBounds();if(n&&o)return{min:i,max:s};const a=this.getMatchingVisibleMetas();for(let r=0,l=a.length;r<l;++r)e=a[r].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));return i=o&&i>s?s:i,s=n&&i>s?i:s,{min:r(i,r(s,i)),max:r(s,r(i,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){d(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Di(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const r=a<this.ticks.length;this._convertTicksToLabels(r?Xs(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||\"auto\"===o.source)&&(this.ticks=js(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,i=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){d(this.options.afterUpdate,[this])}beforeSetDimensions(){d(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){d(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),d(this.options[t],[this])}beforeDataLimits(){this._callHooks(\"beforeDataLimits\")}determineDataLimits(){}afterDataLimits(){this._callHooks(\"afterDataLimits\")}beforeBuildTicks(){this._callHooks(\"beforeBuildTicks\")}buildTicks(){return[]}afterBuildTicks(){this._callHooks(\"afterBuildTicks\")}beforeTickToLabelConversion(){d(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let i,s,n;for(i=0,s=t.length;i<s;i++)n=t[i],n.label=d(e.callback,[n.value,i,t],this)}afterTickToLabelConversion(){d(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){d(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=Us(this.ticks.length,t.ticks.maxTicksLimit),s=e.minRotation||0,n=e.maxRotation;let o,a,r,l=s;if(!this._isVisible()||!e.display||s>=n||i<=1||!this.isHorizontal())return void(this.labelRotation=s);const h=this._getLabelSizes(),c=h.widest.width,d=h.highest.height,u=J(this.chart.width-c,0,this.maxWidth);o=t.offset?this.maxWidth/i:u/(i-1),c+6>o&&(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Ks(t.grid)-e.padding-Gs(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=Y(Math.min(Math.asin(J((h.highest.height+6)/o,-1,1)),Math.asin(J(a/r,-1,1))-Math.asin(J(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}afterCalculateLabelRotation(){d(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){d(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:s,grid:n}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const o=Gs(s,e.options.font);if(a?(t.width=this.maxWidth,t.height=Ks(n)+o):(t.height=this.maxHeight,t.width=Ks(n)+o),i.display&&this.ticks.length){const{first:e,last:s,widest:n,highest:o}=this._getLabelSizes(),r=2*i.padding,l=$(this.labelRotation),h=Math.cos(l),c=Math.sin(l);if(a){const e=i.mirror?0:c*n.width+h*o.height;t.height=Math.min(this.maxHeight,t.height+e+r)}else{const e=i.mirror?0:h*n.width+c*o.height;t.width=Math.min(this.maxWidth,t.width+e+r)}this._calculatePadding(e,s,c,h)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=this.options,r=0!==this.labelRotation,l=\"top\"!==a&&\"x\"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let c=0,d=0;r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):\"start\"===n?d=e.width:\"end\"===n?c=t.width:\"inner\"!==n&&(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let i=e.height/2,s=t.height/2;\"start\"===n?(i=0,s=t.height):\"end\"===n&&(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){d(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return\"top\"===e||\"bottom\"===e||\"x\"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,i;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e<i;e++)s(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=Xs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,i){const{ctx:o,_longestTextCache:a}=this,r=[],l=[],h=Math.floor(e/Us(e,i));let c,d,f,g,p,m,b,x,_,y,v,M=0,w=0;for(c=0;c<e;c+=h){if(g=t[c].label,p=this._resolveTickFontOptions(c),o.font=m=p.string,b=a[m]=a[m]||{data:{},gc:[]},x=p.lineHeight,_=y=0,s(g)||n(g)){if(n(g))for(d=0,f=g.length;d<f;++d)v=g[d],s(v)||n(v)||(_=Ce(o,b.data,b.gc,_,v),y+=x)}else _=Ce(o,b.data,b.gc,_,g),y=x;r.push(_),l.push(y),M=Math.max(_,M),w=Math.max(y,w)}!function(t,e){u(t,(t=>{const i=t.gc,s=i.length/2;let n;if(s>e){for(n=0;n<s;++n)delete t.data[i[n]];i.splice(0,s)}}))}(a,e);const k=r.indexOf(M),S=l.indexOf(w),P=t=>({width:r[t]||0,height:l[t]||0});return{first:P(0),last:P(e-1),widest:P(k),highest:P(S),widths:r,heights:l}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return Q(this._alignToPixels?Ae(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const i=e[t];return i.$context||(i.$context=function(t,e,i){return Ci(t,{tick:i,index:e,type:\"tick\"})}(this.getContext(),t,i))}return this.$context||(this.$context=Ci(this.chart.getContext(),{scale:this,type:\"scale\"}))}_tickSize(){const t=this.options.ticks,e=$(this.labelRotation),i=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),n=this._getLabelSizes(),o=t.autoSkipPadding||0,a=n?n.widest.width+o:0,r=n?n.highest.height+o:0;return this.isHorizontal()?r*i>a*s?a/i:r/s:r*s<a*i?r/i:a/s}_isVisible(){const t=this.options.display;return\"auto\"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,s=this.options,{grid:n,position:a,border:r}=s,h=n.offset,c=this.isHorizontal(),d=this.ticks.length+(h?1:0),u=Ks(n),f=[],g=r.setContext(this.getContext()),p=g.display?g.width:0,m=p/2,b=function(t){return Ae(i,t,p)};let x,_,y,v,M,w,k,S,P,D,C,O;if(\"top\"===a)x=b(this.bottom),w=this.bottom-u,S=x-m,D=b(t.top)+m,O=t.bottom;else if(\"bottom\"===a)x=b(this.top),D=t.top,O=b(t.bottom)-m,w=x+m,S=this.top+u;else if(\"left\"===a)x=b(this.right),M=this.right-u,k=x-m,P=b(t.left)+m,C=t.right;else if(\"right\"===a)x=b(this.left),P=t.left,C=b(t.right)-m,M=x+m,k=this.left+u;else if(\"x\"===e){if(\"center\"===a)x=b((t.top+t.bottom)/2+.5);else if(o(a)){const t=Object.keys(a)[0],e=a[t];x=b(this.chart.scales[t].getPixelForValue(e))}D=t.top,O=t.bottom,w=x+m,S=w+u}else if(\"y\"===e){if(\"center\"===a)x=b((t.left+t.right)/2);else if(o(a)){const t=Object.keys(a)[0],e=a[t];x=b(this.chart.scales[t].getPixelForValue(e))}M=x-m,k=M-u,P=t.left,C=t.right}const A=l(s.ticks.maxTicksLimit,d),T=Math.max(1,Math.ceil(d/A));for(_=0;_<d;_+=T){const t=this.getContext(_),e=n.setContext(t),s=r.setContext(t),o=e.lineWidth,a=e.color,l=s.dash||[],d=s.dashOffset,u=e.tickWidth,g=e.tickColor,p=e.tickBorderDash||[],m=e.tickBorderDashOffset;y=qs(this,_,h),void 0!==y&&(v=Ae(i,y,o),c?M=k=P=C=v:w=S=D=O=v,f.push({tx1:M,ty1:w,tx2:k,ty2:S,x1:P,y1:D,x2:C,y2:O,width:o,color:a,borderDash:l,borderDashOffset:d,tickWidth:u,tickColor:g,tickBorderDash:p,tickBorderDashOffset:m}))}return this._ticksLength=d,this._borderValue=x,f}_computeLabelItems(t){const e=this.axis,i=this.options,{position:s,ticks:a}=i,r=this.isHorizontal(),l=this.ticks,{align:h,crossAlign:c,padding:d,mirror:u}=a,f=Ks(i.grid),g=f+d,p=u?-d:g,m=-$(this.labelRotation),b=[];let x,_,y,v,M,w,k,S,P,D,C,O,A=\"middle\";if(\"top\"===s)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if(\"bottom\"===s)w=this.top+p,k=this._getXAxisLabelAlignment();else if(\"left\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"right\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"x\"===e){if(\"center\"===s)w=(t.top+t.bottom)/2+g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];w=this.chart.scales[t].getPixelForValue(e)+g}k=this._getXAxisLabelAlignment()}else if(\"y\"===e){if(\"center\"===s)M=(t.left+t.right)/2-g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];M=this.chart.scales[t].getPixelForValue(e)}k=this._getYAxisLabelAlignment(f).textAlign}\"y\"===e&&(\"start\"===h?A=\"top\":\"end\"===h&&(A=\"bottom\"));const T=this._getLabelSizes();for(x=0,_=l.length;x<_;++x){y=l[x],v=y.label;const t=a.setContext(this.getContext(x));S=this.getPixelForTick(x)+a.labelOffset,P=this._resolveTickFontOptions(x),D=P.lineHeight,C=n(v)?v.length:1;const e=C/2,i=t.color,o=t.textStrokeColor,h=t.textStrokeWidth;let d,f=k;if(r?(M=S,\"inner\"===k&&(f=x===_-1?this.options.reverse?\"left\":\"right\":0===x?this.options.reverse?\"right\":\"left\":\"center\"),O=\"top\"===s?\"near\"===c||0!==m?-C*D+D/2:\"center\"===c?-T.highest.height/2-e*D+D:-T.highest.height+D/2:\"near\"===c||0!==m?D/2:\"center\"===c?T.highest.height/2-e*D:T.highest.height-C*D,u&&(O*=-1),0===m||t.showLabelBackdrop||(M+=D/2*Math.sin(m))):(w=S,O=(1-C)*D/2),t.showLabelBackdrop){const e=ki(t.backdropPadding),i=T.heights[x],s=T.widths[x];let n=O-e.top,o=0-e.left;switch(A){case\"middle\":n-=i/2;break;case\"bottom\":n-=i}switch(k){case\"center\":o-=s/2;break;case\"right\":o-=s}d={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}b.push({label:v,font:P,textOffset:O,options:{rotation:m,color:i,strokeColor:o,strokeWidth:h,textAlign:f,textBaseline:A,translation:[M,w],backdrop:d}})}return b}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-$(this.labelRotation))return\"top\"===t?\"left\":\"right\";let i=\"center\";return\"start\"===e.align?i=\"left\":\"end\"===e.align?i=\"right\":\"inner\"===e.align&&(i=\"inner\"),i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=this.options,o=t+n,a=this._getLabelSizes().widest.width;let r,l;return\"left\"===e?s?(l=this.right+n,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l+=a)):(l=this.right-o,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l=this.left)):\"right\"===e?s?(l=this.left+n,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l-=a)):(l=this.left+o,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l=this.right)):r=\"right\",{textAlign:r,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return\"left\"===e||\"right\"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:\"top\"===e||\"bottom\"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const i=this.ticks.findIndex((e=>e.value===t));if(i>=0){return e.setContext(this.getContext(i)).lineWidth}return 0}drawGrid(t){const e=this.options.grid,i=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let n,o;const a=(t,e,s)=>{s.width&&s.color&&(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())};if(e.display)for(n=0,o=s.length;n<o;++n){const t=s[n];e.drawOnChartArea&&a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=this,n=i.setContext(this.getContext()),o=i.display?n.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,r=this._borderValue;let l,h,c,d;this.isHorizontal()?(l=Ae(t,this.left,o)-o/2,h=Ae(t,this.right,a)+a/2,c=d=r):(c=Ae(t,this.top,o)-o/2,d=Ae(t,this.bottom,a)+a/2,l=h=r),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(l,c),e.lineTo(h,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,i=this._computeLabelArea();i&&Ie(e,i);const s=this.getLabelItems(t);for(const t of s){const i=t.options,s=t.font;Ne(e,t.label,0,t.textOffset,s,i)}i&&ze(e)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=this;if(!i.display)return;const a=Si(i.font),r=ki(i.padding),l=i.align;let h=a.lineHeight/2;\"bottom\"===e||\"center\"===e||o(e)?(h+=r.bottom,n(i.text)&&(h+=a.lineHeight*(i.text.length-1))):h+=r.top;const{titleX:c,titleY:d,maxWidth:u,rotation:f}=function(t,e,i,s){const{top:n,left:a,bottom:r,right:l,chart:h}=t,{chartArea:c,scales:d}=h;let u,f,g,p=0;const m=r-n,b=l-a;if(t.isHorizontal()){if(f=ft(s,a,l),o(i)){const t=Object.keys(i)[0],s=i[t];g=d[t].getPixelForValue(s)+m-e}else g=\"center\"===i?(c.bottom+c.top)/2+m-e:Ys(t,i,e);u=l-a}else{if(o(i)){const t=Object.keys(i)[0],s=i[t];f=d[t].getPixelForValue(s)-b+e}else f=\"center\"===i?(c.left+c.right)/2-b+e:Ys(t,i,e);g=ft(s,r,n),p=\"left\"===i?-E:E}return{titleX:f,titleY:g,maxWidth:u,rotation:p}}(this,h,e,l);Ne(t,i.text,0,0,a,{color:i.color,maxWidth:u,rotation:f,textAlign:Zs(l,e,s),textBaseline:\"middle\",translation:[c,d]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,i=l(t.grid&&t.grid.z,-1),s=l(t.border&&t.border.z,0);return this._isVisible()&&this.draw===Js.prototype.draw?[{z:i,draw:t=>{this.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),i=this.axis+\"AxisID\",s=[];let n,o;for(n=0,o=e.length;n<o;++n){const o=e[n];o[i]!==this.id||t&&o.type!==t||s.push(o)}return s}_resolveTickFontOptions(t){return Si(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Qs{constructor(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;(function(t){return\"id\"in t&&\"defaults\"in t})(e)&&(i=this.register(e));const s=this.items,n=t.id,o=this.scope+\".\"+n;if(!n)throw new Error(\"class does not have id: \"+t);return n in s||(s[n]=t,function(t,e,i){const s=b(Object.create(null),[i?ue.get(i):{},ue.get(e),t.defaults]);ue.set(e,s),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((i=>{const s=i.split(\".\"),n=s.pop(),o=[t].concat(s).join(\".\"),a=e[i].split(\".\"),r=a.pop(),l=a.join(\".\");ue.route(o,n,l,r)}))}(e,t.defaultRoutes);t.descriptors&&ue.describe(e,t.descriptors)}(t,o,i),this.override&&ue.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,i=t.id,s=this.scope;i in e&&delete e[i],s&&i in ue[s]&&(delete ue[s][i],this.override&&delete re[i])}}class tn{constructor(){this.controllers=new Qs(Ns,\"datasets\",!0),this.elements=new Qs(Hs,\"elements\"),this.plugins=new Qs(Object,\"plugins\"),this.scales=new Qs(Js,\"scales\"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each(\"register\",t)}remove(...t){this._each(\"unregister\",t)}addControllers(...t){this._each(\"register\",t,this.controllers)}addElements(...t){this._each(\"register\",t,this.elements)}addPlugins(...t){this._each(\"register\",t,this.plugins)}addScales(...t){this._each(\"register\",t,this.scales)}getController(t){return this._get(t,this.controllers,\"controller\")}getElement(t){return this._get(t,this.elements,\"element\")}getPlugin(t){return this._get(t,this.plugins,\"plugin\")}getScale(t){return this._get(t,this.scales,\"scale\")}removeControllers(...t){this._each(\"unregister\",t,this.controllers)}removeElements(...t){this._each(\"unregister\",t,this.elements)}removePlugins(...t){this._each(\"unregister\",t,this.plugins)}removeScales(...t){this._each(\"unregister\",t,this.scales)}_each(t,e,i){[...e].forEach((e=>{const s=i||this._getRegistryForType(e);i||s.isForType(e)||s===this.plugins&&e.id?this._exec(t,s,e):u(e,(e=>{const s=i||this._getRegistryForType(e);this._exec(t,s,e)}))}))}_exec(t,e,i){const s=w(t);d(i[\"before\"+s],[],i),e[t](i),d(i[\"after\"+s],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const s=e.get(t);if(void 0===s)throw new Error('\"'+t+'\" is not a registered '+i+\".\");return s}}var en=new tn;class sn{constructor(){this._init=[]}notify(t,e,i,s){\"beforeInit\"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,\"install\"));const n=s?this._descriptors(t).filter(s):this._descriptors(t),o=this._notify(n,t,e,i);return\"afterDestroy\"===e&&(this._notify(n,t,\"stop\"),this._notify(this._init,t,\"uninstall\")),o}_notify(t,e,i,s){s=s||{};for(const n of t){const t=n.plugin;if(!1===d(t[i],[e,s,n.options],t)&&s.cancelable)return!1}return!0}invalidate(){s(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const i=t&&t.config,s=l(i.options&&i.options.plugins,{}),n=function(t){const e={},i=[],s=Object.keys(en.plugins.items);for(let t=0;t<s.length;t++)i.push(en.getPlugin(s[t]));const n=t.plugins||[];for(let t=0;t<n.length;t++){const s=n[t];-1===i.indexOf(s)&&(i.push(s),e[s.id]=!0)}return{plugins:i,localIds:e}}(i);return!1!==s||e?function(t,{plugins:e,localIds:i},s,n){const o=[],a=t.getContext();for(const r of e){const e=r.id,l=nn(s[e],n);null!==l&&o.push({plugin:r,options:on(t.config,{plugin:r,local:i[e]},l,a)})}return o}(t,n,s,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],i=this._cache,s=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(s(e,i),t,\"stop\"),this._notify(s(i,e),t,\"start\")}}function nn(t,e){return e||!1!==t?!0===t?{}:t:null}function on(t,{plugin:e,local:i},s,n){const o=t.pluginScopeKeys(e),a=t.getOptionScopes(s,o);return i&&e.defaults&&a.push(e.defaults),t.createResolver(a,n,[\"\"],{scriptable:!1,indexable:!1,allKeys:!0})}function an(t,e){const i=ue.datasets[t]||{};return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||\"x\"}function rn(t){if(\"x\"===t||\"y\"===t||\"r\"===t)return t}function ln(t,...e){if(rn(t))return t;for(const s of e){const e=s.axis||(\"top\"===(i=s.position)||\"bottom\"===i?\"x\":\"left\"===i||\"right\"===i?\"y\":void 0)||t.length>1&&rn(t[0].toLowerCase());if(e)return e}var i;throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}function hn(t,e,i){if(i[e+\"AxisID\"]===t)return{axis:e}}function cn(t,e){const i=re[t.type]||{scales:{}},s=e.scales||{},n=an(t.type,e),a=Object.create(null);return Object.keys(s).forEach((e=>{const r=s[e];if(!o(r))return console.error(`Invalid scale configuration for scale: ${e}`);if(r._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${e}`);const l=ln(e,r,function(t,e){if(e.data&&e.data.datasets){const i=e.data.datasets.filter((e=>e.xAxisID===t||e.yAxisID===t));if(i.length)return hn(t,\"x\",i[0])||hn(t,\"y\",i[0])}return{}}(e,t),ue.scales[r.type]),h=function(t,e){return t===e?\"_index_\":\"_value_\"}(l,n),c=i.scales||{};a[e]=x(Object.create(null),[{axis:l},r,c[l],c[h]])})),t.data.datasets.forEach((i=>{const n=i.type||t.type,o=i.indexAxis||an(n,e),r=(re[n]||{}).scales||{};Object.keys(r).forEach((t=>{const e=function(t,e){let i=t;return\"_index_\"===t?i=e:\"_value_\"===t&&(i=\"x\"===e?\"y\":\"x\"),i}(t,o),n=i[e+\"AxisID\"]||e;a[n]=a[n]||Object.create(null),x(a[n],[{axis:e},s[n],r[t]])}))})),Object.keys(a).forEach((t=>{const e=a[t];x(e,[ue.scales[e.type],ue.scale])})),a}function dn(t){const e=t.options||(t.options={});e.plugins=l(e.plugins,{}),e.scales=cn(t,e)}function un(t){return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}const fn=new Map,gn=new Set;function pn(t,e){let i=fn.get(t);return i||(i=e(),fn.set(t,i),gn.add(i)),i}const mn=(t,e,i)=>{const s=M(e,i);void 0!==s&&t.add(s)};class bn{constructor(t){this._config=function(t){return(t=t||{}).data=un(t.data),dn(t),t}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=un(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),dn(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return pn(t,(()=>[[`datasets.${t}`,\"\"]]))}datasetAnimationScopeKeys(t,e){return pn(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,\"\"]]))}datasetElementScopeKeys(t,e){return pn(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,\"\"]]))}pluginScopeKeys(t){const e=t.id;return pn(`${this.type}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const i=this._scopeCache;let s=i.get(t);return s&&!e||(s=new Map,i.set(t,s)),s}getOptionScopes(t,e,i){const{options:s,type:n}=this,o=this._cachedScopes(t,i),a=o.get(e);if(a)return a;const r=new Set;e.forEach((e=>{t&&(r.add(t),e.forEach((e=>mn(r,t,e)))),e.forEach((t=>mn(r,s,t))),e.forEach((t=>mn(r,re[n]||{},t))),e.forEach((t=>mn(r,ue,t))),e.forEach((t=>mn(r,le,t)))}));const l=Array.from(r);return 0===l.length&&l.push(Object.create(null)),gn.has(e)&&o.set(e,l),l}chartOptionScopes(){const{options:t,type:e}=this;return[t,re[e]||{},ue.datasets[e]||{},{type:e},ue,le]}resolveNamedOptions(t,e,i,s=[\"\"]){const o={$shared:!0},{resolver:a,subPrefixes:r}=xn(this._resolverCache,t,s);let l=a;if(function(t,e){const{isScriptable:i,isIndexable:s}=Ye(t);for(const o of e){const e=i(o),a=s(o),r=(a||e)&&t[o];if(e&&(S(r)||_n(r))||a&&n(r))return!0}return!1}(a,e)){o.$shared=!1;l=$e(a,i=S(i)?i():i,this.createResolver(t,i,r))}for(const t of e)o[t]=l[t];return o}createResolver(t,e,i=[\"\"],s){const{resolver:n}=xn(this._resolverCache,t,i);return o(e)?$e(n,e,void 0,s):n}}function xn(t,e,i){let s=t.get(e);s||(s=new Map,t.set(e,s));const n=i.join();let o=s.get(n);if(!o){o={resolver:je(e,i),subPrefixes:i.filter((t=>!t.toLowerCase().includes(\"hover\")))},s.set(n,o)}return o}const _n=t=>o(t)&&Object.getOwnPropertyNames(t).reduce(((e,i)=>e||S(t[i])),!1);const yn=[\"top\",\"bottom\",\"left\",\"right\",\"chartArea\"];function vn(t,e){return\"top\"===t||\"bottom\"===t||-1===yn.indexOf(t)&&\"x\"===e}function Mn(t,e){return function(i,s){return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}}function wn(t){const e=t.chart,i=e.options.animation;e.notifyPlugins(\"afterRender\"),d(i&&i.onComplete,[t],e)}function kn(t){const e=t.chart,i=e.options.animation;d(i&&i.onProgress,[t],e)}function Sn(t){return fe()&&\"string\"==typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas),t}const Pn={},Dn=t=>{const e=Sn(t);return Object.values(Pn).filter((t=>t.canvas===e)).pop()};function Cn(t,e,i){const s=Object.keys(t);for(const n of s){const s=+n;if(s>=e){const o=t[n];delete t[n],(i>0||s>e)&&(t[s+i]=o)}}}class On{static defaults=ue;static instances=Pn;static overrides=re;static registry=en;static version=\"4.3.3\";static getChart=Dn;static register(...t){en.add(...t),An()}static unregister(...t){en.remove(...t),An()}constructor(t,e){const s=this.config=new bn(e),n=Sn(t),o=Dn(n);if(o)throw new Error(\"Canvas is already in use. Chart with ID '\"+o.id+\"' must be destroyed before the canvas with ID '\"+o.canvas.id+\"' can be reused.\");const a=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||ks(n)),this.platform.updateConfig(s);const r=this.platform.acquireContext(n,a.aspectRatio),l=r&&r.canvas,h=l&&l.height,c=l&&l.width;this.id=i(),this.ctx=r,this.canvas=l,this.width=c,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new sn,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=dt((t=>this.update(t)),a.resizeDelay||0),this._dataChanges=[],Pn[this.id]=this,r&&l?(xt.listen(this,\"complete\",wn),xt.listen(this,\"progress\",kn),this._initialize(),this.attached&&this.update()):console.error(\"Failed to create chart: can't acquire context from the given item\")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:n,_aspectRatio:o}=this;return s(t)?e&&o?o:n?i/n:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return en}_initialize(){return this.notifyPlugins(\"beforeInit\"),this.options.responsive?this.resize():ke(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins(\"afterInit\"),this}clear(){return Te(this.canvas,this.ctx),this}stop(){return xt.stop(this),this}resize(t,e){xt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const i=this.options,s=this.canvas,n=i.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,t,e,n),a=i.devicePixelRatio||this.platform.getDevicePixelRatio(),r=this.width?\"resize\":\"attach\";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,ke(this,a,!0)&&(this.notifyPlugins(\"resize\",{size:o}),d(i.onResize,[this,o],this),this.attached&&this._doResize(r)&&this.render())}ensureScalesHaveIDs(){u(this.options.scales||{},((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options,e=t.scales,i=this.scales,s=Object.keys(i).reduce(((t,e)=>(t[e]=!1,t)),{});let n=[];e&&(n=n.concat(Object.keys(e).map((t=>{const i=e[t],s=ln(t,i),n=\"r\"===s,o=\"x\"===s;return{options:i,dposition:n?\"chartArea\":o?\"bottom\":\"left\",dtype:n?\"radialLinear\":o?\"category\":\"linear\"}})))),u(n,(e=>{const n=e.options,o=n.id,a=ln(o,n),r=l(n.type,e.dtype);void 0!==n.position&&vn(n.position,a)===vn(e.dposition)||(n.position=e.dposition),s[o]=!0;let h=null;if(o in i&&i[o].type===r)h=i[o];else{h=new(en.getScale(r))({id:o,type:r,ctx:this.ctx,chart:this}),i[h.id]=h}h.init(n,t)})),u(s,((t,e)=>{t||delete i[e]})),u(i,(t=>{as.configure(this,t,t.options),as.addBox(this,t)}))}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,i=t.length;if(t.sort(((t,e)=>t.index-e.index)),i>e){for(let t=e;t<i;++t)this._destroyDatasetMeta(t);t.splice(e,i-e)}this._sortedMetasets=t.slice(0).sort(Mn(\"order\",\"index\"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach(((t,i)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(i)}))}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let i,s;for(this._removeUnreferencedMetasets(),i=0,s=e.length;i<s;i++){const s=e[i];let n=this.getDatasetMeta(i);const o=s.type||this.config.type;if(n.type&&n.type!==o&&(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||an(o,this.options),n.order=s.order||0,n.index=i,n.label=\"\"+s.label,n.visible=this.isDatasetVisible(i),n.controller)n.controller.updateIndex(i),n.controller.linkScales();else{const e=en.getController(o),{datasetElementType:s,dataElementType:a}=ue.datasets[o];Object.assign(e,{dataElementType:en.getElement(a),datasetElementType:s&&en.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}}return this._updateMetasets(),t}_resetElements(){u(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins(\"reset\")}update(t){const e=this.config;e.update();const i=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!i.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins(\"beforeUpdate\",{mode:t,cancelable:!0}))return;const n=this.buildOrUpdateControllers();this.notifyPlugins(\"beforeElementsUpdate\");let o=0;for(let t=0,e=this.data.datasets.length;t<e;t++){const{controller:e}=this.getDatasetMeta(t),i=!s&&-1===n.indexOf(e);e.buildOrUpdateElements(i),o=Math.max(+e.getMaxOverflow(),o)}o=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||u(n,(t=>{t.reset()})),this._updateDatasets(t),this.notifyPlugins(\"afterUpdate\",{mode:t}),this._layers.sort(Mn(\"z\",\"_idx\"));const{_active:a,_lastEvent:r}=this;r?this._eventHandler(r,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){u(this.scales,(t=>{as.removeBox(this,t)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),i=new Set(t.events);P(e,i)&&!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:i,start:s,count:n}of e){Cn(t,s,\"_removeElements\"===i?-n:n)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,i=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+\",\"+t.splice(1).join(\",\")))),s=i(0);for(let t=1;t<e;t++)if(!P(s,i(t)))return;return Array.from(s).map((t=>t.split(\",\"))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(!1===this.notifyPlugins(\"beforeLayout\",{cancelable:!0}))return;as.update(this,this.width,this.height,t);const e=this.chartArea,i=e.width<=0||e.height<=0;this._layers=[],u(this.boxes,(t=>{i&&\"chartArea\"===t.position||(t.configure&&t.configure(),this._layers.push(...t._layers()))}),this),this._layers.forEach(((t,e)=>{t._idx=e})),this.notifyPlugins(\"afterLayout\")}_updateDatasets(t){if(!1!==this.notifyPlugins(\"beforeDatasetsUpdate\",{mode:t,cancelable:!0})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,i=this.data.datasets.length;e<i;++e)this._updateDataset(e,S(t)?t({datasetIndex:e}):t);this.notifyPlugins(\"afterDatasetsUpdate\",{mode:t})}}_updateDataset(t,e){const i=this.getDatasetMeta(t),s={meta:i,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetUpdate\",s)&&(i.controller._update(e),s.cancelable=!1,this.notifyPlugins(\"afterDatasetUpdate\",s))}render(){!1!==this.notifyPlugins(\"beforeRender\",{cancelable:!0})&&(xt.has(this)?this.attached&&!xt.running(this)&&xt.start(this):(this.draw(),wn({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resize(t,e),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins(\"beforeDraw\",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins(\"afterDraw\")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,i=[];let s,n;for(s=0,n=e.length;s<n;++s){const n=e[s];t&&!n.visible||i.push(n)}return i}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins(\"beforeDatasetsDraw\",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins(\"afterDatasetsDraw\")}_drawDataset(t){const e=this.ctx,i=t._clip,s=!i.disabled,n=function(t){const{xScale:e,yScale:i}=t;if(e&&i)return{left:e.left,right:e.right,top:i.top,bottom:i.bottom}}(t)||this.chartArea,o={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetDraw\",o)&&(s&&Ie(e,{left:!1===i.left?0:n.left-i.left,right:!1===i.right?this.width:n.right+i.right,top:!1===i.top?0:n.top-i.top,bottom:!1===i.bottom?this.height:n.bottom+i.bottom}),t.controller.draw(),s&&ze(e),o.cancelable=!1,this.notifyPlugins(\"afterDatasetDraw\",o))}isPointInArea(t){return Re(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,i,s){const n=Xi.modes[e];return\"function\"==typeof n?n(this,t,i,s):[]}getDatasetMeta(t){const e=this.data.datasets[t],i=this._metasets;let s=i.filter((t=>t&&t._dataset===e)).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}getContext(){return this.$context||(this.$context=Ci(null,{chart:this,type:\"chart\"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const i=this.getDatasetMeta(t);return\"boolean\"==typeof i.hidden?!i.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,i){const s=i?\"show\":\"hide\",n=this.getDatasetMeta(t),o=n.controller._resolveAnimations(void 0,s);k(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((e=>e.datasetIndex===t?s:void 0)))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),xt.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins(\"beforeDestroy\");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Te(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Pn[this.id],this.notifyPlugins(\"afterDestroy\")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(t,e,i)=>{t.offsetX=e,t.offsetY=i,this._eventHandler(t)};u(this.options.events,(t=>i(t,s)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(i,s)=>{t[i]&&(e.removeEventListener(this,i,s),delete t[i])},n=(t,e)=>{this.canvas&&this.resize(t,e)};let o;const a=()=>{s(\"attach\",a),this.attached=!0,this.resize(),i(\"resize\",n),i(\"detach\",o)};o=()=>{this.attached=!1,s(\"resize\",n),this._stop(),this._resize(0,0),i(\"attach\",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){u(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._listeners={},u(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._responsiveListeners=void 0}updateHoverStyle(t,e,i){const s=i?\"set\":\"remove\";let n,o,a,r;for(\"dataset\"===e&&(n=this.getDatasetMeta(t[0].datasetIndex),n.controller[\"_\"+s+\"DatasetHoverStyle\"]()),a=0,r=t.length;a<r;++a){o=t[a];const e=o&&this.getDatasetMeta(o.datasetIndex).controller;e&&e[s+\"HoverStyle\"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],i=t.map((({datasetIndex:t,index:e})=>{const i=this.getDatasetMeta(t);if(!i)throw new Error(\"No dataset found at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}}));!f(i,e)&&(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}notifyPlugins(t,e,i){return this._plugins.notify(this,t,e,i)}isPluginEnabled(t){return 1===this._plugins._cache.filter((e=>e.plugin.id===t)).length}_updateHoverStyles(t,e,i){const s=this.options.hover,n=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index)))),o=n(e,t),a=i?t:n(t,e);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(t,e){const i={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},s=e=>(e.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins(\"beforeEvent\",i,s))return;const n=this._handleEvent(t,e,i.inChartArea);return i.cancelable=!1,this.notifyPlugins(\"afterEvent\",i,s),(n||i.changed)&&this.render(),this}_handleEvent(t,e,i){const{_active:s=[],options:n}=this,o=e,a=this._getActiveElements(t,s,i,o),r=D(t),l=function(t,e,i,s){return i&&\"mouseout\"!==t.type?s?e:t:null}(t,this._lastEvent,i,r);i&&(this._lastEvent=null,d(n.onHover,[t,a,this],this),r&&d(n.onClick,[t,a,this],this));const h=!f(a,s);return(h||e)&&(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=l,h}_getActiveElements(t,e,i,s){if(\"mouseout\"===t.type)return[];if(!i)return e;const n=this.options.hover;return this.getElementsAtEventForMode(t,n.mode,n,s)}}function An(){return u(On.instances,(t=>t._plugins.invalidate()))}function Tn(){throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\")}class Ln{static override(t){Object.assign(Ln.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Tn()}parse(){return Tn()}format(){return Tn()}add(){return Tn()}diff(){return Tn()}startOf(){return Tn()}endOf(){return Tn()}}var En={_date:Ln};function Rn(t){const e=t.iScale,i=function(t,e){if(!t._cache.$bar){const i=t.getMatchingVisibleMetas(e);let s=[];for(let e=0,n=i.length;e<n;e++)s=s.concat(i[e].controller.getAllParsedValues(t));t._cache.$bar=lt(s.sort(((t,e)=>t-e)))}return t._cache.$bar}(e,t.type);let s,n,o,a,r=e._length;const l=()=>{32767!==o&&-32768!==o&&(k(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,n=i.length;s<n;++s)o=e.getPixelForValue(i[s]),l();for(a=void 0,s=0,n=e.ticks.length;s<n;++s)o=e.getPixelForTick(s),l();return r}function In(t,e,i,s){return n(t)?function(t,e,i,s){const n=i.parse(t[0],s),o=i.parse(t[1],s),a=Math.min(n,o),r=Math.max(n,o);let l=a,h=r;Math.abs(a)>Math.abs(r)&&(l=r,h=a),e[i.axis]=h,e._custom={barStart:l,barEnd:h,start:n,end:o,min:a,max:r}}(t,e,i,s):e[i.axis]=i.parse(t,s),e}function zn(t,e,i,s){const n=t.iScale,o=t.vScale,a=n.getLabels(),r=n===o,l=[];let h,c,d,u;for(h=i,c=i+s;h<c;++h)u=e[h],d={},d[n.axis]=r||n.parse(a[h],h),l.push(In(u,d,o,h));return l}function Fn(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function Vn(t,e,i,s){let n=e.borderSkipped;const o={};if(!n)return void(t.borderSkipped=o);if(!0===n)return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:a,end:r,reverse:l,top:h,bottom:c}=function(t){let e,i,s,n,o;return t.horizontal?(e=t.base>t.x,i=\"left\",s=\"right\"):(e=t.base<t.y,i=\"bottom\",s=\"top\"),e?(n=\"end\",o=\"start\"):(n=\"start\",o=\"end\"),{start:i,end:s,reverse:e,top:n,bottom:o}}(t);\"middle\"===n&&i&&(t.enableBorderRadius=!0,(i._top||0)===s?n=h:(i._bottom||0)===s?n=c:(o[Bn(c,a,r,l)]=!0,n=h)),o[Bn(n,a,r,l)]=!0,t.borderSkipped=o}function Bn(t,e,i,s){var n,o,a;return s?(a=i,t=Wn(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=Wn(t,e,i),t}function Wn(t,e,i){return\"start\"===t?e:\"end\"===t?i:t}function Nn(t,{inflateAmount:e},i){t.inflateAmount=\"auto\"===e?1===i?.33:0:e}class Hn extends Ns{static id=\"doughnut\";static defaults={datasetElementType:!1,dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:\"number\",properties:[\"circumference\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"startAngle\",\"x\",\"y\",\"offset\",\"borderWidth\",\"spacing\"]}},cutout:\"50%\",rotation:0,circumference:360,radius:\"100%\",spacing:0,indexAxis:\"r\"};static descriptors={_scriptable:t=>\"spacing\"!==t,_indexable:t=>\"spacing\"!==t&&!t.startsWith(\"borderDash\")&&!t.startsWith(\"hoverBorderDash\")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}}};constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const i=this.getDataset().data,s=this._cachedMeta;if(!1===this._parsing)s._parsed=i;else{let n,a,r=t=>+i[t];if(o(i[t])){const{key:t=\"value\"}=this._parsing;r=e=>+M(i[e],t)}for(n=t,a=t+e;n<a;++n)s._parsed[n]=r(n)}}_getRotation(){return $(this.options.rotation-90)}_getCircumference(){return $(this.options.circumference)}_getRotationExtents(){let t=O,e=-O;for(let i=0;i<this.chart.data.datasets.length;++i)if(this.chart.isDatasetVisible(i)&&this.chart.getDatasetMeta(i).type===this._type){const s=this.chart.getDatasetMeta(i).controller,n=s._getRotation(),o=s._getCircumference();t=Math.min(t,n),e=Math.max(e,n+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:i}=e,s=this._cachedMeta,n=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,a=Math.max((Math.min(i.width,i.height)-o)/2,0),r=Math.min(h(this.options.cutout,a),1),l=this._getRingWeight(this.index),{circumference:d,rotation:u}=this._getRotationExtents(),{ratioX:f,ratioY:g,offsetX:p,offsetY:m}=function(t,e,i){let s=1,n=1,o=0,a=0;if(e<O){const r=t,l=r+e,h=Math.cos(r),c=Math.sin(r),d=Math.cos(l),u=Math.sin(l),f=(t,e,s)=>Z(t,r,l,!0)?1:Math.max(e,e*i,s,s*i),g=(t,e,s)=>Z(t,r,l,!0)?-1:Math.min(e,e*i,s,s*i),p=f(0,h,d),m=f(E,c,u),b=g(C,h,d),x=g(C+E,c,u);s=(p-b)/2,n=(m-x)/2,o=-(p+b)/2,a=-(m+x)/2}return{ratioX:s,ratioY:n,offsetX:o,offsetY:a}}(u,d,r),b=(i.width-o)/f,x=(i.height-o)/g,_=Math.max(Math.min(b,x)/2,0),y=c(this.options.radius,_),v=(y-Math.max(y*r,0))/this._getVisibleDatasetWeightTotal();this.offsetX=p*y,this.offsetY=m*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*l,0),this.updateElements(n,0,n.length,t)}_circumference(t,e){const i=this.options,s=this._cachedMeta,n=this._getCircumference();return e&&i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/O)}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.chartArea,r=o.options.animation,l=(a.left+a.right)/2,h=(a.top+a.bottom)/2,c=n&&r.animateScale,d=c?0:this.innerRadius,u=c?0:this.outerRadius,{sharedOptions:f,includeOptions:g}=this._getSharedOptions(e,s);let p,m=this._getRotation();for(p=0;p<e;++p)m+=this._circumference(p,n);for(p=e;p<e+i;++p){const e=this._circumference(p,n),i=t[p],o={x:l+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:u,innerRadius:d};g&&(o.options=f||this.resolveDataElementOptions(p,i.active?\"active\":s)),m+=e,this.updateElement(i,p,o,s)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let i,s=0;for(i=0;i<e.length;i++){const n=t._parsed[i];null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}return s}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?O*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t],i.options.locale);return{label:s[t]||\"\",value:n}}getMaxBorderWidth(t){let e=0;const i=this.chart;let s,n,o,a,r;if(!t)for(s=0,n=i.data.datasets.length;s<n;++s)if(i.isDatasetVisible(s)){o=i.getDatasetMeta(s),t=o.data,a=o.controller;break}if(!t)return 0;for(s=0,n=t.length;s<n;++s)r=a.resolveDataElementOptions(s),\"inner\"!==r.borderAlign&&(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let i=0,s=t.length;i<s;++i){const t=this.resolveDataElementOptions(i);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e}_getRingWeight(t){return Math.max(l(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class jn extends Ns{static id=\"polarArea\";static defaults={dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"]}},indexAxis:\"r\",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}},scales:{r:{type:\"radialLinear\",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t].r,i.options.locale);return{label:s[t]||\"\",value:n}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach(((t,i)=>{const s=this.getParsed(i).r;!isNaN(s)&&this.chart.getDataVisibility(i)&&(s<e.min&&(e.min=s),s>e.max&&(e.max=s))})),e}_updateRadius(){const t=this.chart,e=t.chartArea,i=t.options,s=Math.min(e.right-e.left,e.bottom-e.top),n=Math.max(s/2,0),o=(n-Math.max(i.cutoutPercentage?n/100*i.cutoutPercentage:1,0))/t.getVisibleDatasetCount();this.outerRadius=n-o*this.index,this.innerRadius=this.outerRadius-o}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.options.animation,r=this._cachedMeta.rScale,l=r.xCenter,h=r.yCenter,c=r.getIndexAngle(0)-.5*C;let d,u=c;const f=360/this.countVisibleElements();for(d=0;d<e;++d)u+=this._computeAngle(d,s,f);for(d=e;d<e+i;d++){const e=t[d];let i=u,g=u+this._computeAngle(d,s,f),p=o.getDataVisibility(d)?r.getDistanceFromCenterForValue(this.getParsed(d).r):0;u=g,n&&(a.animateScale&&(p=0),a.animateRotate&&(i=g=c));const m={x:l,y:h,innerRadius:0,outerRadius:p,startAngle:i,endAngle:g,options:this.resolveDataElementOptions(d,e.active?\"active\":s)};this.updateElement(e,d,m,s)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach(((t,i)=>{!isNaN(this.getParsed(i).r)&&this.chart.getDataVisibility(i)&&e++})),e}_computeAngle(t,e,i){return this.chart.getDataVisibility(t)?$(this.resolveDataElementOptions(t,e).angle||i):0}}var $n=Object.freeze({__proto__:null,BarController:class extends Ns{static id=\"bar\";static defaults={datasetElementType:!1,dataElementType:\"bar\",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"base\",\"width\",\"height\"]}}};static overrides={scales:{_index_:{type:\"category\",offset:!0,grid:{offset:!0}},_value_:{type:\"linear\",beginAtZero:!0}}};parsePrimitiveData(t,e,i,s){return zn(t,e,i,s)}parseArrayData(t,e,i,s){return zn(t,e,i,s)}parseObjectData(t,e,i,s){const{iScale:n,vScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=\"x\"===n.axis?a:r,h=\"x\"===o.axis?a:r,c=[];let d,u,f,g;for(d=i,u=i+s;d<u;++d)g=e[d],f={},f[n.axis]=n.parse(M(g,l),d),c.push(In(M(g,h),f,o,d));return c}updateRangeFromParsed(t,e,i,s){super.updateRangeFromParsed(t,e,i,s);const n=i._custom;n&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:i,vScale:s}=e,n=this.getParsed(t),o=n._custom,a=Fn(o)?\"[\"+o.start+\", \"+o.end+\"]\":\"\"+s.getLabelForValue(n[s.axis]);return{label:\"\"+i.getLabelForValue(n[i.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{index:a,_cachedMeta:{vScale:r}}=this,l=r.getBasePixel(),h=r.isHorizontal(),c=this._getRuler(),{sharedOptions:d,includeOptions:u}=this._getSharedOptions(e,n);for(let f=e;f<e+i;f++){const e=this.getParsed(f),i=o||s(e[r.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),g=this._calculateBarIndexPixels(f,c),p=(e._stacks||{})[r.axis],m={horizontal:h,base:i.base,enableBorderRadius:!p||Fn(e._custom)||a===p._top||a===p._bottom,x:h?i.head:g.center,y:h?g.center:i.head,height:h?g.size:Math.abs(i.size),width:h?Math.abs(i.size):g.size};u&&(m.options=d||this.resolveDataElementOptions(f,t[f].active?\"active\":n));const b=m.options||t[f].options;Vn(m,b,p,a),Nn(m,b,c.ratio),this.updateElement(t[f],f,m,n)}}_getStacks(t,e){const{iScale:i}=this._cachedMeta,n=i.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped)),o=i.options.stacked,a=[],r=t=>{const i=t.controller.getParsed(e),n=i&&i[t.vScale.axis];if(s(n)||isNaN(n))return!0};for(const i of n)if((void 0===e||!r(i))&&((!1===o||-1===a.indexOf(i.stack)||void 0===o&&void 0===i.stack)&&a.push(i.stack),i.index===t))break;return a.length||a.push(void 0),a}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,i){const s=this._getStacks(t,i),n=void 0!==e?s.indexOf(e):-1;return-1===n?s.length-1:n}_getRuler(){const t=this.options,e=this._cachedMeta,i=e.iScale,s=[];let n,o;for(n=0,o=e.data.length;n<o;++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));const a=t.barThickness;return{min:a||Rn(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:n},options:{base:o,minBarLength:a}}=this,r=o||0,l=this.getParsed(t),h=l._custom,c=Fn(h);let d,u,f=l[e.axis],g=0,p=i?this.applyStack(e,l,i):f;p!==f&&(g=p-f,p=f),c&&(f=h.barStart,p=h.barEnd-h.barStart,0!==f&&F(f)!==F(h.barEnd)&&(g=0),g+=f);const m=s(o)||c?g:o;let b=e.getPixelForValue(m);if(d=this.chart.getDataVisibility(t)?e.getPixelForValue(g+p):b,u=d-b,Math.abs(u)<a){u=function(t,e,i){return 0!==t?F(t):(e.isHorizontal()?1:-1)*(e.min>=i?1:-1)}(u,e,r)*a,f===r&&(b-=u/2);const t=e.getPixelForDecimal(0),s=e.getPixelForDecimal(1),o=Math.min(t,s),h=Math.max(t,s);b=Math.max(Math.min(b,h),o),d=b+u,i&&!c&&(l._stacks[e.axis]._visualValues[n]=e.getValueForPixel(d)-e.getValueForPixel(b))}if(b===e.getPixelForValue(r)){const t=F(u)*e.getLineWidthForValue(r)/2;b+=t,u-=t}return{size:u,base:b,head:d,center:d+u/2}}_calculateBarIndexPixels(t,e){const i=e.scale,n=this.options,o=n.skipNull,a=l(n.maxBarThickness,1/0);let r,h;if(e.grouped){const i=o?this._getStackCount(t):e.stackCount,l=\"flex\"===n.barThickness?function(t,e,i,s){const n=e.pixels,o=n[t];let a=t>0?n[t-1]:null,r=t<n.length-1?n[t+1]:null;const l=i.categoryPercentage;null===a&&(a=o-(null===r?e.end-e.start:r-o)),null===r&&(r=o+o-a);const h=o-(o-Math.min(a,r))/2*l;return{chunk:Math.abs(r-a)/2*l/s,ratio:i.barPercentage,start:h}}(t,e,n,i):function(t,e,i,n){const o=i.barThickness;let a,r;return s(o)?(a=e.min*i.categoryPercentage,r=i.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}(t,e,n,i),c=this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0);r=l.start+l.chunk*c+l.chunk/2,h=Math.min(a,l.chunk*l.ratio)}else r=i.getPixelForValue(this.getParsed(t)[i.axis],t),h=Math.min(a,e.min*e.ratio);return{base:r-h/2,head:r+h/2,center:r,size:h}}draw(){const t=this._cachedMeta,e=t.vScale,i=t.data,s=i.length;let n=0;for(;n<s;++n)null!==this.getParsed(n)[e.axis]&&i[n].draw(this._ctx)}},BubbleController:class extends Ns{static id=\"bubble\";static defaults={datasetElementType:!1,dataElementType:\"point\",animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"borderWidth\",\"radius\"]}}};static overrides={scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,i,s){const n=super.parsePrimitiveData(t,e,i,s);for(let t=0;t<n.length;t++)n[t]._custom=this.resolveDataElementOptions(t+i).radius;return n}parseArrayData(t,e,i,s){const n=super.parseArrayData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s[2],this.resolveDataElementOptions(t+i).radius)}return n}parseObjectData(t,e,i,s){const n=super.parseObjectData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s&&s.r&&+s.r,this.resolveDataElementOptions(t+i).radius)}return n}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let i=t.length-1;i>=0;--i)e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y),l=o._custom;return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+(l?\", \"+l:\"\")+\")\"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,i,s){const n=\"reset\"===s,{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:r,includeOptions:l}=this._getSharedOptions(e,s),h=o.axis,c=a.axis;for(let d=e;d<e+i;d++){const e=t[d],i=!n&&this.getParsed(d),u={},f=u[h]=n?o.getPixelForDecimal(.5):o.getPixelForValue(i[h]),g=u[c]=n?a.getBasePixel():a.getPixelForValue(i[c]);u.skip=isNaN(f)||isNaN(g),l&&(u.options=r||this.resolveDataElementOptions(d,e.active?\"active\":s),n&&(u.options.radius=0)),this.updateElement(e,d,u,s)}}resolveDataElementOptions(t,e){const i=this.getParsed(t);let s=super.resolveDataElementOptions(t,e);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const n=s.radius;return\"active\"!==e&&(s.radius=0),s.radius+=l(i&&i._custom,n),s}},DoughnutController:Hn,LineController:class extends Ns{static id=\"line\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:\"category\"},_value_:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:i,data:s=[],_dataset:n}=e,o=this.chart._animationsDisabled;let{start:a,count:r}=pt(e,s,o);this._drawStart=a,this._drawCount=r,mt(e)&&(a=0,r=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:l},t),this.updateElements(s,a,r,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,{sharedOptions:c,includeOptions:d}=this._getSharedOptions(e,n),u=a.axis,f=r.axis,{spanGaps:g,segment:p}=this.options,m=N(g)?g:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||o||\"none\"===n,x=e+i,_=t.length;let y=e>0&&this.getParsed(e-1);for(let i=0;i<_;++i){const g=t[i],_=b?g:{};if(i<e||i>=x){_.skip=!0;continue}const v=this.getParsed(i),M=s(v[f]),w=_[u]=a.getPixelForValue(v[u],i),k=_[f]=o||M?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,v,l):v[f],i);_.skip=isNaN(w)||isNaN(k)||M,_.stop=i>0&&Math.abs(v[u]-y[u])>m,p&&(_.parsed=v,_.raw=h.data[i]),d&&(_.options=c||this.resolveDataElementOptions(i,g.active?\"active\":n)),b||this.updateElement(g,i,_,n),y=v}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,i=e.options&&e.options.borderWidth||0,s=t.data||[];if(!s.length)return i;const n=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(i,n,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}},PieController:class extends Hn{static id=\"pie\";static defaults={cutout:0,rotation:0,circumference:360,radius:\"100%\"}},PolarAreaController:jn,RadarController:class extends Ns{static id=\"radar\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",indexAxis:\"r\",showLine:!0,elements:{line:{fill:\"start\"}}};static overrides={aspectRatio:1,scales:{r:{type:\"radialLinear\"}}};getLabelAndValue(t){const e=this._cachedMeta.vScale,i=this.getParsed(t);return{label:e.getLabels()[t],value:\"\"+e.getLabelForValue(i[e.axis])}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta,i=e.dataset,s=e.data||[],n=e.iScale.getLabels();if(i.points=s,\"resize\"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const o={_loop:!0,_fullLoop:n.length===s.length,options:e};this.updateElement(i,void 0,o,t)}this.updateElements(s,0,s.length,t)}updateElements(t,e,i,s){const n=this._cachedMeta.rScale,o=\"reset\"===s;for(let a=e;a<e+i;a++){const e=t[a],i=this.resolveDataElementOptions(a,e.active?\"active\":s),r=n.getPointPositionForValue(a,this.getParsed(a).r),l=o?n.xCenter:r.x,h=o?n.yCenter:r.y,c={x:l,y:h,angle:r.angle,skip:isNaN(l)||isNaN(h),options:i};this.updateElement(e,a,c,s)}}},ScatterController:class extends Ns{static id=\"scatter\";static defaults={datasetElementType:!1,dataElementType:\"point\",showLine:!1,fill:!1};static overrides={interaction:{mode:\"point\"},scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y);return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+\")\"}}update(t){const e=this._cachedMeta,{data:i=[]}=e,s=this.chart._animationsDisabled;let{start:n,count:o}=pt(e,i,s);if(this._drawStart=n,this._drawCount=o,mt(e)&&(n=0,o=i.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:n,_dataset:o}=e;n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!o._decimated,n.points=i;const a=this.resolveDatasetElementOptions(t);a.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:a},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(i,n,o,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement(\"line\")),super.addElements()}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,c=this.resolveDataElementOptions(e,n),d=this.getSharedOptions(c),u=this.includeOptions(n,d),f=a.axis,g=r.axis,{spanGaps:p,segment:m}=this.options,b=N(p)?p:Number.POSITIVE_INFINITY,x=this.chart._animationsDisabled||o||\"none\"===n;let _=e>0&&this.getParsed(e-1);for(let c=e;c<e+i;++c){const e=t[c],i=this.getParsed(c),p=x?e:{},y=s(i[g]),v=p[f]=a.getPixelForValue(i[f],c),M=p[g]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,i,l):i[g],c);p.skip=isNaN(v)||isNaN(M)||y,p.stop=c>0&&Math.abs(i[f]-_[f])>b,m&&(p.parsed=i,p.raw=h.data[c]),u&&(p.options=d||this.resolveDataElementOptions(c,e.active?\"active\":n)),x||this.updateElement(e,c,p,n),_=i}this.updateSharedOptions(d,n,c)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let t=0;for(let i=e.length-1;i>=0;--i)t=Math.max(t,e[i].size(this.resolveDataElementOptions(i))/2);return t>0&&t}const i=t.dataset,s=i.options&&i.options.borderWidth||0;if(!e.length)return s;const n=e[0].size(this.resolveDataElementOptions(0)),o=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(s,n,o)/2}}});function Yn(t,e,i,s){const n=vi(t.options.borderRadius,[\"outerStart\",\"outerEnd\",\"innerStart\",\"innerEnd\"]);const o=(i-e)/2,a=Math.min(o,s*e/2),r=t=>{const e=(i-Math.min(o,t))*s/2;return J(t,0,Math.min(o,e))};return{outerStart:r(n.outerStart),outerEnd:r(n.outerEnd),innerStart:J(n.innerStart,0,a),innerEnd:J(n.innerEnd,0,a)}}function Un(t,e,i,s){return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}function Xn(t,e,i,s,n,o){const{x:a,y:r,startAngle:l,pixelMargin:h,innerRadius:c}=e,d=Math.max(e.outerRadius+s+i-h,0),u=c>0?c+s+i+h:0;let f=0;const g=n-l;if(s){const t=((c>0?c-s:0)+(d>0?d-s:0))/2;f=(g-(0!==t?g*t/(t+s):g))/2}const p=(g-Math.max(.001,g*d-i/C)/d)/2,m=l+p+f,b=n-p-f,{outerStart:x,outerEnd:_,innerStart:y,innerEnd:v}=Yn(e,u,d,b-m),M=d-x,w=d-_,k=m+x/M,S=b-_/w,P=u+y,D=u+v,O=m+y/P,A=b-v/D;if(t.beginPath(),o){const e=(k+S)/2;if(t.arc(a,r,d,k,e),t.arc(a,r,d,e,S),_>0){const e=Un(w,S,a,r);t.arc(e.x,e.y,_,S,b+E)}const i=Un(D,b,a,r);if(t.lineTo(i.x,i.y),v>0){const e=Un(D,A,a,r);t.arc(e.x,e.y,v,b+E,A+Math.PI)}const s=(b-v/u+(m+y/u))/2;if(t.arc(a,r,u,b-v/u,s,!0),t.arc(a,r,u,s,m+y/u,!0),y>0){const e=Un(P,O,a,r);t.arc(e.x,e.y,y,O+Math.PI,m-E)}const n=Un(M,m,a,r);if(t.lineTo(n.x,n.y),x>0){const e=Un(M,k,a,r);t.arc(e.x,e.y,x,m-E,k)}}else{t.moveTo(a,r);const e=Math.cos(k)*d+a,i=Math.sin(k)*d+r;t.lineTo(e,i);const s=Math.cos(S)*d+a,n=Math.sin(S)*d+r;t.lineTo(s,n)}t.closePath()}function qn(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r,options:l}=e,{borderWidth:h,borderJoinStyle:c,borderDash:d,borderDashOffset:u}=l,f=\"inner\"===l.borderAlign;if(!h)return;t.setLineDash(d||[]),t.lineDashOffset=u,f?(t.lineWidth=2*h,t.lineJoin=c||\"round\"):(t.lineWidth=h,t.lineJoin=c||\"bevel\");let g=e.endAngle;if(o){Xn(t,e,i,s,g,n);for(let e=0;e<o;++e)t.stroke();isNaN(r)||(g=a+(r%O||O))}f&&function(t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=e;let h=n/r;t.beginPath(),t.arc(o,a,r,s-h,i+h),l>n?(h=n/l,t.arc(o,a,l,i+h,s-h,!0)):t.arc(o,a,n,i+E,s-E),t.closePath(),t.clip()}(t,e,g),o||(Xn(t,e,i,s,g,n),t.stroke())}function Kn(t,e,i=e){t.lineCap=l(i.borderCapStyle,e.borderCapStyle),t.setLineDash(l(i.borderDash,e.borderDash)),t.lineDashOffset=l(i.borderDashOffset,e.borderDashOffset),t.lineJoin=l(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=l(i.borderWidth,e.borderWidth),t.strokeStyle=l(i.borderColor,e.borderColor)}function Gn(t,e,i){t.lineTo(i.x,i.y)}function Zn(t,e,i={}){const s=t.length,{start:n=0,end:o=s-1}=i,{start:a,end:r}=e,l=Math.max(n,a),h=Math.min(o,r),c=n<a&&o<a||n>r&&o>r;return{count:s,start:l,loop:e.loop,ilen:h<l&&!c?s+h-l:h-l}}function Jn(t,e,i,s){const{points:n,options:o}=e,{count:a,start:r,loop:l,ilen:h}=Zn(n,i,s),c=function(t){return t.stepped?Fe:t.tension||\"monotone\"===t.cubicInterpolationMode?Ve:Gn}(o);let d,u,f,{move:g=!0,reverse:p}=s||{};for(d=0;d<=h;++d)u=n[(r+(p?h-d:d))%a],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);return l&&(u=n[(r+(p?h:0))%a],c(t,f,u,p,o.stepped)),!!l}function Qn(t,e,i,s){const n=e.points,{count:o,start:a,ilen:r}=Zn(n,i,s),{move:l=!0,reverse:h}=s||{};let c,d,u,f,g,p,m=0,b=0;const x=t=>(a+(h?r-t:t))%o,_=()=>{f!==g&&(t.lineTo(m,g),t.lineTo(m,f),t.lineTo(m,p))};for(l&&(d=n[x(0)],t.moveTo(d.x,d.y)),c=0;c<=r;++c){if(d=n[x(c)],d.skip)continue;const e=d.x,i=d.y,s=0|e;s===u?(i<f?f=i:i>g&&(g=i),m=(b*m+e)/++b):(_(),t.lineTo(e,i),u=s,b=0,f=g=i),p=i}_()}function to(t){const e=t.options,i=e.borderDash&&e.borderDash.length;return!(t._decimated||t._loop||e.tension||\"monotone\"===e.cubicInterpolationMode||e.stepped||i)?Qn:Jn}const eo=\"function\"==typeof Path2D;function io(t,e,i,s){eo&&!e.options.segment?function(t,e,i,s){let n=e._path;n||(n=e._path=new Path2D,e.path(n,i,s)&&n.closePath()),Kn(t,e.options),t.stroke(n)}(t,e,i,s):function(t,e,i,s){const{segments:n,options:o}=e,a=to(e);for(const r of n)Kn(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&&t.closePath(),t.stroke()}(t,e,i,s)}class so extends Hs{static id=\"line\";static defaults={borderCapStyle:\"butt\",borderDash:[],borderDashOffset:0,borderJoinStyle:\"miter\",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:\"default\",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t&&\"fill\"!==t};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const i=this.options;if((i.tension||\"monotone\"===i.cubicInterpolationMode)&&!i.stepped&&!this._pointsUpdated){const s=i.spanGaps?this._loop:this._fullLoop;hi(this._points,i,t,s,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=zi(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,i=t.length;return i&&e[t[i-1].end]}interpolate(t,e){const i=this.options,s=t[e],n=this.points,o=Ii(this,{property:e,start:s,end:s});if(!o.length)return;const a=[],r=function(t){return t.stepped?pi:t.tension||\"monotone\"===t.cubicInterpolationMode?mi:gi}(i);let l,h;for(l=0,h=o.length;l<h;++l){const{start:h,end:c}=o[l],d=n[h],u=n[c];if(d===u){a.push(d);continue}const f=r(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);f[e]=t[e],a.push(f)}return 1===a.length?a[0]:a}pathSegment(t,e,i){return to(this)(t,this,e,i)}path(t,e,i){const s=this.segments,n=to(this);let o=this._loop;e=e||0,i=i||this.points.length-e;for(const a of s)o&=n(t,this,a,{start:e,end:e+i-1});return!!o}draw(t,e,i,s){const n=this.options||{};(this.points||[]).length&&n.borderWidth&&(t.save(),io(t,this,i,s),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function no(t,e,i,s){const n=t.options,{[i]:o}=t.getProps([i],s);return Math.abs(e-o)<n.radius+n.hitRadius}function oo(t,e){const{x:i,y:s,base:n,width:o,height:a}=t.getProps([\"x\",\"y\",\"base\",\"width\",\"height\"],e);let r,l,h,c,d;return t.horizontal?(d=a/2,r=Math.min(i,n),l=Math.max(i,n),h=s-d,c=s+d):(d=o/2,r=i-d,l=i+d,h=Math.min(s,n),c=Math.max(s,n)),{left:r,top:h,right:l,bottom:c}}function ao(t,e,i,s){return t?0:J(e,i,s)}function ro(t){const e=oo(t),i=e.right-e.left,s=e.bottom-e.top,n=function(t,e,i){const s=t.options.borderWidth,n=t.borderSkipped,o=Mi(s);return{t:ao(n.top,o.top,0,i),r:ao(n.right,o.right,0,e),b:ao(n.bottom,o.bottom,0,i),l:ao(n.left,o.left,0,e)}}(t,i/2,s/2),a=function(t,e,i){const{enableBorderRadius:s}=t.getProps([\"enableBorderRadius\"]),n=t.options.borderRadius,a=wi(n),r=Math.min(e,i),l=t.borderSkipped,h=s||o(n);return{topLeft:ao(!h||l.top||l.left,a.topLeft,0,r),topRight:ao(!h||l.top||l.right,a.topRight,0,r),bottomLeft:ao(!h||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:ao(!h||l.bottom||l.right,a.bottomRight,0,r)}}(t,i/2,s/2);return{outer:{x:e.left,y:e.top,w:i,h:s,radius:a},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,a.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(n.b,n.r))}}}}function lo(t,e,i,s){const n=null===e,o=null===i,a=t&&!(n&&o)&&oo(t,s);return a&&(n||tt(e,a.left,a.right))&&(o||tt(i,a.top,a.bottom))}function ho(t,e){t.rect(e.x,e.y,e.w,e.h)}function co(t,e,i={}){const s=t.x!==i.x?-e:0,n=t.y!==i.y?-e:0,o=(t.x+t.w!==i.x+i.w?e:0)-s,a=(t.y+t.h!==i.y+i.h?e:0)-n;return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}var uo=Object.freeze({__proto__:null,ArcElement:class extends Hs{static id=\"arc\";static defaults={borderAlign:\"center\",borderColor:\"#fff\",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0};static defaultRoutes={backgroundColor:\"backgroundColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.getProps([\"x\",\"y\"],i),{angle:n,distance:o}=X(s,{x:t,y:e}),{startAngle:a,endAngle:r,innerRadius:h,outerRadius:c,circumference:d}=this.getProps([\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"circumference\"],i),u=(this.options.spacing+this.options.borderWidth)/2,f=l(d,r-a)>=O||Z(n,a,r),g=tt(o,h+u,c+u);return f&&g}getCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=this.getProps([\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"],t),{offset:r,spacing:l}=this.options,h=(s+n)/2,c=(o+a+l+r)/2;return{x:e+Math.cos(h)*c,y:i+Math.sin(h)*c}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:i}=this,s=(e.offset||0)/4,n=(e.spacing||0)/2,o=e.circular;if(this.pixelMargin=\"inner\"===e.borderAlign?.33:0,this.fullCircles=i>O?Math.floor(i/O):0,0===i||this.innerRadius<0||this.outerRadius<0)return;t.save();const a=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(a)*s,Math.sin(a)*s);const r=s*(1-Math.sin(Math.min(C,i||0)));t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,function(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r}=e;let l=e.endAngle;if(o){Xn(t,e,i,s,l,n);for(let e=0;e<o;++e)t.fill();isNaN(r)||(l=a+(r%O||O))}Xn(t,e,i,s,l,n),t.fill()}(t,this,r,n,o),qn(t,this,r,n,o),t.restore()}},BarElement:class extends Hs{static id=\"bar\";static defaults={borderSkipped:\"start\",borderWidth:0,borderRadius:0,inflateAmount:\"auto\",pointStyle:void 0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=this,{inner:n,outer:o}=ro(this),a=(r=o.radius).topLeft||r.topRight||r.bottomLeft||r.bottomRight?He:ho;var r;t.save(),o.w===n.w&&o.h===n.h||(t.beginPath(),a(t,co(o,e,n)),t.clip(),a(t,co(n,-e,o)),t.fillStyle=i,t.fill(\"evenodd\")),t.beginPath(),a(t,co(n,e)),t.fillStyle=s,t.fill(),t.restore()}inRange(t,e,i){return lo(this,t,e,i)}inXRange(t,e){return lo(this,t,null,e)}inYRange(t,e){return lo(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=this.getProps([\"x\",\"y\",\"base\",\"horizontal\"],t);return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}getRange(t){return\"x\"===t?this.width/2:this.height/2}},LineElement:so,PointElement:class extends Hs{static id=\"point\";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:\"circle\",radius:3,rotation:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.options,{x:n,y:o}=this.getProps([\"x\",\"y\"],i);return Math.pow(t-n,2)+Math.pow(e-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(t,e){return no(this,t,\"x\",e)}inYRange(t,e){return no(this,t,\"y\",e)}getCenterPoint(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}size(t){let e=(t=t||this.options||{}).radius||0;e=Math.max(e,e&&t.hoverRadius||0);return 2*(e+(e&&t.borderWidth||0))}draw(t,e){const i=this.options;this.skip||i.radius<.1||!Re(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Le(t,i,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}});function fo(t,e,i,s){const n=t.indexOf(e);if(-1===n)return((t,e,i,s)=>(\"string\"==typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&&(i=null),i))(t,e,i,s);return n!==t.lastIndexOf(e)?i:n}function go(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}function po(t,e,{horizontal:i,minRotation:s}){const n=$(s),o=(i?Math.sin(n):Math.cos(n))||.001,a=.75*e*(\"\"+t).length;return Math.min(e/o,a)}class mo extends Js{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return s(t)||(\"number\"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:i}=this.getUserBounds();let{min:s,max:n}=this;const o=t=>s=e?s:t,a=t=>n=i?n:t;if(t){const t=F(s),e=F(n);t<0&&e<0?a(0):t>0&&e>0&&o(0)}if(s===n){let e=0===n?1:Math.abs(.05*n);a(n+e),t||o(s-e)}this.min=s,this.max=n}getTickLimit(){const t=this.options.ticks;let e,{maxTicksLimit:i,stepSize:s}=t;return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&&(e=Math.min(i,e)),e}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let i=this.getTickLimit();i=Math.max(2,i);const n=function(t,e){const i=[],{bounds:n,step:o,min:a,max:r,precision:l,count:h,maxTicks:c,maxDigits:d,includeBounds:u}=t,f=o||1,g=c-1,{min:p,max:m}=e,b=!s(a),x=!s(r),_=!s(h),y=(m-p)/(d+1);let v,M,w,k,S=B((m-p)/g/f)*f;if(S<1e-14&&!b&&!x)return[{value:p},{value:m}];k=Math.ceil(m/S)-Math.floor(p/S),k>g&&(S=B(k*S/g/f)*f),s(l)||(v=Math.pow(10,l),S=Math.ceil(S*v)/v),\"ticks\"===n?(M=Math.floor(p/S)*S,w=Math.ceil(m/S)*S):(M=p,w=m),b&&x&&o&&H((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,M=a,w=r):_?(M=b?a:M,w=x?r:w,k=h-1,S=(w-M)/k):(k=(w-M)/S,k=V(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));const P=Math.max(U(S),U(M));v=Math.pow(10,s(l)?P:l),M=Math.round(M*v)/v,w=Math.round(w*v)/v;let D=0;for(b&&(u&&M!==a?(i.push({value:a}),M<a&&D++,V(Math.round((M+D*S)*v)/v,a,po(a,y,t))&&D++):M<a&&D++);D<k;++D){const t=Math.round((M+D*S)*v)/v;if(x&&t>r)break;i.push({value:t})}return x&&u&&w!==r?i.length&&V(i[i.length-1].value,r,po(r,y,t))?i[i.length-1].value=r:i.push({value:r}):x&&w!==r||i.push({value:w}),i}({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return\"ticks\"===t.bounds&&j(n,this,\"value\"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}configure(){const t=this.ticks;let e=this.min,i=this.max;if(super.configure(),this.options.offset&&t.length){const s=(i-e)/Math.max(t.length-1,1)/2;e-=s,i+=s}this._startValue=e,this._endValue=i,this._valueRange=i-e}getLabelForValue(t){return ne(t,this.chart.options.locale,this.options.ticks.format)}}class bo extends mo{static id=\"linear\";static defaults={ticks:{callback:ae.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?t:0,this.max=a(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,i=$(this.options.ticks.minRotation),s=(t?Math.sin(i):Math.cos(i))||.001,n=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,n.lineHeight/s))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const xo=t=>Math.floor(z(t)),_o=(t,e)=>Math.pow(10,xo(t)+e);function yo(t){return 1===t/Math.pow(10,xo(t))}function vo(t,e,i){const s=Math.pow(10,i),n=Math.floor(t/s);return Math.ceil(e/s)-n}function Mo(t,{min:e,max:i}){e=r(t.min,e);const s=[],n=xo(e);let o=function(t,e){let i=xo(e-t);for(;vo(t,e,i)>10;)i++;for(;vo(t,e,i)<10;)i--;return Math.min(i,xo(t))}(e,i),a=o<0?Math.pow(10,Math.abs(o)):1;const l=Math.pow(10,o),h=n>o?Math.pow(10,n):0,c=Math.round((e-h)*a)/a,d=Math.floor((e-h)/l/10)*l*10;let u=Math.floor((c-d)/Math.pow(10,o)),f=r(t.min,Math.round((h+d+u*Math.pow(10,o))*a)/a);for(;f<i;)s.push({value:f,major:yo(f),significand:u}),u>=10?u=u<15?15:20:u++,u>=20&&(o++,u=2,a=o>=0?1:a),f=Math.round((h+d+u*Math.pow(10,o))*a)/a;const g=r(t.max,f);return s.push({value:g,major:yo(g),significand:u}),s}class wo extends Js{static id=\"logarithmic\";static defaults={ticks:{callback:ae.formatters.logarithmic,major:{enabled:!0}}};constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const i=mo.prototype.parse.apply(this,[t,e]);if(0!==i)return a(i)&&i>0?i:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?Math.max(0,t):null,this.max=a(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!a(this._userMin)&&(this.min=t===_o(this.min,0)?_o(this.min,-1):_o(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let i=this.min,s=this.max;const n=e=>i=t?i:e,o=t=>s=e?s:t;i===s&&(i<=0?(n(1),o(10)):(n(_o(i,-1)),o(_o(s,1)))),i<=0&&n(_o(s,-1)),s<=0&&o(_o(i,1)),this.min=i,this.max=s}buildTicks(){const t=this.options,e=Mo({min:this._userMin,max:this._userMax},this);return\"ticks\"===t.bounds&&j(e,this,\"value\"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}getLabelForValue(t){return void 0===t?\"0\":ne(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=z(t),this._valueRange=z(this.max)-z(t)}getPixelForValue(t){return void 0!==t&&0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(z(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function ko(t){const e=t.ticks;if(e.display&&t.display){const t=ki(e.backdropPadding);return l(e.font&&e.font.size,ue.font.size)+t.height}return 0}function So(t,e,i,s,n){return t===s||t===n?{start:e-i/2,end:e+i/2}:t<s||t>n?{start:e-i,end:e}:{start:e,end:e+i}}function Po(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},i=Object.assign({},e),s=[],o=[],a=t._pointLabels.length,r=t.options.pointLabels,l=r.centerPointLabels?C/a:0;for(let u=0;u<a;u++){const a=r.setContext(t.getPointLabelContext(u));o[u]=a.padding;const f=t.getPointPosition(u,t.drawingArea+o[u],l),g=Si(a.font),p=(h=t.ctx,c=g,d=n(d=t._pointLabels[u])?d:[d],{w:Oe(h,c.string,d),h:d.length*c.lineHeight});s[u]=p;const m=G(t.getIndexAngle(u)+l),b=Math.round(Y(m));Do(i,e,m,So(b,f.x,p.w,0,180),So(b,f.y,p.h,90,270))}var h,c,d;t.setCenterPoint(e.l-i.l,i.r-e.r,e.t-i.t,i.b-e.b),t._pointLabelItems=function(t,e,i){const s=[],n=t._pointLabels.length,o=t.options,{centerPointLabels:a,display:r}=o.pointLabels,l={extra:ko(o)/2,additionalAngle:a?C/n:0};let h;for(let o=0;o<n;o++){l.padding=i[o],l.size=e[o];const n=Co(t,o,l);s.push(n),\"auto\"===r&&(n.visible=Oo(n,h),n.visible&&(h=n))}return s}(t,s,o)}function Do(t,e,i,s,n){const o=Math.abs(Math.sin(i)),a=Math.abs(Math.cos(i));let r=0,l=0;s.start<e.l?(r=(e.l-s.start)/o,t.l=Math.min(t.l,e.l-r)):s.end>e.r&&(r=(s.end-e.r)/o,t.r=Math.max(t.r,e.r+r)),n.start<e.t?(l=(e.t-n.start)/a,t.t=Math.min(t.t,e.t-l)):n.end>e.b&&(l=(n.end-e.b)/a,t.b=Math.max(t.b,e.b+l))}function Co(t,e,i){const s=t.drawingArea,{extra:n,additionalAngle:o,padding:a,size:r}=i,l=t.getPointPosition(e,s+n+a,o),h=Math.round(Y(G(l.angle+E))),c=function(t,e,i){90===i||270===i?t-=e/2:(i>270||i<90)&&(t-=e);return t}(l.y,r.h,h),d=function(t){if(0===t||180===t)return\"center\";if(t<180)return\"left\";return\"right\"}(h),u=function(t,e,i){\"right\"===i?t-=e:\"center\"===i&&(t-=e/2);return t}(l.x,r.w,d);return{visible:!0,x:l.x,y:c,textAlign:d,left:u,top:c,right:u+r.w,bottom:c+r.h}}function Oo(t,e){if(!e)return!0;const{left:i,top:s,right:n,bottom:o}=t;return!(Re({x:i,y:s},e)||Re({x:i,y:o},e)||Re({x:n,y:s},e)||Re({x:n,y:o},e))}function Ao(t,e,i){const{left:n,top:o,right:a,bottom:r}=i,{backdropColor:l}=e;if(!s(l)){const i=wi(e.borderRadius),s=ki(e.backdropPadding);t.fillStyle=l;const h=n-s.left,c=o-s.top,d=a-n+s.width,u=r-o+s.height;Object.values(i).some((t=>0!==t))?(t.beginPath(),He(t,{x:h,y:c,w:d,h:u,radius:i}),t.fill()):t.fillRect(h,c,d,u)}}function To(t,e,i,s){const{ctx:n}=t;if(i)n.arc(t.xCenter,t.yCenter,e,0,O);else{let i=t.getPointPosition(0,e);n.moveTo(i.x,i.y);for(let o=1;o<s;o++)i=t.getPointPosition(o,e),n.lineTo(i.x,i.y)}}class Lo extends mo{static id=\"radialLinear\";static defaults={display:!0,animate:!0,position:\"chartArea\",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:ae.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:t=>t,padding:5,centerPointLabels:!1}};static defaultRoutes={\"angleLines.color\":\"borderColor\",\"pointLabels.color\":\"color\",\"ticks.color\":\"color\"};static descriptors={angleLines:{_fallback:\"grid\"}};constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=ki(ko(this.options)/2),e=this.width=this.maxWidth-t.width,i=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=a(t)&&!isNaN(t)?t:0,this.max=a(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/ko(this.options))}generateTickLabels(t){mo.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map(((t,e)=>{const i=d(this.options.pointLabels.callback,[t,e],this);return i||0===i?i:\"\"})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?Po(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,i,s){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}getIndexAngle(t){return G(t*(O/(this._pointLabels.length||1))+$(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(s(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(s(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const i=e[t];return function(t,e,i){return Ci(t,{label:i,index:e,type:\"pointLabel\"})}(this.getContext(),t,i)}}getPointPosition(t,e,i=0){const s=this.getIndexAngle(t)-E+i;return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:i,right:s,bottom:n}=this._pointLabelItems[t];return{left:e,top:i,right:s,bottom:n}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const i=this.ctx;i.save(),i.beginPath(),To(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:i,grid:s,border:n}=e,o=this._pointLabels.length;let a,r,l;if(e.pointLabels.display&&function(t,e){const{ctx:i,options:{pointLabels:s}}=t;for(let n=e-1;n>=0;n--){const e=t._pointLabelItems[n];if(!e.visible)continue;const o=s.setContext(t.getPointLabelContext(n));Ao(i,o,e);const a=Si(o.font),{x:r,y:l,textAlign:h}=e;Ne(i,t._pointLabels[n],r,l+a.lineHeight/2,a,{color:o.color,textAlign:h,textBaseline:\"middle\"})}}(this,o),s.display&&this.ticks.forEach(((t,e)=>{if(0!==e){r=this.getDistanceFromCenterForValue(t.value);const i=this.getContext(e),a=s.setContext(i),l=n.setContext(i);!function(t,e,i,s,n){const o=t.ctx,a=e.circular,{color:r,lineWidth:l}=e;!a&&!s||!r||!l||i<0||(o.save(),o.strokeStyle=r,o.lineWidth=l,o.setLineDash(n.dash),o.lineDashOffset=n.dashOffset,o.beginPath(),To(t,i,a,s),o.closePath(),o.stroke(),o.restore())}(this,a,r,o,l)}})),i.display){for(t.save(),a=o-1;a>=0;a--){const s=i.setContext(this.getPointLabelContext(a)),{color:n,lineWidth:o}=s;o&&n&&(t.lineWidth=o,t.strokeStyle=n,t.setLineDash(s.borderDash),t.lineDashOffset=s.borderDashOffset,r=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(a,r),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,i=e.ticks;if(!i.display)return;const s=this.getIndexAngle(0);let n,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign=\"center\",t.textBaseline=\"middle\",this.ticks.forEach(((s,a)=>{if(0===a&&!e.reverse)return;const r=i.setContext(this.getContext(a)),l=Si(r.font);if(n=this.getDistanceFromCenterForValue(this.ticks[a].value),r.showLabelBackdrop){t.font=l.string,o=t.measureText(s.label).width,t.fillStyle=r.backdropColor;const e=ki(r.backdropPadding);t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}Ne(t,s.label,0,-n,l,{color:r.color,strokeColor:r.textStrokeColor,strokeWidth:r.textStrokeWidth})})),t.restore()}drawTitle(){}}const Eo={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Ro=Object.keys(Eo);function Io(t,e){return t-e}function zo(t,e){if(s(e))return null;const i=t._adapter,{parser:n,round:o,isoWeekday:r}=t._parseOpts;let l=e;return\"function\"==typeof n&&(l=n(l)),a(l)||(l=\"string\"==typeof n?i.parse(l,n):i.parse(l)),null===l?null:(o&&(l=\"week\"!==o||!N(r)&&!0!==r?i.startOf(l,o):i.startOf(l,\"isoWeek\",r)),+l)}function Fo(t,e,i,s){const n=Ro.length;for(let o=Ro.indexOf(t);o<n-1;++o){const t=Eo[Ro[o]],n=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((i-e)/(n*t.size))<=s)return Ro[o]}return Ro[n-1]}function Vo(t,e,i){if(i){if(i.length){const{lo:s,hi:n}=et(i,e);t[i[s]>=e?i[s]:i[n]]=!0}}else t[e]=!0}function Bo(t,e,i){const s=[],n={},o=e.length;let a,r;for(a=0;a<o;++a)r=e[a],n[r]=a,s.push({value:r,major:!1});return 0!==o&&i?function(t,e,i,s){const n=t._adapter,o=+n.startOf(e[0].value,s),a=e[e.length-1].value;let r,l;for(r=o;r<=a;r=+n.add(r,1,s))l=i[r],l>=0&&(e[l].major=!0);return e}(t,s,n,i):s}class Wo extends Js{static id=\"time\";static defaults={bounds:\"data\",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:\"millisecond\",displayFormats:{}},ticks:{source:\"auto\",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit=\"day\",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const i=t.time||(t.time={}),s=this._adapter=new En._date(t.adapters.date);s.init(e),x(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return void 0===t?null:zo(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,i=t.time.unit||\"day\";let{min:s,max:n,minDefined:o,maxDefined:r}=this.getUserBounds();function l(t){o||isNaN(t.min)||(s=Math.min(s,t.min)),r||isNaN(t.max)||(n=Math.max(n,t.max))}o&&r||(l(this._getLabelBounds()),\"ticks\"===t.bounds&&\"labels\"===t.ticks.source||l(this.getMinMax(!1))),s=a(s)&&!isNaN(s)?s:+e.startOf(Date.now(),i),n=a(n)&&!isNaN(n)?n:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,n-1),this.max=Math.max(s+1,n)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],i=t[t.length-1]),{min:e,max:i}}buildTicks(){const t=this.options,e=t.time,i=t.ticks,s=\"labels\"===i.source?this.getLabelTimestamps():this._generate();\"ticks\"===t.bounds&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const n=this.min,o=nt(s,n,this.max);return this._unit=e.unit||(i.autoSkip?Fo(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):function(t,e,i,s,n){for(let o=Ro.length-1;o>=Ro.indexOf(i);o--){const i=Ro[o];if(Eo[i].common&&t._adapter.diff(n,s,i)>=e-1)return i}return Ro[i?Ro.indexOf(i):0]}(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=i.major.enabled&&\"year\"!==this._unit?function(t){for(let e=Ro.indexOf(t)+1,i=Ro.length;e<i;++e)if(Eo[Ro[e]].common)return Ro[e]}(this._unit):void 0,this.initOffsets(s),t.reverse&&o.reverse(),Bo(this,o,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e,i,s=0,n=0;this.options.offset&&t.length&&(e=this.getDecimalForValue(t[0]),s=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,i=this.getDecimalForValue(t[t.length-1]),n=1===t.length?i:(i-this.getDecimalForValue(t[t.length-2]))/2);const o=t.length<3?.5:.25;s=J(s,0,o),n=J(n,0,o),this._offsets={start:s,end:n,factor:1/(s+1+n)}}_generate(){const t=this._adapter,e=this.min,i=this.max,s=this.options,n=s.time,o=n.unit||Fo(n.minUnit,e,i,this._getLabelCapacity(e)),a=l(s.ticks.stepSize,1),r=\"week\"===o&&n.isoWeekday,h=N(r)||!0===r,c={};let d,u,f=e;if(h&&(f=+t.startOf(f,\"isoWeek\",r)),f=+t.startOf(f,h?\"day\":o),t.diff(i,e,o)>1e5*a)throw new Error(e+\" and \"+i+\" are too far apart with stepSize of \"+a+\" \"+o);const g=\"data\"===s.ticks.source&&this.getDataTimestamps();for(d=f,u=0;d<i;d=+t.add(d,a,o),u++)Vo(c,d,g);return d!==i&&\"ticks\"!==s.bounds&&1!==u||Vo(c,d,g),Object.keys(c).sort(Io).map((t=>+t))}getLabelForValue(t){const e=this._adapter,i=this.options.time;return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}format(t,e){const i=this.options.time.displayFormats,s=this._unit,n=e||i[s];return this._adapter.format(t,n)}_tickFormatFunction(t,e,i,s){const n=this.options,o=n.ticks.callback;if(o)return d(o,[t,e,i],this);const a=n.time.displayFormats,r=this._unit,l=this._majorUnit,h=r&&a[r],c=l&&a[l],u=i[e],f=l&&c&&u&&u.major;return this._adapter.format(t,s||(f?c:h))}generateTickLabels(t){let e,i,s;for(e=0,i=t.length;e<i;++e)s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,i=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+i)*e.factor)}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+i*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,i=this.ctx.measureText(t).width,s=$(this.isHorizontal()?e.maxRotation:e.minRotation),n=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:i*n+a*o,h:i*o+a*n}}_getLabelCapacity(t){const e=this.options.time,i=e.displayFormats,s=i[e.unit]||i.millisecond,n=this._tickFormatFunction(t,0,Bo(this,[t],this._majorUnit),s),o=this._getLabelSize(n),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t,e,i=this._cache.data||[];if(i.length)return i;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,e=s.length;t<e;++t)i=i.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(i)}getLabelTimestamps(){const t=this._cache.labels||[];let e,i;if(t.length)return t;const s=this.getLabels();for(e=0,i=s.length;e<i;++e)t.push(zo(this,s[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return lt(t.sort(Io))}}function No(t,e,i){let s,n,o,a,r=0,l=t.length-1;i?(e>=t[r].pos&&e<=t[l].pos&&({lo:r,hi:l}=it(t,\"pos\",e)),({pos:s,time:o}=t[r]),({pos:n,time:a}=t[l])):(e>=t[r].time&&e<=t[l].time&&({lo:r,hi:l}=it(t,\"time\",e)),({time:s,pos:o}=t[r]),({time:n,pos:a}=t[l]));const h=n-s;return h?o+(a-o)*(e-s)/h:o}var Ho=Object.freeze({__proto__:null,CategoryScale:class extends Js{static id=\"category\";static defaults={ticks:{callback:go}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:i,label:s}of e)t[i]===s&&t.splice(i,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(s(t))return null;const i=this.getLabels();return((t,e)=>null===t?null:J(Math.round(t),0,e))(e=isFinite(e)&&i[e]===t?e:fo(i,t,l(e,t),this._addedLabels),i.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:i,max:s}=this.getMinMax(!0);\"ticks\"===this.options.bounds&&(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}buildTicks(){const t=this.min,e=this.max,i=this.options.offset,s=[];let n=this.getLabels();n=0===t&&e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);for(let i=t;i<=e;i++)s.push({value:i});return s}getLabelForValue(t){return go.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return\"number\"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}},LinearScale:bo,LogarithmicScale:wo,RadialLinearScale:Lo,TimeScale:Wo,TimeSeriesScale:class extends Wo{static id=\"timeseries\";static defaults=Wo.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=No(e,this.min),this._tableRange=No(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:i}=this,s=[],n=[];let o,a,r,l,h;for(o=0,a=t.length;o<a;++o)l=t[o],l>=e&&l<=i&&s.push(l);if(s.length<2)return[{time:e,pos:0},{time:i,pos:1}];for(o=0,a=s.length;o<a;++o)h=s[o+1],r=s[o-1],l=s[o],Math.round((h+r)/2)!==l&&n.push({time:l,pos:o/(a-1)});return n}_generate(){const t=this.min,e=this.max;let i=super.getDataTimestamps();return i.includes(t)&&i.length||i.splice(0,0,t),i.includes(e)&&1!==i.length||i.push(e),i.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),i=this.getLabelTimestamps();return t=e.length&&i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}getDecimalForValue(t){return(No(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return No(this._table,i*this._tableRange+this._minPos,!0)}}});const jo=[\"rgb(54, 162, 235)\",\"rgb(255, 99, 132)\",\"rgb(255, 159, 64)\",\"rgb(255, 205, 86)\",\"rgb(75, 192, 192)\",\"rgb(153, 102, 255)\",\"rgb(201, 203, 207)\"],$o=jo.map((t=>t.replace(\"rgb(\",\"rgba(\").replace(\")\",\", 0.5)\")));function Yo(t){return jo[t%jo.length]}function Uo(t){return $o[t%$o.length]}function Xo(t){let e=0;return(i,s)=>{const n=t.getDatasetMeta(s).controller;n instanceof Hn?e=function(t,e){return t.backgroundColor=t.data.map((()=>Yo(e++))),e}(i,e):n instanceof jn?e=function(t,e){return t.backgroundColor=t.data.map((()=>Uo(e++))),e}(i,e):n&&(e=function(t,e){return t.borderColor=Yo(e),t.backgroundColor=Uo(e),++e}(i,e))}}function qo(t){let e;for(e in t)if(t[e].borderColor||t[e].backgroundColor)return!0;return!1}var Ko={id:\"colors\",defaults:{enabled:!0,forceOverride:!1},beforeLayout(t,e,i){if(!i.enabled)return;const{data:{datasets:s},options:n}=t.config,{elements:o}=n;if(!i.forceOverride&&(qo(s)||(a=n)&&(a.borderColor||a.backgroundColor)||o&&qo(o)))return;var a;const r=Xo(t);s.forEach(r)}};function Go(t){if(t._decimated){const e=t._data;delete t._decimated,delete t._data,Object.defineProperty(t,\"data\",{configurable:!0,enumerable:!0,writable:!0,value:e})}}function Zo(t){t.data.datasets.forEach((t=>{Go(t)}))}var Jo={id:\"decimation\",defaults:{algorithm:\"min-max\",enabled:!1},beforeElementsUpdate:(t,e,i)=>{if(!i.enabled)return void Zo(t);const n=t.width;t.data.datasets.forEach(((e,o)=>{const{_data:a,indexAxis:r}=e,l=t.getDatasetMeta(o),h=a||e.data;if(\"y\"===Pi([r,t.options.indexAxis]))return;if(!l.controller.supportsDecimation)return;const c=t.scales[l.xAxisID];if(\"linear\"!==c.type&&\"time\"!==c.type)return;if(t.options.parsing)return;let{start:d,count:u}=function(t,e){const i=e.length;let s,n=0;const{iScale:o}=t,{min:a,max:r,minDefined:l,maxDefined:h}=o.getUserBounds();return l&&(n=J(it(e,o.axis,a).lo,0,i-1)),s=h?J(it(e,o.axis,r).hi+1,n,i)-n:i-n,{start:n,count:s}}(l,h);if(u<=(i.threshold||4*n))return void Go(e);let f;switch(s(a)&&(e._data=h,delete e.data,Object.defineProperty(e,\"data\",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(t){this._data=t}})),i.algorithm){case\"lttb\":f=function(t,e,i,s,n){const o=n.samples||s;if(o>=i)return t.slice(e,e+i);const a=[],r=(i-2)/(o-2);let l=0;const h=e+i-1;let c,d,u,f,g,p=e;for(a[l++]=t[p],c=0;c<o-2;c++){let s,n=0,o=0;const h=Math.floor((c+1)*r)+1+e,m=Math.min(Math.floor((c+2)*r)+1,i)+e,b=m-h;for(s=h;s<m;s++)n+=t[s].x,o+=t[s].y;n/=b,o/=b;const x=Math.floor(c*r)+1+e,_=Math.min(Math.floor((c+1)*r)+1,i)+e,{x:y,y:v}=t[p];for(u=f=-1,s=x;s<_;s++)f=.5*Math.abs((y-n)*(t[s].y-v)-(y-t[s].x)*(o-v)),f>u&&(u=f,d=t[s],g=s);a[l++]=d,p=g}return a[l++]=t[h],a}(h,d,u,n,i);break;case\"min-max\":f=function(t,e,i,n){let o,a,r,l,h,c,d,u,f,g,p=0,m=0;const b=[],x=e+i-1,_=t[e].x,y=t[x].x-_;for(o=e;o<e+i;++o){a=t[o],r=(a.x-_)/y*n,l=a.y;const e=0|r;if(e===h)l<f?(f=l,c=o):l>g&&(g=l,d=o),p=(m*p+a.x)/++m;else{const i=o-1;if(!s(c)&&!s(d)){const e=Math.min(c,d),s=Math.max(c,d);e!==u&&e!==i&&b.push({...t[e],x:p}),s!==u&&s!==i&&b.push({...t[s],x:p})}o>0&&i!==u&&b.push(t[i]),b.push(a),h=e,m=0,f=g=l,c=d=u=o}}return b}(h,d,u,n);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}e._decimated=f}))},destroy(t){Zo(t)}};function Qo(t,e,i,s){if(s)return;let n=e[t],o=i[t];return\"angle\"===t&&(n=G(n),o=G(o)),{property:t,start:n,end:o}}function ta(t,e,i){for(;e>t;e--){const t=i[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function ea(t,e,i,s){return t&&e?s(t[i],e[i]):t?t[i]:e?e[i]:0}function ia(t,e){let i=[],s=!1;return n(t)?(s=!0,i=t):i=function(t,e){const{x:i=null,y:s=null}=t||{},n=e.points,o=[];return e.segments.forEach((({start:t,end:e})=>{e=ta(t,e,n);const a=n[t],r=n[e];null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&&(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))})),o}(t,e),i.length?new so({points:i,options:{tension:0},_loop:s,_fullLoop:s}):null}function sa(t){return t&&!1!==t.fill}function na(t,e,i){let s=t[e].fill;const n=[e];let o;if(!i)return s;for(;!1!==s&&-1===n.indexOf(s);){if(!a(s))return s;if(o=t[s],!o)return!1;if(o.visible)return s;n.push(s),s=o.fill}return!1}function oa(t,e,i){const s=function(t){const e=t.options,i=e.fill;let s=l(i&&i.target,i);void 0===s&&(s=!!e.backgroundColor);if(!1===s||null===s)return!1;if(!0===s)return\"origin\";return s}(t);if(o(s))return!isNaN(s.value)&&s;let n=parseFloat(s);return a(n)&&Math.floor(n)===n?function(t,e,i,s){\"-\"!==t&&\"+\"!==t||(i=e+i);if(i===e||i<0||i>=s)return!1;return i}(s[0],e,n,i):[\"origin\",\"start\",\"end\",\"stack\",\"shape\"].indexOf(s)>=0&&s}function aa(t,e,i){const s=[];for(let n=0;n<i.length;n++){const o=i[n],{first:a,last:r,point:l}=ra(o,e,\"x\");if(!(!l||a&&r))if(a)s.unshift(l);else if(t.push(l),!r)break}t.push(...s)}function ra(t,e,i){const s=t.interpolate(e,i);if(!s)return{};const n=s[i],o=t.segments,a=t.points;let r=!1,l=!1;for(let t=0;t<o.length;t++){const e=o[t],s=a[e.start][i],h=a[e.end][i];if(tt(n,s,h)){r=n===s,l=n===h;break}}return{first:r,last:l,point:s}}class la{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,i){const{x:s,y:n,radius:o}=this;return e=e||{start:0,end:O},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}interpolate(t){const{x:e,y:i,radius:s}=this,n=t.angle;return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}}function ha(t){const{chart:e,fill:i,line:s}=t;if(a(i))return function(t,e){const i=t.getDatasetMeta(e),s=i&&t.isDatasetVisible(e);return s?i.dataset:null}(e,i);if(\"stack\"===i)return function(t){const{scale:e,index:i,line:s}=t,n=[],o=s.segments,a=s.points,r=function(t,e){const i=[],s=t.getMatchingVisibleMetas(\"line\");for(let t=0;t<s.length;t++){const n=s[t];if(n.index===e)break;n.hidden||i.unshift(n.dataset)}return i}(e,i);r.push(ia({x:null,y:e.bottom},s));for(let t=0;t<o.length;t++){const e=o[t];for(let t=e.start;t<=e.end;t++)aa(n,a[t],r)}return new so({points:n,options:{}})}(t);if(\"shape\"===i)return!0;const n=function(t){const e=t.scale||{};if(e.getPointPositionForValue)return function(t){const{scale:e,fill:i}=t,s=e.options,n=e.getLabels().length,a=s.reverse?e.max:e.min,r=function(t,e,i){let s;return s=\"start\"===t?i:\"end\"===t?e.options.reverse?e.min:e.max:o(t)?t.value:e.getBaseValue(),s}(i,e,a),l=[];if(s.grid.circular){const t=e.getPointPositionForValue(0,a);return new la({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}for(let t=0;t<n;++t)l.push(e.getPointPositionForValue(t,r));return l}(t);return function(t){const{scale:e={},fill:i}=t,s=function(t,e){let i=null;return\"start\"===t?i=e.bottom:\"end\"===t?i=e.top:o(t)?i=e.getPixelForValue(t.value):e.getBasePixel&&(i=e.getBasePixel()),i}(i,e);if(a(s)){const t=e.isHorizontal();return{x:t?s:null,y:t?null:s}}return null}(t)}(t);return n instanceof la?n:ia(n,s)}function ca(t,e,i){const s=ha(e),{line:n,scale:o,axis:a}=e,r=n.options,l=r.fill,h=r.backgroundColor,{above:c=h,below:d=h}=l||{};s&&n.points.length&&(Ie(t,i),function(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r}=e,l=i._loop?\"angle\":e.axis;t.save(),\"x\"===l&&o!==n&&(da(t,s,a.top),ua(t,{line:i,target:s,color:n,scale:r,property:l}),t.restore(),t.save(),da(t,s,a.bottom));ua(t,{line:i,target:s,color:o,scale:r,property:l}),t.restore()}(t,{line:n,target:s,above:c,below:d,area:i,scale:o,axis:a}),ze(t))}function da(t,e,i){const{segments:s,points:n}=e;let o=!0,a=!1;t.beginPath();for(const r of s){const{start:s,end:l}=r,h=n[s],c=n[ta(s,l,n)];o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(h.x,i),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}t.lineTo(e.first().x,i),t.closePath(),t.clip()}function ua(t,e){const{line:i,target:s,property:n,color:o,scale:a}=e,r=function(t,e,i){const s=t.segments,n=t.points,o=e.points,a=[];for(const t of s){let{start:s,end:r}=t;r=ta(s,r,n);const l=Qo(i,n[s],n[r],t.loop);if(!e.segments){a.push({source:t,target:l,start:n[s],end:n[r]});continue}const h=Ii(e,l);for(const e of h){const s=Qo(i,o[e.start],o[e.end],e.loop),r=Ri(t,n,s);for(const t of r)a.push({source:t,target:e,start:{[i]:ea(l,s,\"start\",Math.max)},end:{[i]:ea(l,s,\"end\",Math.min)}})}}return a}(i,s,n);for(const{source:e,target:l,start:h,end:c}of r){const{style:{backgroundColor:r=o}={}}=e,d=!0!==s;t.save(),t.fillStyle=r,fa(t,a,d&&Qo(n,h,c)),t.beginPath();const u=!!i.pathSegment(t,e);let f;if(d){u?t.closePath():ga(t,s,c,n);const e=!!s.pathSegment(t,l,{move:u,reverse:!0});f=u&&e,f||ga(t,s,h,n)}t.closePath(),t.fill(f?\"evenodd\":\"nonzero\"),t.restore()}}function fa(t,e,i){const{top:s,bottom:n}=e.chart.chartArea,{property:o,start:a,end:r}=i||{};\"x\"===o&&(t.beginPath(),t.rect(a,s,r-a,n-s),t.clip())}function ga(t,e,i,s){const n=e.interpolate(i,s);n&&t.lineTo(n.x,n.y)}var pa={id:\"filler\",afterDatasetsUpdate(t,e,i){const s=(t.data.datasets||[]).length,n=[];let o,a,r,l;for(a=0;a<s;++a)o=t.getDatasetMeta(a),r=o.dataset,l=null,r&&r.options&&r instanceof so&&(l={visible:t.isDatasetVisible(a),index:a,fill:oa(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=l,n.push(l);for(a=0;a<s;++a)l=n[a],l&&!1!==l.fill&&(l.fill=na(n,a,i.propagate))},beforeDraw(t,e,i){const s=\"beforeDraw\"===i.drawTime,n=t.getSortedVisibleDatasetMetas(),o=t.chartArea;for(let e=n.length-1;e>=0;--e){const i=n[e].$filler;i&&(i.line.updateControlPoints(o,i.axis),s&&i.fill&&ca(t.ctx,i,o))}},beforeDatasetsDraw(t,e,i){if(\"beforeDatasetsDraw\"!==i.drawTime)return;const s=t.getSortedVisibleDatasetMetas();for(let e=s.length-1;e>=0;--e){const i=s[e].$filler;sa(i)&&ca(t.ctx,i,t.chartArea)}},beforeDatasetDraw(t,e,i){const s=e.meta.$filler;sa(s)&&\"beforeDatasetDraw\"===i.drawTime&&ca(t.ctx,s,t.chartArea)},defaults:{propagate:!0,drawTime:\"beforeDatasetDraw\"}};const ma=(t,e)=>{let{boxHeight:i=e,boxWidth:s=e}=t;return t.usePointStyle&&(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}};class ba extends Hs{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,i){this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=d(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data)))),t.sort&&(e=e.sort(((e,i)=>t.sort(e,i,this.chart.data)))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const i=t.labels,s=Si(i.font),n=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:r}=ma(i,n);let l,h;e.font=s.string,this.isHorizontal()?(l=this.maxWidth,h=this._fitRows(o,n,a,r)+10):(h=this.maxHeight,l=this._fitCols(o,s,a,r)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.lineWidths=[0],h=s+a;let c=t;n.textAlign=\"left\",n.textBaseline=\"middle\";let d=-1,u=-h;return this.legendItems.forEach(((t,f)=>{const g=i+e/2+n.measureText(t.text).width;(0===f||l[l.length-1]+g+2*a>o)&&(c+=h,l[l.length-(f>0?0:1)]=0,u+=h,d++),r[f]={left:0,top:u,row:d,width:g,height:s},l[l.length-1]+=g+a})),c}_fitCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.columnSizes=[],h=o-t;let c=a,d=0,u=0,f=0,g=0;return this.legendItems.forEach(((t,o)=>{const{itemWidth:p,itemHeight:m}=function(t,e,i,s,n){const o=function(t,e,i,s){let n=t.text;n&&\"string\"!=typeof n&&(n=n.reduce(((t,e)=>t.length>e.length?t:e)));return e+i.size/2+s.measureText(n).width}(s,t,e,i),a=function(t,e,i){let s=t;\"string\"!=typeof e.text&&(s=xa(e,i));return s}(n,s,e.lineHeight);return{itemWidth:o,itemHeight:a}}(i,e,n,t,s);o>0&&u+m+2*a>h&&(c+=d+a,l.push({width:d,height:u}),f+=d+a,g++,d=u=0),r[o]={left:f,top:u,col:g,width:p,height:m},d=Math.max(d,p),u+=m+a})),c+=d,l.push({width:d,height:u}),c}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=this,o=Oi(n,this.left,this.width);if(this.isHorizontal()){let n=0,a=ft(i,this.left+s,this.right-this.lineWidths[n]);for(const r of e)n!==r.row&&(n=r.row,a=ft(i,this.left+s,this.right-this.lineWidths[n])),r.top+=this.top+t+s,r.left=o.leftForLtr(o.x(a),r.width),a+=r.width+s}else{let n=0,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height);for(const r of e)r.col!==n&&(n=r.col,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),r.top=a,r.left+=this.left+s,r.left=o.leftForLtr(o.x(r.left),r.width),a+=r.height+s}}isHorizontal(){return\"top\"===this.options.position||\"bottom\"===this.options.position}draw(){if(this.options.display){const t=this.ctx;Ie(t,this),this._draw(),ze(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=this,{align:n,labels:o}=t,a=ue.color,r=Oi(t.rtl,this.left,this.width),h=Si(o.font),{padding:c}=o,d=h.size,u=d/2;let f;this.drawTitle(),s.textAlign=r.textAlign(\"left\"),s.textBaseline=\"middle\",s.lineWidth=.5,s.font=h.string;const{boxWidth:g,boxHeight:p,itemHeight:m}=ma(o,d),b=this.isHorizontal(),x=this._computeTitleHeight();f=b?{x:ft(n,this.left+c,this.right-i[0]),y:this.top+c+x,line:0}:{x:this.left+c,y:ft(n,this.top+x+c,this.bottom-e[0].height),line:0},Ai(this.ctx,t.textDirection);const _=m+c;this.legendItems.forEach(((y,v)=>{s.strokeStyle=y.fontColor,s.fillStyle=y.fontColor;const M=s.measureText(y.text).width,w=r.textAlign(y.textAlign||(y.textAlign=o.textAlign)),k=g+u+M;let S=f.x,P=f.y;r.setWidth(this.width),b?v>0&&S+k+c>this.right&&(P=f.y+=_,f.line++,S=f.x=ft(n,this.left+c,this.right-i[f.line])):v>0&&P+_>this.bottom&&(S=f.x=S+e[f.line].width+c,f.line++,P=f.y=ft(n,this.top+x+c,this.bottom-e[f.line].height));if(function(t,e,i){if(isNaN(g)||g<=0||isNaN(p)||p<0)return;s.save();const n=l(i.lineWidth,1);if(s.fillStyle=l(i.fillStyle,a),s.lineCap=l(i.lineCap,\"butt\"),s.lineDashOffset=l(i.lineDashOffset,0),s.lineJoin=l(i.lineJoin,\"miter\"),s.lineWidth=n,s.strokeStyle=l(i.strokeStyle,a),s.setLineDash(l(i.lineDash,[])),o.usePointStyle){const a={radius:p*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},l=r.xPlus(t,g/2);Ee(s,a,l,e+u,o.pointStyleWidth&&g)}else{const o=e+Math.max((d-p)/2,0),a=r.leftForLtr(t,g),l=wi(i.borderRadius);s.beginPath(),Object.values(l).some((t=>0!==t))?He(s,{x:a,y:o,w:g,h:p,radius:l}):s.rect(a,o,g,p),s.fill(),0!==n&&s.stroke()}s.restore()}(r.x(S),P,y),S=gt(w,S+g+u,b?S+k:this.right,t.rtl),function(t,e,i){Ne(s,i.text,t,e+m/2,h,{strikethrough:i.hidden,textAlign:r.textAlign(i.textAlign)})}(r.x(S),P,y),b)f.x+=k+c;else if(\"string\"!=typeof y.text){const t=h.lineHeight;f.y+=xa(y,t)+c}else f.y+=_})),Ti(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,i=Si(e.font),s=ki(e.padding);if(!e.display)return;const n=Oi(t.rtl,this.left,this.width),o=this.ctx,a=e.position,r=i.size/2,l=s.top+r;let h,c=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),h=this.top+l,c=ft(t.align,c,this.right-d);else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);h=l+ft(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const u=ft(a,c,c+d);o.textAlign=n.textAlign(ut(a)),o.textBaseline=\"middle\",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ne(o,e.text,u,h,i)}_computeTitleHeight(){const t=this.options.title,e=Si(t.font),i=ki(t.padding);return t.display?e.lineHeight+i.height:0}_getLegendItemAt(t,e){let i,s,n;if(tt(t,this.left,this.right)&&tt(e,this.top,this.bottom))for(n=this.legendHitBoxes,i=0;i<n.length;++i)if(s=n[i],tt(t,s.left,s.left+s.width)&&tt(e,s.top,s.top+s.height))return this.legendItems[i];return null}handleEvent(t){const e=this.options;if(!function(t,e){if((\"mousemove\"===t||\"mouseout\"===t)&&(e.onHover||e.onLeave))return!0;if(e.onClick&&(\"click\"===t||\"mouseup\"===t))return!0;return!1}(t.type,e))return;const i=this._getLegendItemAt(t.x,t.y);if(\"mousemove\"===t.type||\"mouseout\"===t.type){const o=this._hoveredItem,a=(n=i,null!==(s=o)&&null!==n&&s.datasetIndex===n.datasetIndex&&s.index===n.index);o&&!a&&d(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&&!a&&d(e.onHover,[t,i,this],this)}else i&&d(e.onClick,[t,i,this],this);var s,n}}function xa(t,e){return e*(t.text?t.text.length:0)}var _a={id:\"legend\",_element:ba,start(t,e,i){const s=t.legend=new ba({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s)},stop(t){as.removeBox(t,t.legend),delete t.legend},beforeUpdate(t,e,i){const s=t.legend;as.configure(t,s,i),s.options=i},afterUpdate(t){const e=t.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:!0,position:\"top\",align:\"center\",fullSize:!0,reverse:!1,weight:1e3,onClick(t,e,i){const s=e.datasetIndex,n=i.chart;n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets,{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o,useBorderRadius:a,borderRadius:r}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(i?0:void 0),h=ki(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(h.width+h.height)/4,strokeStyle:l.borderColor,pointStyle:s||l.pointStyle,rotation:l.rotation,textAlign:n||l.textAlign,borderRadius:a&&(r||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:!1,position:\"center\",text:\"\"}},descriptors:{_scriptable:t=>!t.startsWith(\"on\"),labels:{_scriptable:t=>![\"generateLabels\",\"filter\",\"sort\"].includes(t)}}};class ya extends Hs{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const i=this.options;if(this.left=0,this.top=0,!i.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const s=n(i.text)?i.text.length:1;this._padding=ki(i.padding);const o=s*Si(i.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=o:this.width=o}isHorizontal(){const t=this.options.position;return\"top\"===t||\"bottom\"===t}_drawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=this,a=o.align;let r,l,h,c=0;return this.isHorizontal()?(l=ft(a,i,n),h=e+t,r=n-i):(\"left\"===o.position?(l=i+t,h=ft(a,s,e),c=-.5*C):(l=n-t,h=ft(a,e,s),c=.5*C),r=s-e),{titleX:l,titleY:h,maxWidth:r,rotation:c}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const i=Si(e.font),s=i.lineHeight/2+this._padding.top,{titleX:n,titleY:o,maxWidth:a,rotation:r}=this._drawArgs(s);Ne(t,e.text,0,0,i,{color:e.color,maxWidth:a,rotation:r,textAlign:ut(e.align),textBaseline:\"middle\",translation:[n,o]})}}var va={id:\"title\",_element:ya,start(t,e,i){!function(t,e){const i=new ya({ctx:t.ctx,options:e,chart:t});as.configure(t,i,e),as.addBox(t,i),t.titleBlock=i}(t,i)},stop(t){const e=t.titleBlock;as.removeBox(t,e),delete t.titleBlock},beforeUpdate(t,e,i){const s=t.titleBlock;as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"bold\"},fullSize:!0,padding:10,position:\"top\",text:\"\",weight:2e3},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const Ma=new WeakMap;var wa={id:\"subtitle\",start(t,e,i){const s=new ya({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s),Ma.set(t,s)},stop(t){as.removeBox(t,Ma.get(t)),Ma.delete(t)},beforeUpdate(t,e,i){const s=Ma.get(t);as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"normal\"},fullSize:!0,padding:0,position:\"top\",text:\"\",weight:1500},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const ka={average(t){if(!t.length)return!1;let e,i,s=0,n=0,o=0;for(e=0,i=t.length;e<i;++e){const i=t[e].element;if(i&&i.hasValue()){const t=i.tooltipPosition();s+=t.x,n+=t.y,++o}}return{x:s/o,y:n/o}},nearest(t,e){if(!t.length)return!1;let i,s,n,o=e.x,a=e.y,r=Number.POSITIVE_INFINITY;for(i=0,s=t.length;i<s;++i){const s=t[i].element;if(s&&s.hasValue()){const t=q(e,s.getCenterPoint());t<r&&(r=t,n=s)}}if(n){const t=n.tooltipPosition();o=t.x,a=t.y}return{x:o,y:a}}};function Sa(t,e){return e&&(n(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Pa(t){return(\"string\"==typeof t||t instanceof String)&&t.indexOf(\"\\n\")>-1?t.split(\"\\n\"):t}function Da(t,e){const{element:i,datasetIndex:s,index:n}=e,o=t.getDatasetMeta(s).controller,{label:a,value:r}=o.getLabelAndValue(n);return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}function Ca(t,e){const i=t.chart.ctx,{body:s,footer:n,title:o}=t,{boxWidth:a,boxHeight:r}=e,l=Si(e.bodyFont),h=Si(e.titleFont),c=Si(e.footerFont),d=o.length,f=n.length,g=s.length,p=ki(e.padding);let m=p.height,b=0,x=s.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);if(x+=t.beforeBody.length+t.afterBody.length,d&&(m+=d*h.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),x){m+=g*(e.displayColors?Math.max(r,l.lineHeight):l.lineHeight)+(x-g)*l.lineHeight+(x-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*c.lineHeight+(f-1)*e.footerSpacing);let _=0;const y=function(t){b=Math.max(b,i.measureText(t).width+_)};return i.save(),i.font=h.string,u(t.title,y),i.font=l.string,u(t.beforeBody.concat(t.afterBody),y),_=e.displayColors?a+2+e.boxPadding:0,u(s,(t=>{u(t.before,y),u(t.lines,y),u(t.after,y)})),_=0,i.font=c.string,u(t.footer,y),i.restore(),b+=p.width,{width:b,height:m}}function Oa(t,e,i,s){const{x:n,width:o}=i,{width:a,chartArea:{left:r,right:l}}=t;let h=\"center\";return\"center\"===s?h=n<=(r+l)/2?\"left\":\"right\":n<=o/2?h=\"left\":n>=a-o/2&&(h=\"right\"),function(t,e,i,s){const{x:n,width:o}=s,a=i.caretSize+i.caretPadding;return\"left\"===t&&n+o+a>e.width||\"right\"===t&&n-o-a<0||void 0}(h,t,e,i)&&(h=\"center\"),h}function Aa(t,e,i){const s=i.yAlign||e.yAlign||function(t,e){const{y:i,height:s}=e;return i<s/2?\"top\":i>t.height-s/2?\"bottom\":\"center\"}(t,i);return{xAlign:i.xAlign||e.xAlign||Oa(t,e,i,s),yAlign:s}}function Ta(t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:a}=t,{xAlign:r,yAlign:l}=i,h=n+o,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(a);let g=function(t,e){let{x:i,width:s}=t;return\"right\"===e?i-=s:\"center\"===e&&(i-=s/2),i}(e,r);const p=function(t,e,i){let{y:s,height:n}=t;return\"top\"===e?s+=i:s-=\"bottom\"===e?n+i:n/2,s}(e,l,h);return\"center\"===l?\"left\"===r?g+=h:\"right\"===r&&(g-=h):\"left\"===r?g-=Math.max(c,u)+n:\"right\"===r&&(g+=Math.max(d,f)+n),{x:J(g,0,s.width-e.width),y:J(p,0,s.height-e.height)}}function La(t,e,i){const s=ki(i.padding);return\"center\"===e?t.x+t.width/2:\"right\"===e?t.x+t.width-s.right:t.x+s.left}function Ea(t){return Sa([],Pa(t))}function Ra(t,e){const i=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return i?t.override(i):t}const Ia={beforeTitle:e,title(t){if(t.length>0){const e=t[0],i=e.chart.data.labels,s=i?i.length:0;if(this&&this.options&&\"dataset\"===this.options.mode)return e.dataset.label||\"\";if(e.label)return e.label;if(s>0&&e.dataIndex<s)return i[e.dataIndex]}return\"\"},afterTitle:e,beforeBody:e,beforeLabel:e,label(t){if(this&&this.options&&\"dataset\"===this.options.mode)return t.label+\": \"+t.formattedValue||t.formattedValue;let e=t.dataset.label||\"\";e&&(e+=\": \");const i=t.formattedValue;return s(i)||(e+=i),e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:e,afterBody:e,beforeFooter:e,footer:e,afterFooter:e};function za(t,e,i,s){const n=t[e].call(i,s);return void 0===n?Ia[e].call(i,s):n}class Fa extends Hs{static positioners=ka;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,i=this.options.setContext(this.getContext()),s=i.enabled&&e.options.animation&&i.animations,n=new Os(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(n)),n}getContext(){return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,Ci(t,{tooltip:e,tooltipItems:i,type:\"tooltip\"})));var t,e,i}getTitle(t,e){const{callbacks:i}=e,s=za(i,\"beforeTitle\",this,t),n=za(i,\"title\",this,t),o=za(i,\"afterTitle\",this,t);let a=[];return a=Sa(a,Pa(s)),a=Sa(a,Pa(n)),a=Sa(a,Pa(o)),a}getBeforeBody(t,e){return Ea(za(e.callbacks,\"beforeBody\",this,t))}getBody(t,e){const{callbacks:i}=e,s=[];return u(t,(t=>{const e={before:[],lines:[],after:[]},n=Ra(i,t);Sa(e.before,Pa(za(n,\"beforeLabel\",this,t))),Sa(e.lines,za(n,\"label\",this,t)),Sa(e.after,Pa(za(n,\"afterLabel\",this,t))),s.push(e)})),s}getAfterBody(t,e){return Ea(za(e.callbacks,\"afterBody\",this,t))}getFooter(t,e){const{callbacks:i}=e,s=za(i,\"beforeFooter\",this,t),n=za(i,\"footer\",this,t),o=za(i,\"afterFooter\",this,t);let a=[];return a=Sa(a,Pa(s)),a=Sa(a,Pa(n)),a=Sa(a,Pa(o)),a}_createItems(t){const e=this._active,i=this.chart.data,s=[],n=[],o=[];let a,r,l=[];for(a=0,r=e.length;a<r;++a)l.push(Da(this.chart,e[a]));return t.filter&&(l=l.filter(((e,s,n)=>t.filter(e,s,n,i)))),t.itemSort&&(l=l.sort(((e,s)=>t.itemSort(e,s,i)))),u(l,(e=>{const i=Ra(t.callbacks,e);s.push(za(i,\"labelColor\",this,e)),n.push(za(i,\"labelPointStyle\",this,e)),o.push(za(i,\"labelTextColor\",this,e))})),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=l,l}update(t,e){const i=this.options.setContext(this.getContext()),s=this._active;let n,o=[];if(s.length){const t=ka[i.position].call(this,s,this._eventPosition);o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);const e=this._size=Ca(this,i),a=Object.assign({},t,e),r=Aa(this.chart,i,a),l=Ta(i,a,r,this.chart);this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(n={opacity:0});this._tooltipItems=o,this.$context=void 0,n&&this._resolveAnimations().update(this,n),t&&i.external&&i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,i,s){const n=this.getCaretPosition(t,i,s);e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}getCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=this,{caretSize:o,cornerRadius:a}=i,{topLeft:r,topRight:l,bottomLeft:h,bottomRight:c}=wi(a),{x:d,y:u}=t,{width:f,height:g}=e;let p,m,b,x,_,y;return\"center\"===n?(_=u+g/2,\"left\"===s?(p=d,m=p-o,x=_+o,y=_-o):(p=d+f,m=p+o,x=_-o,y=_+o),b=p):(m=\"left\"===s?d+Math.max(r,h)+o:\"right\"===s?d+f-Math.max(l,c)-o:this.caretX,\"top\"===n?(x=u,_=x-o,p=m-o,b=m+o):(x=u+g,_=x+o,p=m+o,b=m-o),y=x),{x1:p,x2:m,x3:b,y1:x,y2:_,y3:y}}drawTitle(t,e,i){const s=this.title,n=s.length;let o,a,r;if(n){const l=Oi(i.rtl,this.x,this.width);for(t.x=La(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline=\"middle\",o=Si(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,r=0;r<n;++r)e.fillText(s[r],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,r+1===n&&(t.y+=i.titleMarginBottom-a)}}_drawColorBox(t,e,i,s,n){const a=this.labelColors[i],r=this.labelPointStyles[i],{boxHeight:l,boxWidth:h}=n,c=Si(n.bodyFont),d=La(this,\"left\",n),u=s.x(d),f=l<c.lineHeight?(c.lineHeight-l)/2:0,g=e.y+f;if(n.usePointStyle){const e={radius:Math.min(h,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},i=s.leftForLtr(u,h)+h/2,o=g+l/2;t.strokeStyle=n.multiKeyBackground,t.fillStyle=n.multiKeyBackground,Le(t,e,i,o),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,Le(t,e,i,o)}else{t.lineWidth=o(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;const e=s.leftForLtr(u,h),i=s.leftForLtr(s.xPlus(u,1),h-2),r=wi(a.borderRadius);Object.values(r).some((t=>0!==t))?(t.beginPath(),t.fillStyle=n.multiKeyBackground,He(t,{x:e,y:g,w:h,h:l,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),He(t,{x:i,y:g+1,w:h-2,h:l-2,radius:r}),t.fill()):(t.fillStyle=n.multiKeyBackground,t.fillRect(e,g,h,l),t.strokeRect(e,g,h,l),t.fillStyle=a.backgroundColor,t.fillRect(i,g+1,h-2,l-2))}t.fillStyle=this.labelTextColors[i]}drawBody(t,e,i){const{body:s}=this,{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:h}=i,c=Si(i.bodyFont);let d=c.lineHeight,f=0;const g=Oi(i.rtl,this.x,this.width),p=function(i){e.fillText(i,g.x(t.x+f),t.y+d/2),t.y+=d+n},m=g.textAlign(o);let b,x,_,y,v,M,w;for(e.textAlign=o,e.textBaseline=\"middle\",e.font=c.string,t.x=La(this,m,i),e.fillStyle=i.bodyColor,u(this.beforeBody,p),f=a&&\"right\"!==m?\"center\"===o?l/2+h:l+2+h:0,y=0,M=s.length;y<M;++y){for(b=s[y],x=this.labelTextColors[y],e.fillStyle=x,u(b.before,p),_=b.lines,a&&_.length&&(this._drawColorBox(e,t,y,g,i),d=Math.max(c.lineHeight,r)),v=0,w=_.length;v<w;++v)p(_[v]),d=c.lineHeight;u(b.after,p)}f=0,d=c.lineHeight,u(this.afterBody,p),t.y-=n}drawFooter(t,e,i){const s=this.footer,n=s.length;let o,a;if(n){const r=Oi(i.rtl,this.x,this.width);for(t.x=La(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=r.textAlign(i.footerAlign),e.textBaseline=\"middle\",o=Si(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a<n;++a)e.fillText(s[a],r.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}}drawBackground(t,e,i,s){const{xAlign:n,yAlign:o}=this,{x:a,y:r}=t,{width:l,height:h}=i,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(s.cornerRadius);e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+c,r),\"top\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+l-d,r),e.quadraticCurveTo(a+l,r,a+l,r+d),\"center\"===o&&\"right\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a+l,r+h-f),e.quadraticCurveTo(a+l,r+h,a+l-f,r+h),\"bottom\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+u,r+h),e.quadraticCurveTo(a,r+h,a,r+h-u),\"center\"===o&&\"left\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a,r+c),e.quadraticCurveTo(a,r,a+c,r),e.closePath(),e.fill(),s.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,i=this.$animations,s=i&&i.x,n=i&&i.y;if(s||n){const i=ka[t.position].call(this,this._active,this._eventPosition);if(!i)return;const o=this._size=Ca(this,t),a=Object.assign({},i,this._size),r=Aa(e,t,a),l=Ta(t,a,r,e);s._to===l.x&&n._to===l.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let i=this.opacity;if(!i)return;this._updateAnimationTarget(e);const s={width:this.width,height:this.height},n={x:this.x,y:this.y};i=Math.abs(i)<.001?0:i;const o=ki(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),Ai(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),Ti(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const i=this._active,s=t.map((({datasetIndex:t,index:e})=>{const i=this.chart.getDatasetMeta(t);if(!i)throw new Error(\"Cannot find a dataset at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}})),n=!f(i,s),o=this._positionChanged(s,e);(n||o)&&(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,i=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,n=this._active||[],o=this._getActiveElements(t,n,e,i),a=this._positionChanged(o,t),r=e||!f(o,n)||a;return r&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),r}_getActiveElements(t,e,i,s){const n=this.options;if(\"mouseout\"===t.type)return[];if(!s)return e;const o=this.chart.getElementsAtEventForMode(t,n.mode,n,i);return n.reverse&&o.reverse(),o}_positionChanged(t,e){const{caretX:i,caretY:s,options:n}=this,o=ka[n.position].call(this,t,e);return!1!==o&&(i!==o.x||s!==o.y)}}var Va={id:\"tooltip\",_element:Fa,positioners:ka,afterInit(t,e,i){i&&(t.tooltip=new Fa({chart:t,options:i}))},beforeUpdate(t,e,i){t.tooltip&&t.tooltip.initialize(i)},reset(t,e,i){t.tooltip&&t.tooltip.initialize(i)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const i={tooltip:e};if(!1===t.notifyPlugins(\"beforeTooltipDraw\",{...i,cancelable:!0}))return;e.draw(t.ctx),t.notifyPlugins(\"afterTooltipDraw\",i)}},afterEvent(t,e){if(t.tooltip){const i=e.replay;t.tooltip.handleEvent(e.event,i,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:\"average\",backgroundColor:\"rgba(0,0,0,0.8)\",titleColor:\"#fff\",titleFont:{weight:\"bold\"},titleSpacing:2,titleMarginBottom:6,titleAlign:\"left\",bodyColor:\"#fff\",bodySpacing:2,bodyFont:{},bodyAlign:\"left\",footerColor:\"#fff\",footerSpacing:2,footerMarginTop:6,footerFont:{weight:\"bold\"},footerAlign:\"left\",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:\"#fff\",displayColors:!0,boxPadding:0,borderColor:\"rgba(0,0,0,0)\",borderWidth:0,animation:{duration:400,easing:\"easeOutQuart\"},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"width\",\"height\",\"caretX\",\"caretY\"]},opacity:{easing:\"linear\",duration:200}},callbacks:Ia},defaultRoutes:{bodyFont:\"font\",footerFont:\"font\",titleFont:\"font\"},descriptors:{_scriptable:t=>\"filter\"!==t&&\"itemSort\"!==t&&\"external\"!==t,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:\"animation\"}},additionalOptionScopes:[\"interaction\"]};return On.register($n,Ho,uo,t),On.helpers={...Wi},On._adapters=En,On.Animation=Cs,On.Animations=Os,On.animator=xt,On.controllers=en.controllers.items,On.DatasetController=Ns,On.Element=Hs,On.elements=uo,On.Interaction=Xi,On.layouts=as,On.platforms=Ss,On.Scale=Js,On.Ticks=ae,Object.assign(On,$n,Ho,uo,t,Ss),On.Chart=On,\"undefined\"!=typeof window&&(window.Chart=On),On}));\n//# sourceMappingURL=chart.umd.js.map\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type Chart from '../core/core.controller.js';\nimport type {ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\n\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nfunction getDatasetArea(meta) {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: xScale.left,\n      right: xScale.right,\n      top: yScale.top,\n      bottom: yScale.bottom\n    };\n  }\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta) || this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the envent inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<string, string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: TimeUnit): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: TimeUnit): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek'): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<string, string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase\n};\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, ) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, /** @type {Unit} */ (parser))\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n","import {DoughnutController, PolarAreaController} from '../index.js';\nimport type {Chart, ChartDataset} from '../types.js';\n\nexport interface ColorsPluginOptions {\n  enabled?: boolean;\n  forceOverride?: boolean;\n}\n\ninterface ColorsDescriptor {\n  backgroundColor?: unknown;\n  borderColor?: unknown;\n}\n\nconst BORDER_COLORS = [\n  'rgb(54, 162, 235)', // blue\n  'rgb(255, 99, 132)', // red\n  'rgb(255, 159, 64)', // orange\n  'rgb(255, 205, 86)', // yellow\n  'rgb(75, 192, 192)', // green\n  'rgb(153, 102, 255)', // purple\n  'rgb(201, 203, 207)' // grey\n];\n\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\n\nfunction getBorderColor(i: number) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\n\nfunction getBackgroundColor(i: number) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\n\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n\n  return ++i;\n}\n\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n\n  return i;\n}\n\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n\n  return i;\n}\n\nfunction getColorizer(chart: Chart) {\n  let i = 0;\n\n  return (dataset: ChartDataset, datasetIndex: number) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\n\nfunction containsColorsDefinitions(\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\n) {\n  let k: number | string;\n\n  for (k in descriptors) {\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction containsColorsDefinition(\n  descriptor: ColorsDescriptor\n) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\n\nexport default {\n  id: 'colors',\n\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  } as ColorsPluginOptions,\n\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\n    if (!options.enabled) {\n      return;\n    }\n\n    const {\n      data: {datasets},\n      options: chartOptions\n    } = chart.config;\n    const {elements} = chartOptions;\n\n    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || (elements && containsColorsDefinitions(elements)))) {\n      return;\n    }\n\n    const colorizer = getColorizer(chart);\n\n    datasets.forEach(colorizer);\n  }\n};\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  /**\n   * Implementation of the Largest Triangle Three Buckets algorithm.\n   *\n   * This implementation is based on the original implementation by Sveinn Steinarsson\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\n   *\n   * The original implementation is MIT licensed.\n   */\n  const samples = options.samples || availableWidth;\n  // There are less points than the threshold, returning the whole array\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  // Starting from offset\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n\n    // Adding offset\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n\n    // Adding offset\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n\n    // Note that this is changed from the original algorithm which initializes these\n    // values to 1. The reason for this change is that if the area is small, nextA\n    // would never be set and thus a crash would occur in the next loop as `a` would become\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\n    // initializing with a negative number is the correct solution.\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  // Include the last point\n  decimated[sampledIndex++] = data[endIndex];\n\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      // Use point.x here because we're computing the average data `x` value\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        // The interval is defined by 4 points: start, min, max, end.\n        // The starting point is already considered at this point, so we need to determine which\n        // of the other points to add. We need to sort these points to ensure the decimated data\n        // is still sorted and then ensure there are no duplicates.\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      // lastIndex === startIndex will occur when a range has only 1 point which could\n      // happen with very uneven data\n      if (i > 0 && lastIndex !== startIndex) {\n        // Last point in the previous interval\n        decimated.push(data[lastIndex]);\n      }\n\n      // Start of the new interval\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data,\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count;\n\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {start, count};\n}\n\nexport default {\n  id: 'decimation',\n\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    // Assume the entire chart is available to show a few more points than needed\n    const availableWidth = chart.width;\n\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        // Decimation is only supported for lines that have an X indexAxis\n        return;\n      }\n\n      if (!meta.controller.supportsDecimation) {\n        // Only line datasets are supported\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        // Only linear interpolation is supported\n        return;\n      }\n\n      if (chart.options.parsing) {\n        // Plugin only supports data that does not need parsing\n        return;\n      }\n\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        // No decimation is required until we are above this threshold\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        // First time we are seeing this dataset\n        // We override the 'data' property with a setter that stores the\n        // raw data in _data, but reads the decimated data from _decimated\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n\n      // Point the chart to the decimated data\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of an segment -> need to add another point before this,\n      // from next line below.\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of an segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n/**\n * @namespace Chart\n */\nimport Chart from './core/core.controller.js';\n\nimport * as helpers from './helpers/index.js';\nimport _adapters from './core/core.adapters.js';\nimport Animation from './core/core.animation.js';\nimport animator from './core/core.animator.js';\nimport Animations from './core/core.animations.js';\nimport * as controllers from './controllers/index.js';\nimport DatasetController from './core/core.datasetController.js';\nimport Element from './core/core.element.js';\nimport * as elements from './elements/index.js';\nimport Interaction from './core/core.interaction.js';\nimport layouts from './core/core.layouts.js';\nimport * as platforms from './platform/index.js';\nimport * as plugins from './plugins/index.js';\nimport registry from './core/core.registry.js';\nimport Scale from './core/core.scale.js';\nimport * as scales from './scales/index.js';\nimport Ticks from './core/core.ticks.js';\n\n// Register built-ins\nChart.register(controllers, scales, elements, plugins);\n\nChart.helpers = {...helpers};\nChart._adapters = _adapters;\nChart.Animation = Animation;\nChart.Animations = Animations;\nChart.animator = animator;\nChart.controllers = registry.controllers.items;\nChart.DatasetController = DatasetController;\nChart.Element = Element;\nChart.elements = elements;\nChart.Interaction = Interaction;\nChart.layouts = layouts;\nChart.platforms = platforms;\nChart.Scale = Scale;\nChart.Ticks = Ticks;\n\n// Compatibility with ESM extensions\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\nChart.Chart = Chart;\n\nif (typeof window !== 'undefined') {\n  window.Chart = Chart;\n}\n\nexport default Chart;\n\n"],"names":["t","e","Ht","Object","freeze","__proto__","Colors","Ko","Decimation","Jo","Filler","pa","Legend","_a","SubTitle","wa","Title","va","Tooltip","Va","i","s","n","Array","isArray","prototype","toString","call","slice","o","a","Number","isFinite","r","l","h","endsWith","parseFloat","c","d","apply","u","length","keys","f","datasetIndex","index","g","map","create","p","indexOf","m","b","merger","x","_","hasOwnProperty","y","v","split","push","M","w","charAt","toUpperCase","k","S","P","size","has","D","type","C","Math","PI","O","A","T","POSITIVE_INFINITY","L","E","R","I","z","log10","F","sign","V","abs","B","round","pow","floor","W","sqrt","sort","pop","N","isNaN","H","j","min","max","$","Y","U","X","atan2","angle","distance","q","K","G","Z","J","Q","tt","et","lo","hi","it","st","nt","ot","at","_chartjs","listeners","defineProperty","configurable","enumerable","value","forEach","rt","splice","lt","Set","from","ht","window","requestAnimationFrame","ct","dt","clearTimeout","setTimeout","ut","ft","gt","pt","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","start","count","mt","xScale","yScale","_scaleRanges","xmin","xmax","ymin","ymax","assign","xt","constructor","_request","_charts","Map","_running","_lastDate","_notify","duration","chart","initial","numSteps","currentStep","_refresh","_update","Date","now","running","items","_active","_total","tick","draw","_getAnims","get","complete","progress","set","listen","add","reduce","_duration","stop","cancel","remove","delete","_t","yt","vt","Mt","wt","kt","St","Pt","Dt","Ct","Ot","Tt","Lt","Et","Rt","It","zt","Vt","Wt","Nt","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","$t","Yt","Ut","Xt","qt","Kt","Zt","jt","replace","parseInt","transparent","toLowerCase","exec","Bt","_rgb","_valid","valid","rgb","rgbString","hexString","hslString","mix","interpolate","clone","alpha","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","rotate","Jt","Qt","te","ee","ie","se","ne","JSON","stringify","Intl","NumberFormat","format","oe","values","numeric","options","locale","notation","minimumFractionDigits","maximumFractionDigits","ticks","logarithmic","significand","includes","ae","formatters","re","le","he","ce","ue","animation","backgroundColor","borderColor","color","datasets","devicePixelRatio","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","defineProperties","writable","_scriptable","startsWith","_indexable","_fallback","delay","easing","fn","loop","to","colors","properties","numbers","active","resize","show","animations","visible","hide","autoPadding","padding","top","right","bottom","left","display","offset","reverse","beginAtZero","bounds","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","callback","minor","major","align","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","fe","document","ge","parentNode","host","pe","me","ownerDocument","defaultView","getComputedStyle","be","getPropertyValue","xe","_e","height","ye","shadowRoot","ve","canvas","currentDevicePixelRatio","boxSizing","box","touches","offsetX","offsetY","target","getBoundingClientRect","clientX","clientY","Me","we","maxWidth","maxHeight","clientWidth","clientHeight","ke","ctx","setTransform","Se","passive","addEventListener","removeEventListener","Pe","match","De","Ce","measureText","Oe","data","garbageCollect","save","restore","Ae","Te","getContext","resetTransform","clearRect","Le","Ee","pointStyle","rotation","radius","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","Re","Ie","clip","ze","Fe","Ve","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","Ne","strokeWidth","strokeColor","string","translation","fillStyle","textAlign","textBaseline","backdrop","We","fillRect","strokeStyle","strokeText","fillText","Be","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","decorationWidth","He","topLeft","bottomLeft","bottomRight","topRight","je","ti","Symbol","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","qe","Ue","Je","getOwnPropertyDescriptor","Reflect","getPrototypeOf","ei","ownKeys","_storage","$e","_proxy","_context","_subProxy","_stack","_descriptors","Ye","setContext","isScriptable","Error","join","filter","isIndexable","allKeys","scriptable","indexable","_allKeys","Ge","Ze","ii","key","_parsing","parse","si","EPSILON","ni","skip","oi","ai","previous","next","ri","li","spanGaps","cubicInterpolationMode","tension","capBezierPoints","ci","di","ui","fi","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","gi","pi","mi","bi","xi","_i","yi","vi","Mi","wi","ki","Si","console","warn","Pi","cacheable","Di","Ci","Oi","setWidth","xPlus","leftForLtr","Ai","getPropertyPriority","setProperty","prevTextDirection","Ti","Li","between","compare","normalize","Ei","end","Ri","property","Ii","segments","points","zi","_loop","Fi","_fullLoop","_chart","Vi","_datasetIndex","Bi","p0","p1","p0DataIndex","p1DataIndex","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","Wi","HALF_PI","INFINITY","PITAU","QUARTER_PI","RAD_PER_DEG","TAU","TWO_THIRDS_PI","_addGrace","_alignPixel","_alignStartEnd","_angleBetween","_angleDiff","_arrayUnique","_attachContext","_bezierCurveTo","_bezierInterpolation","_boundSegment","_boundSegments","_capitalize","_computeSegments","_createResolver","_decimalPlaces","_deprecated","_elementsEqual","_factorize","_filterBetween","_getParentNode","_getStartAndCountOfVisiblePoints","_int16Range","_isBetween","_isClickEvent","_isDomSupported","_isPointInArea","_limitValue","_longestText","_lookup","_lookupByKey","_measureText","_merger","_mergerIf","_normalizeAngle","_parseObjectDataRadialScale","_pointInLine","_readValueToProps","_rlookupByKey","_scaleRangesChanged","_setMinAndMaxByKey","_splitKey","_steppedInterpolation","_steppedLineTo","_textX","_toLeftRightCenter","_updateBezierControlPoints","addRoundedRectPath","almostEquals","almostWhole","clearCanvas","clipArea","createContext","debounce","defined","distanceBetweenPoints","drawPoint","drawPointLegend","each","easingEffects","finiteOrDefault","fontString","formatNumber","getAngleFromPoint","getHoverColor","getMaximumSize","getRelativePosition","getRtlAdapter","getStyle","isFunction","isNullOrUndef","isNumber","isObject","isPatternOrGradient","listenArrayEvents","merge","mergeIf","niceNum","noop","overrideTextDirection","readUsedSize","renderText","requestAnimFrame","resolve","resolveObjectKey","restoreTextDirection","retinaScale","setsEqual","splineCurve","splineCurveMonotone","supportsEventListenerOptions","throttled","toDegrees","toDimension","toFont","toFontString","toLineHeight","toPadding","toPercentage","toRadians","toTRBL","toTRBLCorners","uid","unclipArea","unlistenArrayEvents","valueOrDefault","Hi","getSortedVisibleDatasetMetas","Ni","controller","_cachedMeta","_reversePixels","_sharedOptions","getRange","ji","isPointInArea","chartArea","inRange","element","Yi","$i","getCenterPoint","startAngle","endAngle","getProps","Ui","Xi","evaluateInteractionItems","modes","dataset","getDatasetMeta","point","nearest","qi","Ki","pos","Gi","Zi","Qi","ts","ss","update","is","maxPadding","horizontal","same","other","es","stack","getPadding","outerWidth","outerHeight","fullSize","ns","os","placed","stackWeight","as","addBox","boxes","position","_layers","removeBox","configure","layout","isHorizontal","leftAndTop","concat","rightAndBottom","vertical","beforeLayout","availableWidth","availableHeight","vBoxMaxWidth","hBoxMaxHeight","Ji","rs","acquireContext","releaseContext","isAttached","updateConfig","ls","hs","cs","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","ds","us","gs","contains","ps","MutationObserver","addedNodes","removedNodes","observe","childList","subtree","ms","bs","xs","_s","ys","ResizeObserver","contentRect","vs","disconnect","Ms","native","ws","getAttribute","removeAttribute","setAttribute","$proxies","attach","detach","isConnected","ks","OffscreenCanvas","Ss","BasePlatform","BasicPlatform","DomPlatform","_detectPlatform","Ps","Ds","boolean","number","Cs","_fn","_easing","_start","_target","_prop","_from","_to","_promises","wait","Promise","res","rej","Os","_properties","getOwnPropertyNames","_animateOptions","$shared","$animations","_createAnimations","all","then","As","Ts","_getSortedDatasetMetas","Ls","Es","stacked","Is","getMatchingVisibleMetas","zs","_stacks","vScale","id","Rs","_top","_bottom","_visualValues","Fs","shift","Vs","Bs","Ws","Ns","defaults","datasetElementType","dataElementType","_ctx","_cachedDataOpts","getMeta","_type","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","xAxisID","yAxisID","rAxisID","iAxisID","vAxisID","getScaleForId","rScale","_getOtherScale","reset","_destroy","_dataCheck","isExtensible","buildOrUpdateElements","_resyncElements","config","datasetScopeKeys","getOptionScopes","createResolver","parseArrayData","parseObjectData","parsePrimitiveData","getLabels","xAxisKey","yAxisKey","getParsed","getDataElement","applyStack","updateRangeFromParsed","NaN","getMinMax","hidden","NEGATIVE_INFINITY","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","parsed","raw","_resolveElementOptions","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","_animationsDisabled","_getSharedOptions","updateSharedOptions","sharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","_insertElements","_removeElements","updateElements","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","_onDataUnshift","Hs","defaultRoutes","tooltipPosition","hasValue","$s","ceil","Ys","Us","Xs","Ks","Gs","Js","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_length","_maxLength","_longestTextCache","_startPixel","_endPixel","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","getTicks","labels","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","js","_tickSize","maxTicksLimit","enabled","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","_isVisible","_getLabelSizes","widest","highest","asin","first","last","_calculatePadding","_handleMargins","getPixelForTick","isFullSize","_computeLabelSizes","_resolveTickFontOptions","gc","widths","heights","getValueForPixel","getPixelForDecimal","getDecimalForPixel","getBasePixel","getBaseValue","_computeGridLineItems","tickBorderDash","tickBorderDashOffset","qs","tx1","ty1","tx2","ty2","x1","y1","x2","y2","_getXAxisLabelAlignment","_getYAxisLabelAlignment","textOffset","_computeLabelArea","drawBackground","getLineWidthForValue","findIndex","drawGrid","setLineDash","lineDashOffset","drawBorder","drawLabels","drawTitle","titleX","titleY","_maxDigits","Qs","scope","isForType","isPrototypeOf","register","descriptors","overrides","unregister","en","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","_getRegistryForType","_exec","sn","_init","notify","_createDescriptors","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","on","local","pluginScopeKeys","some","an","rn","ln","hn","dn","cn","error","un","gn","pn","mn","bn","_config","_scopeCache","_resolverCache","clearCache","clear","additionalOptionScopes","_cachedScopes","chartOptionScopes","resolver","subPrefixes","xn","_n","yn","vn","Mn","wn","onComplete","kn","onProgress","Sn","getElementById","Pn","Dn","On","instances","registry","version","getChart","An","aspectRatio","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","onResize","render","ensureScalesHaveIDs","buildOrUpdateScales","dposition","dtype","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","order","isDatasetVisible","_resetElements","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","unbindEvents","_getUniformDataChanges","method","Cn","_idx","_updateDataset","meta","_drawDatasets","_drawDataset","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","updateHoverStyle","getActiveElements","setActiveElements","event","replay","inChartArea","_handleEvent","changed","_getActiveElements","Tn","Ln","formats","diff","startOf","endOf","En","_date","In","_custom","barStart","barEnd","zn","Fn","Bn","Wn","Hn","animateRotate","animateScale","cutout","circumference","spacing","legend","generateLabels","fontColor","innerRadius","outerRadius","_getRotation","_getCircumference","_getRotationExtents","getMaxBorderWidth","getMaxOffset","_getRingWeight","ratioX","ratioY","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","borderAlign","hoverBorderWidth","hoverOffset","jn","angleLines","circular","pointLabels","bind","_updateRadius","cutoutPercentage","xCenter","yCenter","getIndexAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","$n","BarController","categoryPercentage","barPercentage","grouped","_index_","_value_","_getRuler","base","head","_calculateBarValuePixels","_calculateBarIndexPixels","enableBorderRadius","center","Vn","borderSkipped","Nn","inflateAmount","ratio","_getStacks","_getStackCount","_getStackIndex","barThickness","Rn","$bar","pixels","stackCount","minBarLength","skipNull","maxBarThickness","chunk","BubbleController","DoughnutController","LineController","_decimated","segment","animated","updateControlPoints","PieController","PolarAreaController","RadarController","line","getPointPositionForValue","ScatterController","Un","Xn","pixelMargin","outerStart","outerEnd","innerStart","innerEnd","Yn","borderRadius","Kn","lineCap","lineJoin","Gn","Zn","ilen","Jn","stepped","move","Qn","eo","Path2D","so","_path","_points","_segments","_pointsUpdated","pathSegment","path","no","hitRadius","oo","ao","ho","co","uo","ArcElement","fullCircles","qn","BarElement","inner","outer","ro","inXRange","inYRange","LineElement","PointElement","hoverRadius","go","po","mo","_startValue","_endValue","_valueRange","handleTickRangeOptions","getTickLimit","stepSize","computeTickLimit","step","precision","maxTicks","maxDigits","includeBounds","bo","xo","_o","yo","vo","wo","_zero","Mo","ko","So","To","getPointPosition","Lo","animate","centerPointLabels","drawingArea","_pointLabels","_pointLabelItems","_padding","Po","getPointLabelContext","Do","setCenterPoint","extra","additionalAngle","Co","Oo","getValueForDistanceFromCenter","getBasePosition","getPointLabelPosition","Ao","Eo","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","Ro","Io","zo","_adapter","parser","isoWeekday","_parseOpts","Fo","MAX_SAFE_INTEGER","Vo","Bo","Wo","adapters","time","unit","minUnit","displayFormats","_unit","_majorUnit","_offsets","_normalized","date","normalized","_getLabelBounds","getLabelTimestamps","_generate","_getLabelCapacity","initOffsets","offsetAfterAutoskip","getDecimalForValue","factor","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","_getLabelSize","No","Ho","CategoryScale","_addedLabels","fo","unshift","lastIndexOf","LinearScale","LogarithmicScale","RadialLinearScale","TimeScale","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","jo","$o","Yo","Uo","qo","forceOverride","Go","Zo","algorithm","beforeElementsUpdate","threshold","samples","Qo","ta","ea","ia","sa","la","ca","ha","aa","ra","above","below","area","da","ua","fa","ga","afterDatasetsUpdate","oa","$filler","na","propagate","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","ma","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","ba","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","_computeTitleHeight","_fitRows","_fitCols","row","itemWidth","xa","col","adjustHitBoxes","rtl","_draw","textDirection","lineDash","SQRT2","_getLegendItemAt","handleEvent","onLeave","_element","afterEvent","useBorderRadius","ya","_drawArgs","titleBlock","Ma","WeakMap","ka","average","Sa","Pa","String","Ca","body","footer","bodyFont","titleFont","footerFont","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","boxPadding","Aa","yAlign","xAlign","Oa","caretSize","caretPadding","Ta","cornerRadius","La","Ra","tooltip","callbacks","Ia","beforeTitle","afterTitle","beforeLabel","formattedValue","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","za","Fa","positioners","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","getTitle","getBeforeBody","getBody","getAfterBody","getFooter","_createItems","Da","itemSort","external","drawCaret","getCaretPosition","x3","y3","titleAlign","titleColor","_drawColorBox","multiKeyBackground","strokeRect","drawBody","bodyAlign","drawFooter","footerAlign","footerColor","quadraticCurveTo","_updateAnimationTarget","_willRender","globalAlpha","_positionChanged","_ignoreReplayEvents","afterInit","afterDraw","helpers","_adapters","Animation","Animations","animator","DatasetController","Element","Interaction","layouts","platforms","Scale","Ticks","Chart","exports","module","define","amd","globalThis","self","isNumberFinite","defaultValue","dimension","args","thisArg","loopable","len","a0","a1","v0","v1","klen","isValidKey","tval","sval","sources","current","keyResolvers","parts","tmp","part","obj","_getKeyResolver","str","item","epsilon","range","roundedRange","niceRange","fraction","result","rounded","array","degrees","radians","isFiniteNumber","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","pt1","pt2","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","table","cmp","mid","arrayEvents","listener","this","object","stub","argsToUse","ticking","timeout","animationsDisabled","pointCount","newRanges","Animator","undefined","anims","remaining","charts","cb","acc","cur","lim","p2b","n2b","b2n","n2p","map$1","hex","h1","h2","eq","isShort","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","rgb2hsl","hueValue","calln","hsl2rgb","hue","hueParse","p2","hwb2rgb","hsv2rgb","names$1","names","nameParse","unpacked","tkeys","ok","nk","unpack","RGB_RE","modHSL","proto","fromObject","input","functionParse","rgbParse","Color","ret","c1","c2","w2","w1","rgb1","rgb2","val","deg","intlCache","num","cacheKey","formatter","getNumberFormat","tickValue","delta","maxTick","calculateDelta","logDelta","numDecimal","remain","getScope","node","root","Defaults","_appliers","context","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","appliers","domNode","parent","parseMaxStyle","styleValue","parentProperty","valueInPixels","el","positions","getPositionedStyle","styles","suffix","useOffsetPos","borderBox","paddings","borders","getCanvasPosition","xOffset","yOffset","round1","bbWidth","bbHeight","margins","containerSize","container","containerStyle","containerBorder","containerPadding","getContainerSize","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","passiveSupported","matches","longest","textWidth","arrayOfThings","cache","jlen","thing","nestedThing","gcLen","pixel","halfWidth","xOffsetW","yOffsetW","rad","margin","flip","midpoint","decorateText","opts","metrics","yDecoration","drawBackdrop","oldColor","setRenderOpts","scopes","prefixes","rootScopes","fallback","getTarget","finalRootScopes","_resolve","prop","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getKeysFromAllScopes","storage","subProxy","descriptorDefaults","receiver","getValue","_resolveScriptable","arr","_resolveArray","_resolveWithContext","resolveFallback","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","getPoint","getValueAxis","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fb","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","controlPoints","prev","inArea","inAreaPrev","inAreaNext","atEdge","elasticIn","elasticOut","effects","cp1","cp2","LINE_HEIGHT","FONT_STYLE","numberOrZero","props","objProps","read","inputs","info","minmax","change","keepZero","parentContext","rectX","getRightToLeftAdapter","_itemWidth","direction","original","propertyFn","normalizeSegment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","sub","segmentOptions","findStartAndEnd","splitByStyles","solidSegments","chartContext","baseStyle","readStyle","prevStyle","addStyle","dir","styleChanged","doSplitByStyles","replacer","pixelSize","fontStyle","fontFamily","binarySearch","metaset","lookupMethod","handler","metasets","getIntersectItems","useFinalPosition","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getNearestItems","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","params","stacks","wrap","buildStacks","getCombinedMax","updateMaxPadding","updateDims","newWidth","newHeight","widthChanged","heightChanged","getMargins","marginForPositions","fitBoxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","visibleVerticalBoxCount","updatePos","handleMaxPadding","EXPANDO_KEY","EVENT_TYPES","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","createAttachObserver","observer","entries","trigger","entry","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","listenDevicePixelRatioChanges","releaseObserver","unlistenDevicePixelRatioChanges","createProxyAndListen","fromNativeEvent","addListener","renderHeight","renderWidth","displayWidth","displayHeight","initCanvas","proxies","interpolators","c0","helpersColor","cfg","currentValue","elapsed","promises","resolved","animationOptions","animatedProps","option","newOptions","resolveTargetOptions","anim","awaitAll","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","dsIndex","singleMode","otherValue","isStacked","getOrCreateStack","stackKey","indexValue","subStack","getLastIndexInStack","positive","updateStacks","iAxis","vAxis","indexScale","valueScale","getStackKey","getFirstScaleId","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","static","chooseId","xid","yid","rid","iid","vid","scaleID","adata","convertObjectDataToArray","resetNewElements","stackChanged","oldStacked","scopeKeys","sorted","isNotInOrderComparedToPrev","singleScale","parsedValue","canStack","otherScale","createStack","otherMin","otherMax","_skip","toClip","defaultClip","createDataContext","createDatasetContext","elementType","sharing","transition","firstOpts","previouslySharedOptions","arg1","arg2","numMeta","numData","removed","newCount","final","tickOpts","determinedMaxTicks","maxScale","maxChart","determineMaxTicks","ticksLimit","majorIndices","getMajorIndices","numMajorIndices","newTicks","skipMajors","evenMajorSpacing","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","edge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","reverseAlign","super","metas","samplingEnabled","startPixel","endPixel","reversePixels","numTicks","maxLabelDiagonal","labelSizes","maxLabelWidth","maxLabelHeight","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","isRotated","labelsBelowTicks","offsetLeft","offsetRight","caches","tickFont","nestedLabel","widestLabelSize","highestLabelSize","valueAt","idx","decimal","createTickContext","optionTicks","rot","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","positionAxisID","limit","optsAtIndex","optsAtIndexBorder","lineColor","tickAndPadding","hTickAndPadding","lineCount","halfCount","tickTextAlign","labelPadding","drawLine","lastLineWidth","renderTextOptions","titleArgs","tz","gz","bz","axisID","fontSize","TypedRegistry","parentScope","isIChartComponent","itemDefaults","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","Registry","typedRegistry","arg","reg","itemReg","component","camelMethod","PluginService","hook","descriptor","callCallback","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","scaleOptions","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","initConfig","datasetType","mainScope","resetCache","keyLists","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","getCanvas","moveNumericKeys","intKey","invalidatePlugins","userConfig","initialCanvas","existingChart","newSize","newRatio","axisOptions","scaleOpts","updated","isRadial","scaleType","hasUpdated","newControllers","ControllerClass","animsDisabled","existingEvents","newEvents","changes","datasetCount","makeSet","changeSet","noArea","layers","useClip","getDatasetArea","_add","_remove","detached","activeElements","lastActive","pluginId","hoverOptions","deactivated","activated","eventFilter","isClick","lastEvent","determineLastEvent","abstract","DateAdapterBase","members","computeMinSampleSize","visibleMetas","getAllScaleValues","curr","updateMinAndPrev","parseValue","startValue","endValue","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","borderProps","parseEdge","orig","v2","startEnd","setInflateAmount","legendItem","getter","arcs","maxSize","chartWeight","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","animationOpts","centerX","centerY","metaData","ringWeightOffset","datasetStartAngle","defaultAngle","iAxisKey","vAxisKey","bars","ruler","vpixels","ipixels","baseValue","actualBase","floating","barSign","halfGrid","Infinity","percent","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","pointPosition","parseBorderRadius","angleDelta","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","rThetaToXY","theta","pathArc","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","angleMargin","clipArc","setStyle","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","lineMethod","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","strokePathWithCache","segmentMethod","strokePathDirect","_interpolate","_getInterpolationMethod","interpolated","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","addRectPath","mouseX","mouseY","findOrAddLabel","addedLabels","addIfString","_getLabelForValue","relativeLabelSize","minSpacing","LinearScaleBase","setMin","setMax","minSign","maxSign","generationOptions","dataRange","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks","log10Floor","changeExponent","isMajor","tickVal","rangeExp","rangeStep","minExp","exp","startExp","lastTick","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","pointLabelOpts","plFont","textSize","updateLimits","itemOpts","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","labelCount","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","drawPointLabels","gridLineOpts","drawRadiusLine","INTERVALS","UNITS","sorter","adapter","determineUnitForAutoTicks","capacity","interval","addTick","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","_applyBounds","timeOpts","determineUnitForFormatting","determineMajorUnit","weekday","hasWeekday","fmt","minorFormat","majorFormat","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","added","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","plugin_colors","_args","chartOptions","colorizer","cleanDecimatedDataset","cleanDecimatedData","plugin_decimation","xAxis","getStartAndCountOfVisiblePointsSimplified","decimated","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_pointsFromSegments","_shouldApplyFill","_resolveTarget","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","getBoxSize","labelOpts","labelFont","hitboxes","totalHeight","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","rtlHelper","hitbox","defaultColor","halfFontSize","cursor","drawOptions","yBoxTop","xBoxLeft","drawLegendBox","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","isListened","hoveredItem","sameItem","plugin_legend","fontOpts","plugin_title","createTitle","plugin_subtitle","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","createTooltipItem","getTooltipSize","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","widthPadding","maxLineWidth","determineXAlign","chartWidth","caret","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","tooltipItem","invokeCallbackWithFallback","bodyItems","scoped","positionAndSize","backgroundPoint","tooltipPoint","caretPosition","ptX","ptY","colorX","rtlColorX","yOffSet","colorY","outerX","innerX","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","tooltipSize","animX","animY","hasTooltipContent","positionChanged","plugin_tooltip"],"version":3,"file":"index.2e60a0a1.js.map"}